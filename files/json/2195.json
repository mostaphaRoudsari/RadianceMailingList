{"refs": ["<BAY102-F198EF7F777CF434858D064A4F30@phx.gbl>"], "id": "<68969C85-9DC0-4BFC-A087-650AE3F3C321@gmail.com>", "subject": "[Radiance-general] Mesh Rendering Performan", "email": "gregoryjward at gmail.com", "body": "\nHi Marcus,\n\nIt doesn't surprise me that much that the mesh intersection routines\nare slower.  Many more operations are required to compute the ray-\ntriangle intersection when the plane equation is unknown.  I chose\nnot to store the plane equation because it would approximately triple\nthe amount of memory used per triangle during rendering, and the\nwhole point of the mesh primitive is to minimize memory use.  It's a\nclassic time/space trade-off.  The performance would be even worse if\nit weren't for the edge caching, which takes only a modest amount of\nmemory.\n\nThe other thing that costs is transforming the ray before and after\nintersection, similar to having an octree instance (which it is).\nBreaking the mesh into smaller pieces may or may not help matters,\ndepending on how compact the mesh octree is.  In other words, it's a\ngood idea to use multiple object meshes if the combined mesh is\nspread mostly in one or two dimensions, or is very sparsely populated\nby geometry.  That way, you can avoid many of the the voxel\ncomputations through empty space.  However, just like octree\ninstances, it doesn't pay to have many overlapping mesh bounding cubes.\n\nI hope this helps.\n-Greg\n\nP.S.  Meshes are faster in any case when you have local (u,v) texture\ncoordinates.\n\n\n", "isquestion": false, "replyTo": "Subject: [Radiance-general] Mesh Rendering Performanc", "tags": [], "sender": "Greg Ward", "datetime": "Sat Feb 25 02:13:54 2006"}