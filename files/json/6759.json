{"refs": ["<OF8AF61F94.3FA8FC6E-ONC1257928.0033B10A-C1257928.0033C9D6@ise.fhg.de>"], "id": "<3240FF28-08F5-4300-84F9-C2F05F1EE2A0@lmi.net>", "subject": "[Radiance-general] rtcontrib -n", "email": "gregoryjward at gmail.com", "body": "\nHello Wendelin,\n\nGood sleuth work, but in fact since rtcontrib doesn't employ the -n option of rtrace, the flushing behavior doesn't affect efficiency in this case.  The problem is that the controlling process in rtcontrib is often the bottleneck in these calculations.  Unless each primary ray sent to rtrace spawns many, many daughter rays, most of the time overall will be spent communicating with and collecting results from the multiple rtrace child processes that the rtcontrib parent process creates.\n\nI have looked at the possibility of changing the way I partition the problem to put more work into the subprocesses, but the logic for that has thus far eluded me.  The rtcontrib program is quite complicated, and I would rather not increase its complexity further.  The only way I've found to effectively speed up rtcontrib on multiple cores when each rtrace process is churning through many rays quickly is to subdivide the input and reassemble it at the end.  This is a bit painful and requires some book-keeping on the part of the user, but for difficult or repetitive problems it may be worth the effort.\n\nBest of luck,\n-Greg\n\n\n\n", "isquestion": false, "replyTo": "Subject: [Radiance-general] rtcontrib", "tags": [], "sender": "Greg Ward", "datetime": "Thu, 13 Oct 2011 07:17:42 -0700"}