{"refs": ["<CAMxTbri9-2+CYCjBe0O80GN9NDWvhnsWT=TTheAKi96faYM-uA@mail.gmail.com>", "<50825B2F.7040505@gmx.net>", "<CAD83LVKQ97JZoyCnB=jvPqJUyENxdhtUhxV7UWSbv6yjCrkJww@mail.gmail.com>", "<508407FC.8040408@gmx.net>", "<CAD83LVLba8_qYttjoM2f=2E6SJBhx5o4CJXqePuH6nozhfkJkQ@mail.gmail.com>"], "id": "<845F404E-414E-49AC-BD4E-BF707FF4AFE7@gmx.net>", "subject": "[Radiance-general] sky visibility", "email": "grobe at gmx.net", "body": "\nHi Ji Zhang!\n\n\nThe problem here probably is, that your fisheye view -vta produces pixel values outside the circular image you would expect. These get counted in the total number of pixels. So if you are using -vta, you need  way to filter pixels lying outside the circle. Several approaches to do so come to my mind. A generic one is:\n\n1) vwrays -vta into a scene consisting only of a source, corresponding to the hemisphere you want to sample\n2) pipe the output to rtrace, check for intersections with the source and get origin and direction vectors\n3) pipe that into rtrace again, this time checking for your pixel values as above...\n\nStill, there is a problem with the -vta (equiangular) fisheye not being a equisolid fisheye, so pixels do not represent equal solid angles.... for sky view factors, that is what you would want, but for your definition, you want the ration (solid angle visible sky) / (solid angle sky without obstructions). So either calculate the solid angle of the pixel depending on the distance from view centre, or go with rpict, create a fisheye image (-vta), and use the S and T functions to filter pixels outside the view and to weigh pixels by their solid angle. So in above commands, you would not set the pixel value to 0 or 1, but to 0 or S(n).\n\nAgain, I could not try out all this and send a complete example, just trying to point you to some direction.\n\nCheers, Lars.\n\n\n\n", "isquestion": false, "replyTo": "Subject: [Radiance-general] sky visibilit", "tags": [], "sender": "Lars O. Grobe", "datetime": "Tue, 23 Oct 2012 10:40:11 +0200"}