{"body": "I didn't cross-post this to radiance-general...\n\n\n > Georg Mischler wrote:\n> This just reminds me of another problem that we'll have to solve\n> in this context. Since Windows doesn't support NFS file locking\n> (and neither did cygwin, last time I looked), we'll need to find\n> a better solution for concurrent access to ambient files. I can\n> think of two portable ways to do this: Either we invent a file\n> based locking mechanism, or we establish a seperate server\n> process that accepts network store and retreival requests by the\n> actual simulation processes. The latter would be more technicall\n> involved, but probably a lot more robust. Any thoughts?\n\n\nEwww.  Can't we just say that if you want to do parallel rendering, you \nneed to install Unix?\n\n\n> > Autoconf...scares me.  It's one of the most difficult scripting\n> > languages and it actively encourages #ifdef-laden code.  Personally, I\n> > favor the Kernighan and Pike (*The Practice of Programming*) approach\n> > to portability; write the base code portably, and bottle up the OS\n> > dependencies in separate libraries and APIs.\n>\n> I don't think that those two approaches are mutually exclusive.\n> Some more complex dependencies certainly belong into seperate\n> modules with a thick layer of barbed wire around them. But there\n> are also many other small variations and bugs among different\n> systems with no clear borderlines between vendors, kernel and\n> library versions, etc. Keeping track of those without a tool like\n> autoconf is a real pain for both developers and users.\n>\n> Have you had a look at the makeall script lately? This is\n> complexity that the user has to handle when something goes wrong.\n> Autoconf is generally a one-time effort, that only needs to be\n> handled by one or two of the developers. Once that is done, the\n> trusty mantra of \"./configure; make; make install\" just magically\n> works on pretty much any system, whether its specific quirks have\n> been cataloged before or not. Not every user can grant Greg ssh\n> access to solve compile problems, and Greg probably wouldn't have\n> the time to do this for every user anyway.\n>\n> The Radiance sources are currently littered with hundreds of\n> instances of preprocessor symbols referencing more than a dozen\n> individual operating systems. This has almost worked yesterday,\n> it's already breaking today with very current systems, and it's\n> garanteed to break in the future, unless someone constantly keeps\n> a list of all the systems out there and their specific bugs and\n> other nonstandard behaviour. I will chose #ifdefs of the form\n> \"HAS_<feature>\" any time, against the alternative of multiple\n> nested OS specific conditionals in the same place.\n\n\nOK, that's a bit of an exaggeration.  I did a quick grep of the source \ntree, and I found 8 instances of system-dependent code in 6 files.  \nThese are typically limited to a #define or a declaration or two, and I \nexpect that we could eliminate most of these with a little effort -- \nmuch less than it would take to change over to a HAS_<feature> sort of \ncoding strategy.  I've found that by doing some homework, it is usually \npossible to find a solution that works on all systems without any \nconditional compiles.  The ones that are in there now are either \nnecessary because there aren't any general solutions, or more likely, \nthey could be eliminated.  The least-common-denominator approach to \nportability is still the best in my opinion.  You miss out on a few \nfeatures on a few systems, but you get a more consistent result in the \nend (with cleaner code).\n\n\n> > Peter Apian-Bennewitz wrote:\n> > > However, that interface is not changed solely by prototyping \n> functions.\n> > > Doing more than that risks new bugs- well, we'll get them out. Maybe\n> > > there's a core structure between just-prototypes and a full \n> rewrite ?\n> >\n> > Hmmmm...Radiance plug-ins.  Most Unices support some version of\n> > dynamic loading these days.  Windows does.  I don't think Plan 9 \n> does...\n>\n> Prototypes and the elimination of global variables will make the\n> *internal* interfaces of Radiance a lot clearer and more obvious\n> than they are right now. After that, it will be much easier to\n> isolate those parts that need to be changed to better accomodate\n> any present or future extensions, and the risk of breaking all\n> the rest when doing so will become much smaller.\n\n\nI support this suggestion whole-heartedly.  The global variables \ncurrently in use in the renderers could be eliminated with a single \nstructure and a reference to it in the ray struct.  In principle, the \nbulk of the renderer could then be consolidated into a library, which \ncould be multi-threaded with a bit more work....\n\n\n> > Now, I'm interested in ways to standardize the GUI API.  In my\n> > opinion, it would be useful if we could customize ximage and rview to\n> > native OS conventions easily, perhaps by providing an OS specific\n> > library.  It might also be useful to embed the core rendering tools in\n> > a dynamic loading environment.  But, again, I don't know what it would\n> > take.\n>\n> You're not the first one to think that thought.\n>\n> In the end it won't really take a lot of effort, but only after\n> the above steps have been taken. Despite all its shortcomings,\n> the Windows version of rview already points into the right\n> direction here, by demonstrating approximately where the\n> interfaces between the simulation core and a display framework\n> should be placed. Unfortunately, the existing implementation is a\n> horrible mess, due to the difficulties of integrating the current\n> Radiance code on one hand, and some other obstacles the original\n> developers were facing on the other. I realize that most of you\n> haven't seen those sources yet, so you'll simply have to take my\n> word for it... ;)\n\n\nI haven't seen this code, either, and from what you say, I'm not sure I \nwant to...  I thought I had defined an interface for rview pretty well \nin rt/driver.h.  This is where I began when I wrote different drivers.  \n(There was a little-used NeWS driver at one time, as well as one for \nSuntools -- anyone remember those systems?)  As for ximage, this program \nwas meant to be replaced in its entirety, not built upon.  I assume \nthat's what they did for Windows, but I don't know.  The programming \ninterface for image display is the Radiance picture format!\n___\n<sup>Automatically generated content from [radiance mailing-list](https://radiance-online.org/pipermail/radiance-dev/2002-June/000002.html).</sup>", "attachments": [], "created_by_name": "Greg Ward", "created_at": "June 12, 2002 at 09:57AM", "created_by": "Greg_Ward", "parent_id": "radiance-dev_000000", "id": "radiance-dev_000002"}