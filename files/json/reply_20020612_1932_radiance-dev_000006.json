{"body": "I accidentally sent this to Greg directly instead of to the list.\nPeter, could you set the Reply-to to the list for this one as well?\n\n\n\n\nGreg Ward wrote:\n\n\n> Ewww.  Can't we just say that if you want to do parallel rendering, you\n> need to install Unix?\n\n\nHehe...\n\n\nIf you were asking me for my purely emotional response, then\nyou'd probably like my answer better than the one you'll actually\nget. But I think we should face reality and accept that in the\nnear future, most people using Radiance will be sitting in front\nof Windows boxes.\n\n\nThey may well be sending long simulations to some linux cluster\nin the basement, but their CAD system will probably run under\nWindows, and having to switch back and forth more of a pain than\nworking with the \"wrong\" system all the time. Others will really\ndistribute stuff across their Windows network, as not everybody\nmay have the funding for establishing a parallel infrastructure\njust for Radiance.\n\n\nMaybe what we really need is some kind of switch that allows to\naccess different locking mechanisms depending on the situation. I\ndidn't check in detail, but I assume there are two functions, one\nfor fetching ambient data and one for storing it. Such a very\nnarrow interface lends itself relatively well to this approach.\nIt's not that I can easily pull a good file or server based\nlocking strategy out of my ears, but I think it would be worth a\nlittle effort. We have had enough problems with NFS locking in\nthe past to appreciate the advantages that a working and truly\nportable solution will bring.\n\n\n\n\n> > The Radiance sources are currently littered with hundreds of\n> > instances of preprocessor symbols referencing more than a dozen\n> > individual operating systems. This has almost worked yesterday,\n\n\n> OK, that's a bit of an exaggeration.\n\n\nI wasn't really exaggerating that much as far as the numbers go.\nBut of course I didn't check how many of those are really still\nneeded or could be eliminated in other ways. I'm not sure, for\nexample, how many of the MSDOS special cases are really still\nrequired on modern Windows systems, and most of the UNIX\nconditionals may fall away with the reverse argument. Those and\nBSD seem to be responsible for more than half the OS specific code.\n\n\nI also didn't mean to insinuate that we need autoconv right now\nand at any price. I think we'll know more about what we really\nneed after ANSIfication, as this may already eliminate quite a\nfew dependencies.  If we then end up with so little that a\nhomebrew script gets us the same result, so much the better. The\ndifferences between BSD and SYSV have been reduced to a large\ndegree by the ongoing implementation of the posix standards by\nmost vendors.\n\n\n\n\n> > Prototypes and the elimination of global variables will make the\n> > *internal* interfaces of Radiance a lot clearer and more obvious\n> > than they are right now.\n>\n> I support this suggestion whole-heartedly. The global variables\n> currently in use in the renderers could be eliminated with a single\n> structure and a reference to it in the ray struct. In principle, the\n> bulk of the renderer could then be consolidated into a library, which\n> could be multi-threaded with a bit more work....\n\n\nI was actually thinking about a slightly finer granularity, but I\nguess we'll see what makes sense when we get there. One of the\nmore interesting tasks might turn out to be the elimination of\nexit() calls in code that is considered part of a library. I\ndon't think there's any part of Radiance that currently hesitates\nto kill the whole process whenever something goes wrong, which\nwould be very surprising for a program using such a library.\n\n\n\n\n> > I realize that most of you\n> > haven't seen those sources yet, so you'll simply have to take my\n> > word for it... ;)\n>\n> I haven't seen this code, either, and from what you say, I'm not sure I\n> want to...\n\n\nWell, it's C++ code for Windows, apparently written by someone\nwho didn't bother to read the very decent documentation about the\nsystem APIs coming with his compiler and IDE. I'm clearly no\nexpert in Windows programming (let alone in C++), but there's no\nfeeling of loneliness in that corner...\n\n\n\n\n> I thought I had defined an interface for rview pretty well\n> in rt/driver.h.  This is where I began when I wrote different drivers.\n> (There was a little-used NeWS driver at one time, as well as one for\n> Suntools -- anyone remember those systems?)  As for ximage, this program\n> was meant to be replaced in its entirety, not built upon.  I assume\n> that's what they did for Windows, but I don't know.\n\n\nI couldn't say for sure. My primary fight was on the Windows\nside, to turn the whole thing into a conforming and well behaved\nprogram (with at least partial success). As far as I remember\nright now, they directly hooked into the raytracing routines.\n\n\nOne of the trickier problems is how to make the raytracer return\nprematurely out of its recursive ambient calculations upon user\ninput. The lack of this possibility (and thus often significantly\ndelayed response) can also be quite annoying with ximage. On Windows\nthis becomes a serious issue, as you can't just kill a program\nwithout the risk of losing a bunch of system resources.\n\n\nI'm not sure if I understand the concept behind driver.h\ncorrectly yet. It looks like it wants to do all the event\nhandling itself, and reduces the \"driver\" to subordinate tasks\nlike providing mouse coordinates etc.  Modern window management\nsystems rather lend itself to the opposite approach, where the\nuser interface runs the event loop and calls the simulation code\nin the background (possible in a seperate thread). This makes it\npossible to offer menus and other interaction possibilities,\nwhich gives the user better control about what happens.\n\n\nThe possibility to interrupt the simulation at any point in its\nrecursion is mandatory to garantee this responsiveness.  As far\nas I could figure out, this possibility isn't currently\nimplemented (and the implementation in winimage is not as clean\nas it should be). I haven't checked if the holodeck stuff does\nanything different in that regard.\n\n\n\n\n> The programming\n> interface for image display is the Radiance picture format!\n\n\nHmmm... and reinvent all the tonemapping stuff?\n\n\n\n\n-schorsch\n\n\n\n\nGeorg Mischler  --  simulations developer  --  schorsch at schorsch.com\n+schorsch.com+  --  lighting design tools  --  http://www.schorsch.com/\n___\n<sup>Automatically generated content from [radiance mailing-list](https://radiance-online.org/pipermail/radiance-dev/2002-June/000006.html).</sup>", "attachments": [], "created_by_name": "Georg Mischler", "created_at": "June 12, 2002 at 07:32PM", "created_by": "Georg_Mischler", "parent_id": "radiance-dev_000000", "id": "radiance-dev_000006"}