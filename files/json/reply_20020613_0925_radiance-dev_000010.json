{"body": "On Thu, Jun 13, 2002 at 10:14:23AM -0400, Georg Mischler wrote:\n> \n> > Another reason to use a file lock manager rather than a server process\n> > besides simplicity is that the lock manager is robust to individual\n> > systems going down (or should be), whereas everything dies if your\n> > server process dies.  What about Chas' suggestion of offering Samba as a\n> > substitute lock manager?\n> \n> The lock manager ultimately dies with the machine where the\n> locked file resides, which is just as good or bad. Ideally, any\n> other server process would run on this same machine as well. Only\n> when this isn't possible will there be two seperate points of\n> failure.\n> \n\n\nIt seems like establishing a Radiance locking manager--perhaps just a\nproblem which managed the global ambient file--might be a good idea.\nNFS locking doesn't even work on all systems, unfortunately, so that\nwould also fix that problem.\n\n\n> \n> > >  One of the\n> > > more interesting tasks might turn out to be the elimination of\n> > > exit() calls in code that is considered part of a library. I\n> > > don't think there's any part of Radiance that currently hesitates\n> > > to kill the whole process whenever something goes wrong, which\n> > > would be very surprising for a program using such a library.\n> >\n> > Ah, yes.  I agree -- although I usually call quit(), which then calls\n> > exit() if it isn't overridden by the calling program.  The only way to\n> > avoid exit() is with a long jump, however, and this is not a generally\n> > recommended practice, so it remains a problem.\n> \n\n\nI believe longjmp() has been standardized in ANSI C, so this has become\nsafer.\n\n\n> \n> Maybe, maybe not. There are at least two levels of thread safety.\n> One is to have the critical code running independently in its own\n> thread *once*, which is no problem as long as there aren't any\n> global variables. The other would be to allow several instances\n> running in parallel threads, which in addition requires the\n> elimination of all static variables in functions. I think both\n> conditions could be met quite easily when all state (including\n> any stop condition flags that the parent thread might want to\n> set) is encapsulated eg. in the ray struct. Future mode again,\n> though.\n> \n\n\nThis, plus the previous issue is starting to be a powerful argument\nfor C++, which solves this problem by making globals into instance\nvariables and the exit problem with the exception mechanism.  With a\nhypothetical C++ embedded renderer one could simply instantiate a\nrenderer object.\n\n\nOK, then....looking at C++...I think it might be possible.  If we left\nmost of the code as straight C, not using the fancy OO features, only\ngathering up--no, wait.  We could combine the two solutions.  Gather up\nthe globals into a structure which is referenced throughout the\nrenderer and use longjmp() to handle exceptions.  Then wrap the whole\nthing up in a C++ (or Objective C) class.  The only issue I can\nsee--and it is potentially major--would be potential memory leaks.\n\n\nRandolph\n___\n<sup>Automatically generated content from [radiance mailing-list](https://radiance-online.org/pipermail/radiance-dev/2002-June/000010.html).</sup>", "attachments": [], "created_by_name": "Randolph Fritz", "created_at": "June 13, 2002 at 09:25AM", "created_by": "Randolph_Fritz", "parent_id": "radiance-dev_000000", "id": "radiance-dev_000010"}