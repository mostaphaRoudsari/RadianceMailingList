{"body": "--0-2106539197-1023987040=:49654\nContent-Type: text/plain; charset=us-ascii\n\n\n\n\n I see that Peter fixed the reply-to field.  Thank you!\nThe samba code is not part of the current Radiance for Windows release built with MS VC++.  It was part of the Desktop Radiance BETA release built with the Cygwin version of Radiance for Windows.  Samba works multi-directionally from Unix client to Windows server, Unix client to Unix Samba server, Windows client to Unix Samba server, and of course, Windows client to Windows server.  We tested each of these configurations.  The kernel of the server cpu will know about the file lock.  You ask a good question about what happens when an NFS lock tries to get ahold of the file?  I dunno.  I presume the lock fails or hangs the client CPU like NFS usually does. :-)  Samba exists for just about every flavor of Unix known, Macintosh OSX included, and it is reliable and has a dedicated open source support staff.  Even older Mac's can use a low-cost proprietary solution called DAVE.\nIf we're going to implement a custom file locking mechanism, then why reinvent the wheel?  There have got to be several different open source file locking systems.  What about PovRay?  They've stolen enough from Radiance...perhaps it our turn to collect. :-)  The Samba mods are just a no-brainer.  About 30 lines of code max.\n-Chas\n  Georg Mischler <schorsch@schorsch.com> wrote: Greg Ward wrote:\n\n\n> Having dealt just a little with Windows networks, I have to say that my\n> interest in supporting them is identically 0 over all time and space.\n> I'll leave it to you and others who think it worthwhile.\n\n\nVery understandably. I'd like to try to stay away from any\nWindows specific stuff as much as possible myself. Any solution\nshould be either file or IP based, to make it portable across\nall platforms.\n\n\n\n\n> Another reason to use a file lock manager rather than a server process\n> besides simplicity is that the lock manager is robust to individual\n> systems going down (or should be), whereas everything dies if your\n> server process dies. What about Chas' suggestion of offering Samba as a\n> substitute lock manager?\n\n\nThe lock manager ultimately dies with the machine where the\nlocked file resides, which is just as good or bad. Ideally, any\nother server process would run on this same machine as well. Only\nwhen this isn't possible will there be two seperate points of\nfailure.\n\n\nI'm not sure yet what Samba exactly does here, apart from the\nfact that it involves yet another extra server process. One one\nside, Samba offers the standard Windows network locking API to\nprocesses connecting from that end. And it looks like it *can*\ntranslate those into flock() calls on the unix side. Does this\nmean that unix processes accessing the same file per NFS would\nsee the lock too?\n\n\nChas, is this code included in the Radiance for Windows sources I\nhave or was it added later? Because I'm pretty sure that my\nversion corrupts the ambient files on concurrent access.\nThe ultimate goal should be that every process on every OS type\ncan access the same file without getting in each others way.\n\n\n\n\n> > One of the\n> > more interesting tasks might turn out to be the elimination of\n> > exit() calls in code that is considered part of a library. I\n> > don't think there's any part of Radiance that currently hesitates\n> > to kill the whole process whenever something goes wrong, which\n> > would be very surprising for a program using such a library.\n>\n> Ah, yes. I agree -- although I usually call quit(), which then calls\n> exit() if it isn't overridden by the calling program. The only way to\n> avoid exit() is with a long jump, however, and this is not a generally\n> recommended practice, so it remains a problem.\n\n\nOne of my modifications to winrview was to establish a safe\nreturn path from very deep recursion levels when user interaction\nstops the current simulation. This may involve a few additional\nreturn value checks, but I think in this specific case those were\nalready in place. Similar scenarios, in the worst case with an\nextra flag somewhere to indicate an error condition, should be\npossible in most if not all places where exit/quit are invoked.\nBut I think we're discussing pretty far in future mode here already...\n\n\n\n\n> If the ambient calculation is the only barrier to responsiveness in\n> rview, it wouldn't be too difficult to query the value of some variable\n> set asynchronously by the caller and make a hasty retreat.\n\n\nYup, exactly.\n\n\n\n\n> However,\n> we'd have to work long and hard before we got the renderer code into\n> thread-safe shape.\n\n\nMaybe, maybe not. There are at least two levels of thread safety.\nOne is to have the critical code running independently in its own\nthread *once*, which is no problem as long as there aren't any\nglobal variables. The other would be to allow several instances\nrunning in parallel threads, which in addition requires the\nelimination of all static variables in functions. I think both\nconditions could be met quite easily when all state (including\nany stop condition flags that the parent thread might want to\nset) is encapsulated eg. in the ray struct. Future mode again,\nthough.\n\n\n\n\n> Another option is to use the Unix signal facility to\n> send an interrupt to the rendering process, causing premature\n> termination of any ambient calculation in progress. This wouldn't\n> require much coding effort at all.\n\n\nUnfortunately, signals and Windows don't match very well...\n\n\n\n\n> Another, possibly better solution would be to have the renderer call a\n> global \"checkInput()\" routine every so many rays, which is the way rview\n> is _supposed_ to work but doesn't, simply because the call to\n> checkInput() is handled at too high a level. If we moved this into the\n> low-level raytrace() routine, I think we'd have responsiveness licked\n> without having to change to a background rendering process. I might\n> even give this a go to try it out.\n\n\nWhichever stopping signalization is chosen should indeed be\nchecked somewhere down there. Winrview currently does this at the\nbeginning of ambient(), sets a flag for the original caller (not\nreally necessary), assigns zero values to the current rgb set\n(should probably use the ambient values instead), and returns.\nI don't know if this is the optimal place to do this, but it\nworked well enough for me at the time.\n\n\n\n\n-schorsch\n\n\n\n\nGeorg Mischler -- simulations developer -- schorsch at schorsch.com\n+schorsch.com+ -- lighting design tools -- http://www.schorsch.com/\n\n\n_______________________________________________\nRadiance-dev mailing list\nRadiance-dev@radiance-online.org\nhttp://www.radiance-online.org/mailman/listinfo/radiance-dev\n\n\n\n\n\n\nDo You Yahoo!?\nSign-up for Video Highlights of 2002 FIFA World Cup\n--0-2106539197-1023987040=:49654\nContent-Type: text/html; charset=us-ascii\n\n\n<P> I see that Peter fixed the reply-to field.&nbsp; Thank you!\n<P>The samba code is <STRONG>not</STRONG> part of the current Radiance for Windows release built with MS VC++.&nbsp; It was part of the Desktop Radiance BETA release built with the Cygwin version of Radiance for Windows.&nbsp; Samba works multi-directionally from Unix client to Windows server, Unix client to Unix Samba server, Windows client to Unix Samba server, and of course, Windows client to Windows server.&nbsp; We tested&nbsp;each of&nbsp;these configurations.&nbsp;&nbsp;The kernel&nbsp;of the server cpu will know about the file lock.&nbsp; You ask a good question about what happens when an NFS lock tries to get ahold of the file?&nbsp; I dunno.&nbsp; I presume the lock&nbsp;fails or hangs the client CPU like NFS usually does. :-)&nbsp; Samba exists for just about every flavor of Unix known, Macintosh OSX included, and it is reliable and has a dedicated open source support staff.&nbsp; Even older Mac's can use a low-cost proprietary solution called DAVE.\n<P>If we're going to implement a custom file locking mechanism, then why reinvent the wheel?&nbsp; There have got to be several different open source file locking systems.&nbsp; What about PovRay?&nbsp; They've stolen enough from Radiance...perhaps it our turn to collect. :-)&nbsp; The Samba mods are just a no-brainer.&nbsp; About 30 lines of code max.\n<P>-Chas\n<P>&nbsp; <B><I>Georg Mischler &lt;schorsch@schorsch.com&gt;</I></B> wrote: \n<BLOCKQUOTE style=\"PADDING-LEFT: 5px; MARGIN-LEFT: 5px; BORDER-LEFT: #1010ff 2px solid\">Greg Ward wrote:<BR><BR>&gt; Having dealt just a little with Windows networks, I have to say that my<BR>&gt; interest in supporting them is identically 0 over all time and space.<BR>&gt; I'll leave it to you and others who think it worthwhile.<BR><BR>Very understandably. I'd like to try to stay away from any<BR>Windows specific stuff as much as possible myself. Any solution<BR>should be either file or IP based, to make it portable across<BR>all platforms.<BR><BR><BR>&gt; Another reason to use a file lock manager rather than a server process<BR>&gt; besides simplicity is that the lock manager is robust to individual<BR>&gt; systems going down (or should be), whereas everything dies if your<BR>&gt; server process dies. What about Chas' suggestion of offering Samba as a<BR>&gt; substitute lock manager?<BR><BR>The lock manager ultimately dies with the machine where the<BR>locked file resides, which is just as good or bad. Ideally, any<BR>other server process would run on this same machine as well. Only<BR>when this isn't possible will there be two seperate points of<BR>failure.<BR><BR>I'm not sure yet what Samba exactly does here, apart from the<BR>fact that it involves yet another extra server process. One one<BR>side, Samba offers the standard Windows network locking API to<BR>processes connecting from that end. And it looks like it *can*<BR>translate those into flock() calls on the unix side. Does this<BR>mean that unix processes accessing the same file per NFS would<BR>see the lock too?<BR><BR>Chas, is this code included in the Radiance for Windows sources I<BR>have or was it added later? Because I'm pretty sure that my<BR>version corrupts the ambient files on concurrent access.<BR>The ultimate goal should be that every process on every OS type<BR>can access the same file without getting in each others way.<BR><BR><BR>&gt; &gt; One of the<BR>&gt; &gt; more interesting tasks might turn out to be the elimination of<BR>&gt; &gt; exit() calls in code that is considered part of a library. I<BR>&gt; &gt; don't think there's any part of Radiance that currently hesitates<BR>&gt; &gt; to kill the whole process whenever something goes wrong, which<BR>&gt; &gt; would be very surprising for a program using such a library.<BR>&gt;<BR>&gt; Ah, yes. I agree -- although I usually call quit(), which then calls<BR>&gt; exit() if it isn't overridden by the calling program. The only way to<BR>&gt; avoid exit() is with a long jump, however, and this is not a generally<BR>&gt; recommended practice, so it remains a problem.<BR><BR>One of my modifications to winrview was to establish a safe<BR>return path from very deep recursion levels when user interaction<BR>stops the current simulation. This may involve a few additional<BR>return value checks, but I think in this specific case those were<BR>already in place. Similar scenarios, in the worst case with an<BR>extra flag somewhere to indicate an error condition, should be<BR>possible in most if not all places where exit/quit are invoked.<BR>But I think we're discussing pretty far in future mode here already...<BR><BR><BR>&gt; If the ambient calculation is the only barrier to responsiveness in<BR>&gt; rview, it wouldn't be too difficult to query the value of some variable<BR>&gt; set asynchronously by the caller and make a hasty retreat.<BR><BR>Yup, exactly.<BR><BR><BR>&gt; However,<BR>&gt; we'd have to work long and hard before we got the renderer code into<BR>&gt; thread-safe shape.<BR><BR>Maybe, maybe not. There are at least two levels of thread safety.<BR>One is to have the critical code running independently in its own<BR>thread *once*, which is no problem as long as there aren't any<BR>global variables. The other would be to allow several instances<BR>running in parallel threads, which in addition requires the<BR>elimination of all static variables in functions. I think both<BR>conditions could be met quite easily when all state (including<BR>any stop condition flags that the parent thread might want to<BR>set) is encapsulated eg. in the ray struct. Future mode again,<BR>though.<BR><BR><BR>&gt; Another option is to use the Unix signal facility to<BR>&gt; send an interrupt to the rendering process, causing premature<BR>&gt; termination of any ambient calculation in progress. This wouldn't<BR>&gt; require much coding effort at all.<BR><BR>Unfortunately, signals and Windows don't match very well...<BR><BR><BR>&gt; Another, possibly better solution would be to have the renderer call a<BR>&gt; global \"checkInput()\" routine every so many rays, which is the way rview<BR>&gt; is _supposed_ to work but doesn't, simply because the call to<BR>&gt; checkInput() is handled at too high a level. If we moved this into the<BR>&gt; low-level raytrace() routine, I think we'd have responsiveness licked<BR>&gt; without having to change to a background rendering process. I might<BR>&gt; even give this a go to try it out.<BR><BR>Whichever stopping signalization is chosen should indeed be<BR>checked somewhere down there. Winrview currently does this at the<BR>beginning of ambient(), sets a flag for the original caller (not<BR>really necessary), assigns zero values to the current rgb set<BR>(should probably use the ambient values instead), and returns.<BR>I don't know if this is the optimal place to do this, but it<BR>worked well enough for me at the time.<BR><BR><BR>-schorsch<BR><BR>-- <BR>Georg Mischler -- simulations developer -- schorsch at schorsch.com<BR>+schorsch.com+ -- lighting design tools -- http://www.schorsch.com/<BR><BR>_______________________________________________<BR>Radiance-dev mailing list<BR>Radiance-dev@radiance-online.org<BR>http://www.radiance-online.org/mailman/listinfo/radiance-dev</BLOCKQUOTE><p><br><hr size=1><b>Do You Yahoo!?</b><br>\n<a href=\"http://rd.yahoo.com/welcome/*http://fifaworldcup.yahoo.com/fc/en/spl\">Sign-up for Video Highlights</a> of 2002 FIFA World Cup\n--0-2106539197-1023987040=:49654--\n___\n<sup>Automatically generated content from [radiance mailing-list](https://radiance-online.org/pipermail/radiance-dev/2002-June/000011.html).</sup>", "attachments": [], "created_by_name": "Charles Ehrlich", "created_at": "June 13, 2002 at 09:50AM", "created_by": "Charles_Ehrlich", "parent_id": "radiance-dev_000000", "id": "radiance-dev_000011"}