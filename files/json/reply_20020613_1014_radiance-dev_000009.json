{"body": "Greg Ward wrote:\n\n\n> Having dealt just a little with Windows networks, I have to say that my\n> interest in supporting them is identically 0 over all time and space.\n> I'll leave it to you and others who think it worthwhile.\n\n\nVery understandably. I'd like to try to stay away from any\nWindows specific stuff as much as possible myself. Any solution\nshould be either file or IP based, to make it portable across\nall platforms.\n\n\n\n\n> Another reason to use a file lock manager rather than a server process\n> besides simplicity is that the lock manager is robust to individual\n> systems going down (or should be), whereas everything dies if your\n> server process dies.  What about Chas' suggestion of offering Samba as a\n> substitute lock manager?\n\n\nThe lock manager ultimately dies with the machine where the\nlocked file resides, which is just as good or bad. Ideally, any\nother server process would run on this same machine as well. Only\nwhen this isn't possible will there be two seperate points of\nfailure.\n\n\nI'm not sure yet what Samba exactly does here, apart from the\nfact that it involves yet another extra server process. One one\nside, Samba offers the standard Windows network locking API to\nprocesses connecting from that end. And it looks like it *can*\ntranslate those into flock() calls on the unix side. Does this\nmean that unix processes accessing the same file per NFS would\nsee the lock too?\n\n\nChas, is this code included in the Radiance for Windows sources I\nhave or was it added later? Because I'm pretty sure that my\nversion corrupts the ambient files on concurrent access.\nThe ultimate goal should be that every process on every OS type\ncan access the same file without getting in each others way.\n\n\n\n\n> >  One of the\n> > more interesting tasks might turn out to be the elimination of\n> > exit() calls in code that is considered part of a library. I\n> > don't think there's any part of Radiance that currently hesitates\n> > to kill the whole process whenever something goes wrong, which\n> > would be very surprising for a program using such a library.\n>\n> Ah, yes.  I agree -- although I usually call quit(), which then calls\n> exit() if it isn't overridden by the calling program.  The only way to\n> avoid exit() is with a long jump, however, and this is not a generally\n> recommended practice, so it remains a problem.\n\n\nOne of my modifications to winrview was to establish a safe\nreturn path from very deep recursion levels when user interaction\nstops the current simulation. This may involve a few additional\nreturn value checks, but I think in this specific case those were\nalready in place.  Similar scenarios, in the worst case with an\nextra flag somewhere to indicate an error condition, should be\npossible in most if not all places where exit/quit are invoked.\nBut I think we're discussing pretty far in future mode here already...\n\n\n\n\n> If the ambient calculation is the only barrier to responsiveness in\n> rview, it wouldn't be too difficult to query the value of some variable\n> set asynchronously by the caller and make a hasty retreat.\n\n\nYup, exactly.\n\n\n\n\n> However,\n> we'd have to work long and hard before we got the renderer code into\n> thread-safe shape.\n\n\nMaybe, maybe not. There are at least two levels of thread safety.\nOne is to have the critical code running independently in its own\nthread *once*, which is no problem as long as there aren't any\nglobal variables. The other would be to allow several instances\nrunning in parallel threads, which in addition requires the\nelimination of all static variables in functions. I think both\nconditions could be met quite easily when all state (including\nany stop condition flags that the parent thread might want to\nset) is encapsulated eg. in the ray struct. Future mode again,\nthough.\n\n\n\n\n> Another option is to use the Unix signal facility to\n> send an interrupt to the rendering process, causing premature\n> termination of any ambient calculation in progress.  This wouldn't\n> require much coding effort at all.\n\n\nUnfortunately, signals and Windows don't match very well...\n\n\n\n\n> Another, possibly better solution would be to have the renderer call a\n> global \"checkInput()\" routine every so many rays, which is the way rview\n> is _supposed_ to work but doesn't, simply because the call to\n> checkInput() is handled at too high a level.  If we moved this into the\n> low-level raytrace() routine, I think we'd have responsiveness licked\n> without having to change to a background rendering process.  I might\n> even give this a go to try it out.\n\n\nWhichever stopping signalization is chosen should indeed be\nchecked somewhere down there. Winrview currently does this at the\nbeginning of ambient(), sets a flag for the original caller (not\nreally necessary), assigns zero values to the current rgb set\n(should probably use the ambient values instead), and returns.\nI don't know if this is the optimal place to do this, but it\nworked well enough for me at the time.\n\n\n\n\n-schorsch\n\n\n\n\nGeorg Mischler  --  simulations developer  --  schorsch at schorsch.com\n+schorsch.com+  --  lighting design tools  --  http://www.schorsch.com/\n___\n<sup>Automatically generated content from [radiance mailing-list](https://radiance-online.org/pipermail/radiance-dev/2002-June/000009.html).</sup>", "attachments": [], "created_by_name": "Georg Mischler", "created_at": "June 13, 2002 at 10:14AM", "created_by": "Georg_Mischler", "parent_id": "radiance-dev_000000", "id": "radiance-dev_000009"}