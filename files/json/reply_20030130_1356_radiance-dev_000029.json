{"body": "Carsten Bauer wrote:\n\n\n> Hi, Schorsch and others\n>\n> > It also looks like Carsten already has this implemented, although\n> > his description so far hasn't made it completely clear whether\n> > that depends on PVM or not. He wanted to be around again this\n> > week to explain it better. A self contained version is obviously\n> > preferrable, and I believe that it can be done with reasonable\n> > effort.\n>\n> sorry, I thought everything was clear already. Of course my stuff\n> depends completely on PVM.\n\n\nI was uncertain whether that also included the client/server\ncommunication, thanks for clarifying.  Is you code available\nanywhere? Even if we're going to try to avoid PVM, your approach\nof integration might still be interesting to look at for\ninspiration.\n\n\n\n\nI'm splicing the following in here, so that the topic remains in\none thread:\n\n\nGreg wrote:\n\n\n> On another note, I have been following with interest the discussion on\n> parallel rendering solutions and alternatives to a working NFS lock\n> manager.  I haven't responded because I haven't had anything\n> intelligent to add...  It's sounding like the consensus is headed the\n> direction of a socket-based client/server solution.  A dreadful pain to\n> implement from all I've seen, but perhaps it's best in the long run.\n\n\nI had a look at the ambient code from 3.4. The current file\naccess mechanics seem to be organized simple enough, so that a\nswitch to networked access will only require to replace/modify\nthree functions (and their children, of course). Making lookamb\nnetwork-aware would add another two. I'll have a closer look as\nsoon as the ANSIfied code is available per CVS. You can expect a\nfew questions after that to verify that I'm understanding\neverything correctly.\n\n\nOn the client side, the networking code will be very simple:\n- A new option  -an host[,port[,timeout]]\n- Establish a socket connection on startup.\n- Write new ambient values to that socket.\n- Update the local ambient data from the socket.\nThis is almost identical to the current file based code, minus\nlocking (which is done by the server). We'll have to see if it is\nworth the effort to \"bundle\" network transfers (only sync after a\ncertain number of new values have been created), which would\ninvolve some more overhead.\n\n\nOn the server side, things may get a bit more involved. Since we\nneed to make sure that all accesses are sequential, asynchronous\noperation through select() looks like the obvious choice.\nNote that the server doesn't necessarily have to write the data\nto a file, unless the user expects to stop and restart it later.\nIf it does use a file, then the existing code for that purpose\ncan be used with only minimal changes if any. NFS lock based\nshared access on this file will *still* be possible, on those\nplatforms where that works.\n\n\nI'm thinking of implementing the server in Python at first. This\nwill make it easy to experiment with different strategies wrt.\nconnection pool management, communication protocol, data caching,\nand maybe even file locking mechanisms. It will also benefit from\nthe experience I have collected by writing the remote simulation\nserver that is included with Rayfront. Once we know what works\nbest, it will be possible to either declare the Python version\nproduction ready, or to rewrite it in C. The latter is unlikely\nto make it any more efficient, but may be desirable to reduce the\nthird party tool dependency.\n\n\n\n\n-schorsch\n\n\n\n\nGeorg Mischler  --  simulations developer  --  schorsch at schorsch com\n+schorsch.com+  --  lighting design tools  --  http://www.schorsch.com/\n___\n<sup>Automatically generated content from [radiance mailing-list](https://radiance-online.org/pipermail/radiance-dev/2003-January/000029.html).</sup>", "attachments": [], "created_by_name": "Georg Mischler", "created_at": "January 30, 2003 at 01:56PM", "created_by": "Georg_Mischler", "parent_id": "radiance-dev_000016", "id": "radiance-dev_000029"}