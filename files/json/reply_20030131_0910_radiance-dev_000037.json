{"body": "Hi Guys,\n\n\nThis whole conversation is getting way too complicated for my tastes.  \nCan't we find a simpler solution?  The whole client/server model sounds \nreally nasty -- who starts the server?  What happens if the server dies \nor gets overwhelmed?  How portable will it be between architectures?  \nAll these things make me nervous.\n\n\nWhat if we try to stay closer to the current model, just modifying it \nso it doesn't depend on an NFS lock manager.  Here's what I suggest:\n\n\n1) Instead of calling fcntl with F_SETLKW, each ambient process \nperiodically checks for the existence of a lock file on the NFS \nfilesystem (named after the ambient file perhaps with an added suffix \n\".lok\").\n\n\n2a) If the lock file exists, we continue rendering until a later \ncheckpoint.\n\n\n2b) If the lock file doesn't exist, we create it with open(...O_EXCL).  \nWe then have full control over the ambient file to read in the new \nvalues from other processes and write our values to it.  Afterwards, we \nremove the lock file.\n\n\nThe only difference between this and what's currently in ambient.c is \nthat we use the lock file with open() and unlink() to control access, \nand buffer as many values as necessary until the lock is available.  \n(Right now, the process will block after a certain accumulation and not \nunblock until it obtains the lock.)\n\n\n-Greg\n\n\nP.S.  I took some flack for my apparent lack of knowledge regarding C \npointer arithmetic after the last post.  So I screwed up!  At least I \neventually figured out that I screwed up -- don't I get some credit for \nthat?  I didn't think the error was so obvious, myself.\n\n\nP.P.S.\n>> char    **avp1, **avp2;\n>\n> I hope you're using pointers to void in the ANSI version... ;)\n>\n> -schorsch\n\n\nYou may be disappointed when you first see the new ANSI version.  My \ngoal was to get the libraries to a state where other people could call \nthem with the benefits of function prototypes.  I didn't go into all \nthe various modules and programs and make sure that the local functions \nall had prototypes as well.  Only the code in the src/common and src/rt \ndirectories got treated -- I pretty well left the rest alone, except to \nmake sure it was happy with the new library prototypes, and didn't go \ndeclaring standard library functions, itself.  Internal static \nfunctions pretty much never got prototyped, as gcc (and other C \ncompilers) don't pick on you if you use the old K&R style of function \ndefinitions:\n\n\ntype call(a1, a1) type a1, a2; {...}\n\n\nThus, the comparison function passed to qsort doesn't get its \nparameters examined.  If someone wants to go in and add all the correct \nparameter lists and casts everywhere, they're welcomed to do so once we \nget CVS up and running.  Frankly, I think it's a waste of time that \ncould be better spent, and it only increases the chances of errors.  I \nfound exactly 0 bugs in Radiance by adding the prototypes I added, and \ncaused two or three in the process, which took me a while to ferret \nout....\n___\n<sup>Automatically generated content from [radiance mailing-list](https://radiance-online.org/pipermail/radiance-dev/2003-January/000037.html).</sup>", "attachments": [], "created_by_name": "Greg Ward", "created_at": "January 31, 2003 at 09:10AM", "created_by": "Greg_Ward", "parent_id": "radiance-dev_000016", "id": "radiance-dev_000037"}