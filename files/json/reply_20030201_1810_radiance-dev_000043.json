{"body": "Greg Ward wrote:\n\n\n> The open() call with the O_EXCL flag is supposed to be atomic with the\n> file system -- i.e., if the file exists, the call fails, so if\n> competing processes compete in a race, only one can win.  If the open()\n> call fails, then our process moves on as if the lock file were there\n> all along.\n\n\nYou almost convinced me with this one, until I checked the\nopen(2) man page on my Linux box:\n\n\n  O_EXCL is broken on\n  NFS  file  systems,  programs  which  rely on it for performing\n  locking tasks will contain a race condition.  The solution  for\n  performing  atomic file locking using a lockfile is to create a\n  unique file on the same fs (e.g.,  incorporating  hostname  and\n  pid),  use  link(2)  to  make a link to the lockfile. If link()\n  returns 0, the lock is successful.  Otherwise, use  stat(2)  on\n  the  unique file to check if its link count has increased to 2,\n  in which case the lock is also successful.\n\n\nI don't know if this is specific to Linux, or if is just the only\nsystem where the documentation spells out the problem. The method\nwith the hard link is what Mailman uses, btw., making reference to\nthe above paragraph of the linux man page in the code.\n\n\nThere's no link() on Windows, so we'll have to use open() there.\nDoes anyone know if open() on Windows is supposed to be atomic?\nThe worst case scenario I see there is someone running a Samba\nserver on a Linux box, serving a file system that it has mounted\nfrom another unix host per NFS, which opens us to the above race\ncondition again...\n\n\n\n\n> As for processes that die unexpectedly in the middle of an ambient sync\n> operation, we could either disregard this possibility as neither likely\n> nor disasterous -- it would just untie all the processes so their\n> values wouldn't get written out -- not a disaster.\n\n\nFor a high quality production rendering that is taking lots of\ntime, this *can* be a disaster. If we can figure out a reliable\nway to avoid this, then I think we should do so.\n\n\n\n\n> Or, we could employ\n> some check on the file creation time and if a lock has been around more\n> than a certain period (a minute would be extremely generous), any of\n> the processes that's been failing to obtain it can remove it after\n> their Nth failure.\n\n\nRelying on the ctime of the file makes us dependent on the system\nclocks being exactly snychronized. It is not uncommon for\nmachines in the same network to by out of sync by several\nminutes. Maybe we just have to watch the file for at least a\nminute to decide it's expired.\n\n\nThe other problem is that removing the file will create new race\nconditions. If two processes try this at nearly the same time,\nand a third one succeeds at creating a new lockfile in between,\nthen we'll remove that one as well. There may have to be a\nsecondary lockfile protecting the lock breaking process, with\nanother minute of waiting after it is created. Any process trying\nto aquire the primary lock must check first to make sure that no\nsecondary lock exists. Waiting a few minutes shouldn't be a\nproblem, as it will only happen in an exceptional situation\nanyway. To make individual lock files identifiable, they can\ncontain the hostname and PID of the creating process, and the\ncreation time.\n\n\nBad scenario:\n- A creates lock and dies\n- B and C both fail to create a lock several times,\n- B and C check and remember the ID of the lock\n- B and C make sure that they are still looking at the same\n  file after at least a minute\n- B removes the lockfile\n- D succeeds in creating a new lock\n- C removes the new lock, thinking it is still the old one\n\n\nBetter (but still not perfect) scenario:\n- A creates lock and dies (or gets suspended)\n- B and C fail to create a lock several times,\n- B and C check and remember the ID of the lock\n- B and C make sure that they are still looking at the same\n  file after at least a minute\n- B creates a secondary lockfile\n- C tries to create a secondary lockfile, fails, and steps back\n- D wants to create a new lock, but sees the secondary lock\n  and steps back (similarly during all following steps)\n- B waits for another minute, to make sure that all other\n  processes interested in aquiring or breaking the original lock\n  have had time to notice the secondary lock\n- B finds that it still owns the secondary lockfile (this\n  eliminates the last chance for A to wake up and intercept the\n  breakage by removing the secondary lock)\n- B removes the original lock\n- B waits yet another minute to insure against A removing\n  someone elses lock if it wakes up again later\n- B removes the secondary lock\n- any process can try to aquire the lock again\n- If A wakes up now, we need to make sure that it doesn't\n  remove someone elses lock. This means that it will have to\n  check that it really owns the lockfile immeditatly before\n  removing it (hence the third wait above). If it still owns\n  the primary lock, and notices a secondary lock, it may first\n  remove the secondary lock.\n\n\nWell yeah, all this assuming that we have a reliable way to\ncreate the original lock in the first place...\nAnd if the file system (or network) is really bogged down, eg.\nbecause of excessive swapping or other disk activity, then\nwriting a few ambient records *can* take more than a minute.\n\n\nTo put this all into perspective: Do we have any data on the\ntypical frequency of an ambient file getting locked/unlocked when\na dozen processes share it in a largish simulation?\n\n\n\n\n-schorsch\n\n\n\n\nGeorg Mischler  --  simulations developer  --  schorsch at schorsch com\n+schorsch.com+  --  lighting design tools  --  http://www.schorsch.com/\n___\n<sup>Automatically generated content from [radiance mailing-list](https://radiance-online.org/pipermail/radiance-dev/2003-February/000043.html).</sup>", "attachments": [], "created_by_name": "Georg Mischler", "created_at": "February 01, 2003 at 06:10PM", "created_by": "Georg_Mischler", "parent_id": "radiance-dev_000042", "id": "radiance-dev_000043"}