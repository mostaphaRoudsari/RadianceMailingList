{"body": "Greg Ward wrote:\n\n\n> Is Everything broken on Linux, or does it just seem that way?\n\n\nThe problem appears to come from the specification of the NFS\nprotocol version 2, so it's not necessarily limited to Linux:\nhttp://www.linux.se/doc/HOWTO/Secure-Programs-HOWTO/avoid-race.html\n\n\n  | if the lock file may be on an NFS-mounted filesystem, then\n  | you have the problem that NFS version 2 doesn't completely\n  | support normal file semantics.\n  | ...\n  | NFS version 3 added support for O_EXCL mode in open(2); see\n  | IETF RFC 1813, in particular the \"EXCLUSIVE\" value to the\n  | \"mode\" argument of \"CREATE\". Sadly, not everyone has switched\n  | to NFS version 3 or higher at the time of this writing, so\n  | you can't depend on this yet in portable programs. Still,\n  | in the long run there's hope that this issue will go away.\n\n\n\n\nThere's another idea that I ran into on my searches (as a reply\nto someone with a similar problem to ours):\nhttp://lists.linux.org.au/archives/linuxcprogramming/2002-July/msg00054.html\n\n\n  | Surely the simple solution is to write a network lock server\n  | (which would take a couple of hours) or grab one from\n  | somewhere (which might take even less time).  Then you can\n  | forget about special cases for different platforms and file\n  | systems.\n\n\nThis is a less involved variation of what I was planning to try.\nI thought that once I have a server running, I can just as well\nfeed all the data through it. The more lightweight implementation\nsuggested here just establishes the lock, while the ambient data\nstill goes directly to the file.\n\n\nAn example implementation that we might even be able to use\nand/or modify can be found here:\n  http://sourceforge.net/projects/lockserver/\nThis does a lot more than we need, as it also queues requests,\nstores locks to a file to survive a restart, and manages\npriorities and TTLs for both queued requests and granted locks.\n\n\n\n\n> > Maybe we just have to watch the file for at least a minute to\n> > decide it's expired.\n>\n> I thought about this, and that's why I think it's best for the\n> process to simply keep track of when the lock file says it was\n> created, and if the date hasn't changed between checks that are\n> a few minutes apart by the local clock, it's safe to assume\n> that the process died during an update.\n\n\nSame idea. Potential pitfall: We'll need to check out which of\nthe timestamps we can rely on on Windows. I *think* ctime should\nbe fine. One of the problems here is that Windows file systems\ndon't use inodes, but store this kind of information with the\nfile. If I remember correctly, then this means that eg. the atime\ngets modified just by looking at it (kind of logically inevitable,\nbut still weird!).\n\n\n\n\n> Unless we are really stupid about how often we check the lock\n> file, I don't think this scenario will play out in any of our\n> lifetimes.\n\n\nMaybe, maybe not. All I know for sure is that it *can* happen.\nThat was the reason I asked for data (or even just a reasonable\nestimation) on the frequency that the lock might typically get\naquired during a large simulation. Maybe we can add a way to log\nthis information, to get a better idea about the risks involved.\n\n\nI agree that there will be a point of being \"good enough\" (my\nconvoluted scenario isn't 100% safe either), but I would feel\nmuch better if we could decide on this point based on solid data.\nIf the data shows that it might happen once during my lifetime,\nthen I'd gladly accept that. If I were to see it twice, I might\nhave second thoughts...\n\n\n\n\nOk, independently of the specific implementation details, I see\nthe following strategies that we could test:\n\n\n System lock (as implemented for unix)\n * direct read access to ambient file\n * direct write access to ambient file\n * locking through fcntl() (resp. the standard Windows locking\n   mechanisms, translated through Samba when needed)\n\n\n Simple lock file\n * direct read access to ambient file\n * direct write access to ambient file\n * locking through lock file, broken after a TTL of n minutes\n\n\n Complex lock file\n * direct read access to ambient file\n * direct write access to ambient file\n * locking through lock file, broken under protection of a\n   secondary lock\n\n\n Locking server\n * direct read access to ambient file\n * direct write access to ambient file\n * locking through a seperate server process\n\n\n Unidirectional data server\n * direct read access to ambient file\n * ambient data written through server process\n * server may use one of the above locking mechanisms if file\n   writing is still shared with other processes, or none if it\n   has exclusive access\n\n\n Bidirectional data server\n * ambient data read through server process\n * ambient data written through server process\n * server may use one of the above locking mechanisms if file\n   writing is still shared with other processes, or none if it\n   has exclusive access\n\n\n\n\nLots of toys to play with...\n\n\n\n\n-schorsch\n\n\n\n\nGeorg Mischler  --  simulations developer  --  schorsch at schorsch com\n+schorsch.com+  --  lighting design tools  --  http://www.schorsch.com/\n___\n<sup>Automatically generated content from [radiance mailing-list](https://radiance-online.org/pipermail/radiance-dev/2003-February/000045.html).</sup>", "attachments": [], "created_by_name": "Georg Mischler", "created_at": "February 03, 2003 at 07:10PM", "created_by": "Georg_Mischler", "parent_id": "radiance-dev_000042", "id": "radiance-dev_000045"}