{"body": "Schorsch writes:\n\n\n> Since you're using the t-word, are we necessarily restricted to\n> triangles here? The obj format looks like an \"n-mesh\", allowing\n> for faces to reference an arbitrary number of vertices. As long\n> as those faces are planar, I think it would be nice to allow that\n> as well, and I can't see any obvious reason why your concept\n> shouldn't be able to handle the general case.\n\n\nThere are a few problems with N-meshes.  First, the vertices can be \nnon-planar.  Even slight non-planarity can result in visible cracks \nunder certain conditions.  The means for avoid cracking of non-planar \ngeometry are generally not available within a ray-tracer.  The second \nproblem with quads and especially poly's with 5 sides or more is that \nthey don't succumb easily to coordinate interpolation for smoothing and \n(u,v) lookups.  Finally, and this is relatively minor,  it takes a bit \nof extra storage and complexity to deal with N-ary polygons, to the \npoint where it doesn't cost much more to break everything into \ntriangles, which is what I plan to do if a quad (or higher) is \ndelivered in the .OBJ file.  (The cost of breaking quads into triangles \nis 1 byte/quad, and the intersection tests don't take much longer -- \nsome people claim it's even faster if you optimize.)\n\n\n> I'm not sure what exactly \"face grouping\" means in practise, but\n> it sounds complicated... Will it still work efficiently for\n> irregular geometry? I'm thinking about meshes where the indivual\n> faces intersect and stretch all around the bounding box, making\n> it impossible to assign each of them to a local region. Or is the\n> term invoking the wrong images in my head?\n\n\nI came up with a fairly simple data structure for grouping vertices and \nfaces together so each triangle takes three bytes for the three vertex \nreferences.  Reference locality is based on face order in the file, and \nwe solve the boundary problem by replicating vertices when we run out \nof room in a given group.  The costs for doing so should be minor \nrelative to the savings.  Reading in the .OBJ file is a bit more \ncomplicated this way, but we get a savings of about 9 bytes/triangle \nover a more straightforward representation.  This cuts the memory use \nnearly in half for a mesh without normals or texture coordinates, and \n35% or so for a mesh with both normals and uv.  Access time is \nunaffected.  Since a big reason for switching to a mesh representation \nis to cut storage costs so we can handle scanned data and the like, I \nthink it's worth the effort to do a good job of it, provided we don't \ncompromise performance.  So, we're agreed on that.\n\n\n>> We traverse the mesh bounding box with a ray using a 3DDA \n>> (3-diminetional differential analyzer), computing the intersection of \n>> the three orthonormal pixel sets at each 3-D voxel.  If a triangle is \n>> in all three sets, that means we are within its local bounding box, \n>> and should test it for intersection with the ray.\n\n\n> Nice trick. What advantages does it have relative to building a\n> sub-octree as for instances? I assume that with many (but not\n> all) meshes, most of the voxels would be empty, but you still\n> can't reduce their number, while an empty octree branch won't\n> contain any further children. Or is it cheaper to traverse voxel\n> sets instead of octrees? Since you want to generate them on the\n> fly, I guess that at least that is significantly faster.\n\n\nWell, having thought about it some more, I'm starting to waiver on this \nidea.  The scheme I devised is quite a bit more complicated than \nleveraging the octree traversal code, which I'm starting to believe \nisn't as impossible as I first thought.  I need a way of creating an \noctree on the fly, or creating a compiled mesh format (and converter) \nfor quick loading.  Also, I'm not convinced the 3DDA would be that much \nfaster, if indeed it would be faster, since I'd be computing \npotentially large set intersections along the path.  Such an approach \nwould be sensitive to depth complexity, and in the worst case when \ndensly meshed faces are aligned with the coordinate axes, we could get \nsome really large sets (thousands of faces) that we'd have to intersect \nin a few places.  An octree doesn't suffer this problem, and the \nexisting structure would work as it is.  I'm still pondering this.\n\n\n> Looks fine to me.\n> I especially like the fact that the obj format will also allow us\n> to accept true free form surfaces later...\n\n\nWhat packages actually output Wavefront's free-form extensions?  I do \nplan on making gensurf optionally output the new mesh format, since \nit's basically computing a free-form mesh with uv coordinates as it is.\n\n\n-Greg\n___\n<sup>Automatically generated content from [radiance mailing-list](https://radiance-online.org/pipermail/radiance-dev/2003-March/000060.html).</sup>", "attachments": [], "created_by_name": "Greg Ward", "created_at": "February 28, 2003 at 04:31PM", "created_by": "Greg_Ward", "parent_id": "radiance-dev_000056", "id": "radiance-dev_000060"}