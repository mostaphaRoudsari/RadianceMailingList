{"body": "--0-54572204-1046480332=:74707\nContent-Type: text/plain; charset=us-ascii\n\n\n\n\nGreg,\nThe following caught my attention:\n>I need a way of creating an octree on the fly, or \n> creating a compiled mesh format (and converter) \n> for quick loading.\n\n\nThis sounds like it would be useful for scene animations with a stay-in-memory version of the renderer, no?\n-Chas\n Greg Ward <gward@lmi.net> wrote:Schorsch writes:\n\n\n> Since you're using the t-word, are we necessarily restricted to\n> triangles here? The obj format looks like an \"n-mesh\", allowing\n> for faces to reference an arbitrary number of vertices. As long\n> as those faces are planar, I think it would be nice to allow that\n> as well, and I can't see any obvious reason why your concept\n> shouldn't be able to handle the general case.\n\n\nThere are a few problems with N-meshes. First, the vertices can be \nnon-planar. Even slight non-planarity can result in visible cracks \nunder certain conditions. The means for avoid cracking of non-planar \ngeometry are generally not available within a ray-tracer. The second \nproblem with quads and especially poly's with 5 sides or more is that \nthey don't succumb easily to coordinate interpolation for smoothing and \n(u,v) lookups. Finally, and this is relatively minor, it takes a bit \nof extra storage and complexity to deal with N-ary polygons, to the \npoint where it doesn't cost much more to break everything into \ntriangles, which is what I plan to do if a quad (or higher) is \ndelivered in the .OBJ file. (The cost of breaking quads into triangles \nis 1 byte/quad, and the intersection tests don't take much longer -- \nsome people claim it's even faster if you optimize.)\n\n\n> I'm not sure what exactly \"face grouping\" means in practise, but\n> it sounds complicated... Will it still work efficiently for\n> irregular geometry? I'm thinking about meshes where the indivual\n> faces intersect and stretch all around the bounding box, making\n> it impossible to assign each of them to a local region. Or is the\n> term invoking the wrong images in my head?\n\n\nI came up with a fairly simple data structure for grouping vertices and \nfaces together so each triangle takes three bytes for the three vertex \nreferences. Reference locality is based on face order in the file, and \nwe solve the boundary problem by replicating vertices when we run out \nof room in a given group. The costs for doing so should be minor \nrelative to the savings. Reading in the .OBJ file is a bit more \ncomplicated this way, but we get a savings of about 9 bytes/triangle \nover a more straightforward representation. This cuts the memory use \nnearly in half for a mesh without normals or texture coordinates, and \n35% or so for a mesh with both normals and uv. Access time is \nunaffected. Since a big reason for switching to a mesh representation \nis to cut storage costs so we can handle scanned data and the like, I \nthink it's worth the effort to do a good job of it, provided we don't \ncompromise performance. So, we're agreed on that.\n\n\n>> We traverse the mesh bounding box with a ray using a 3DDA \n>> (3-diminetional differential analyzer), computing the intersection of \n>> the three orthonormal pixel sets at each 3-D voxel. If a triangle is \n>> in all three sets, that means we are within its local bounding box, \n>> and should test it for intersection with the ray.\n\n\n> Nice trick. What advantages does it have relative to building a\n> sub-octree as for instances? I assume that with many (but not\n> all) meshes, most of the voxels would be empty, but you still\n> can't reduce their number, while an empty octree branch won't\n> contain any further children. Or is it cheaper to traverse voxel\n> sets instead of octrees? Since you want to generate them on the\n> fly, I guess that at least that is significantly faster.\n\n\nWell, having thought about it some more, I'm starting to waiver on this \nidea. The scheme I devised is quite a bit more complicated than \nleveraging the octree traversal code, which I'm starting to believe \nisn't as impossible as I first thought. I need a way of creating an \noctree on the fly, or creating a compiled mesh format (and converter) \nfor quick loading. Also, I'm not convinced the 3DDA would be that much \nfaster, if indeed it would be faster, since I'd be computing \npotentially large set intersections along the path. Such an approach \nwould be sensitive to depth complexity, and in the worst case when \ndensly meshed faces are aligned with the coordinate axes, we could get \nsome really large sets (thousands of faces) that we'd have to intersect \nin a few places. An octree doesn't suffer this problem, and the \nexisting structure would work as it is. I'm still pondering this.\n\n\n> Looks fine to me.\n> I especially like the fact that the obj format will also allow us\n> to accept true free form surfaces later...\n\n\nWhat packages actually output Wavefront's free-form extensions? I do \nplan on making gensurf optionally output the new mesh format, since \nit's basically computing a free-form mesh with uv coordinates as it is.\n\n\n-Greg\n\n\n_______________________________________________\nRadiance-dev mailing list\nRadiance-dev@radiance-online.org\nhttp://www.radiance-online.org/mailman/listinfo/radiance-dev\n--0-54572204-1046480332=:74707\nContent-Type: text/html; charset=us-ascii\n\n\n<P>Greg,\n<P>The following caught my attention:\n<P>&gt;I need a way of creating an octree on the fly, or <BR>&gt; creating a compiled mesh format (and converter) <BR>&gt; for quick loading.</P>\n<P>This sounds like it would be useful for&nbsp;scene animations with a stay-in-memory version of the renderer, no?\n<P>-Chas\n<P>&nbsp;<B><I>Greg Ward &lt;gward@lmi.net&gt;</I></B> wrote:\n<BLOCKQUOTE style=\"PADDING-LEFT: 5px; MARGIN-LEFT: 5px; BORDER-LEFT: #1010ff 2px solid\">Schorsch writes:<BR><BR>&gt; Since you're using the t-word, are we necessarily restricted to<BR>&gt; triangles here? The obj format looks like an \"n-mesh\", allowing<BR>&gt; for faces to reference an arbitrary number of vertices. As long<BR>&gt; as those faces are planar, I think it would be nice to allow that<BR>&gt; as well, and I can't see any obvious reason why your concept<BR>&gt; shouldn't be able to handle the general case.<BR><BR>There are a few problems with N-meshes. First, the vertices can be <BR>non-planar. Even slight non-planarity can result in visible cracks <BR>under certain conditions. The means for avoid cracking of non-planar <BR>geometry are generally not available within a ray-tracer. The second <BR>problem with quads and especially poly's with 5 sides or more is that <BR>they don't succumb easily to coordinate interpolation for smoothing and <BR>(u,v) lookups. Finally, and this is relatively minor, it takes a bit <BR>of extra storage and complexity to deal with N-ary polygons, to the <BR>point where it doesn't cost much more to break everything into <BR>triangles, which is what I plan to do if a quad (or higher) is <BR>delivered in the .OBJ file. (The cost of breaking quads into triangles <BR>is 1 byte/quad, and the intersection tests don't take much longer -- <BR>some people claim it's even faster if you optimize.)<BR><BR>&gt; I'm not sure what exactly \"face grouping\" means in practise, but<BR>&gt; it sounds complicated... Will it still work efficiently for<BR>&gt; irregular geometry? I'm thinking about meshes where the indivual<BR>&gt; faces intersect and stretch all around the bounding box, making<BR>&gt; it impossible to assign each of them to a local region. Or is the<BR>&gt; term invoking the wrong images in my head?<BR><BR>I came up with a fairly simple data structure for grouping vertices and <BR>faces together so each triangle takes three bytes for the three vertex <BR>references. Reference locality is based on face order in the file, and <BR>we solve the boundary problem by replicating vertices when we run out <BR>of room in a given group. The costs for doing so should be minor <BR>relative to the savings. Reading in the .OBJ file is a bit more <BR>complicated this way, but we get a savings of about 9 bytes/triangle <BR>over a more straightforward representation. This cuts the memory use <BR>nearly in half for a mesh without normals or texture coordinates, and <BR>35% or so for a mesh with both normals and uv. Access time is <BR>unaffected. Since a big reason for switching to a mesh representation <BR>is to cut storage costs so we can handle scanned data and the like, I <BR>think it's worth the effort to do a good job of it, provided we don't <BR>compromise performance. So, we're agreed on that.<BR><BR>&gt;&gt; We traverse the mesh bounding box with a ray using a 3DDA <BR>&gt;&gt; (3-diminetional differential analyzer), computing the intersection of <BR>&gt;&gt; the three orthonormal pixel sets at each 3-D voxel. If a triangle is <BR>&gt;&gt; in all three sets, that means we are within its local bounding box, <BR>&gt;&gt; and should test it for intersection with the ray.<BR><BR>&gt; Nice trick. What advantages does it have relative to building a<BR>&gt; sub-octree as for instances? I assume that with many (but not<BR>&gt; all) meshes, most of the voxels would be empty, but you still<BR>&gt; can't reduce their number, while an empty octree branch won't<BR>&gt; contain any further children. Or is it cheaper to traverse voxel<BR>&gt; sets instead of octrees? Since you want to generate them on the<BR>&gt; fly, I guess that at least that is significantly faster.<BR><BR>Well, having thought about it some more, I'm starting to waiver on this <BR>idea. The scheme I devised is quite a bit more complicated than <BR>leveraging the octree traversal code, which I'm starting to believe <BR>isn't as impossible as I first thought. I need a way of creating an <BR>octree on the fly, or creating a compiled mesh format (and converter) <BR>for quick loading. Also, I'm not convinced the 3DDA would be that much <BR>faster, if indeed it would be faster, since I'd be computing <BR>potentially large set intersections along the path. Such an approach <BR>would be sensitive to depth complexity, and in the worst case when <BR>densly meshed faces are aligned with the coordinate axes, we could get <BR>some really large sets (thousands of faces) that we'd have to intersect <BR>in a few places. An octree doesn't suffer this problem, and the <BR>existing structure would work as it is. I'm still pondering this.<BR><BR>&gt; Looks fine to me.<BR>&gt; I especially like the fact that the obj format will also allow us<BR>&gt; to accept true free form surfaces later...<BR><BR>What packages actually output Wavefront's free-form extensions? I do <BR>plan on making gensurf optionally output the new mesh format, since <BR>it's basically computing a free-form mesh with uv coordinates as it is.<BR><BR>-Greg<BR><BR>_______________________________________________<BR>Radiance-dev mailing list<BR>Radiance-dev@radiance-online.org<BR>http://www.radiance-online.org/mailman/listinfo/radiance-dev</BLOCKQUOTE>\n--0-54572204-1046480332=:74707--\n___\n<sup>Automatically generated content from [radiance mailing-list](https://radiance-online.org/pipermail/radiance-dev/2003-March/000061.html).</sup>", "attachments": [], "created_by_name": "Charles Ehrlich", "created_at": "February 28, 2003 at 04:58PM", "created_by": "Charles_Ehrlich", "parent_id": "radiance-dev_000056", "id": "radiance-dev_000061"}