{"body": "Greg Ward wrote:\n\n\n> I am thinking about adding a \"mesh\" primitive to Radiance, which would\n> be the first new geometric primitive since the system's inception.\n\n\nOooohhhh....!\n\n\n\n\n> In a well-constructed t-mesh, each non-boundary vertex has a valence of\n> 6, which means that we can save a lot of memory by sharing vertices\n> rather than repeating them in individual triangles.\n\n\nSince you're using the t-word, are we necessarily restricted to\ntriangles here? The obj format looks like an \"n-mesh\", allowing\nfor faces to reference an arbitrary number of vertices. As long\nas those faces are planar, I think it would be nice to allow that\nas well, and I can't see any obvious reason why your concept\nshouldn't be able to handle the general case.\n\n\n\n\n> Furthermore, mesh\n> vertices can be constrained to fit within a bounding box, permitting\n> them to be represented by 32-bit integers rather than 64-bit doubles,\n> which saves another factor of two.  We have to add back in some\n> overhead for vertex indexing, but I think I can reduce this to one byte\n> per reference using face grouping -- I'll have to think about it some\n> more.\n\n\nI'm not sure what exactly \"face grouping\" means in practise, but\nit sounds complicated... Will it still work efficiently for\nirregular geometry? I'm thinking about meshes where the indivual\nfaces intersect and stretch all around the bounding box, making\nit impossible to assign each of them to a local region. Or is the\nterm invoking the wrong images in my head?\n\n\nIn general, I wouldn't hesitate to trade a few bytes anymore, if\nwe got noticeable performance improvements in return. Cutting\nmemory use in half (or better) may still be worth the effort, but\nif it's less than that, then I'd say that RAM is cheap, and time\nis expensive.\n\n\n\n\n>   All I need to store is 3 orthonormal images on the mesh\n> bounding box, where each image pixel contains the set of triangles that\n> project onto that position (without hidden surface removal).  We\n> traverse the mesh bounding box with a ray using a 3DDA (3-diminetional\n> differential analyzer), computing the intersection of the three\n> orthonormal pixel sets at each 3-D voxel.  If a triangle is in all\n> three sets, that means we are within its local bounding box, and should\n> test it for intersection with the ray.\n\n\nNice trick. What advantages does it have relative to building a\nsub-octree as for instances? I assume that with many (but not\nall) meshes, most of the voxels would be empty, but you still\ncan't reduce their number, while an empty octree branch won't\ncontain any further children. Or is it cheaper to traverse voxel\nsets instead of octrees? Since you want to generate them on the\nfly, I guess that at least that is significantly faster.\n\n\n\n\n> Another bonus we'll get with this implementation is something Radiance\n> has never had -- local (u,v) coordinates!  These can be stored wtih our\n> vertices and made available for patterns and textures through the\n> function language as new variables, Lu and Lv.\n\n\nThat might make it tempting to convert \"normal\" geometry into\nmeshes too for certain applications...\n\n\n\n\n> Their values will be\n> set in the mesh input file, for which I plan to use Wavefront .OBJ,\n> since it already contains pretty much everything we need to specify a\n> mesh without a lot of fluff.  Here's the primitive specification I have\n> in mind:\n>\n> mod mesh id\n> 1+ mesh_file.obj [xf ..]\n> 0\n> 0+ [smoothing_angle]\n\n\nLooks fine to me.\nI especially like the fact that the obj format will also allow us\nto accept true free form surfaces later...\n\n\n\n\n>  Do we need meshes or not?\n\n\nFor people importing DXF data from programs like Rhino or FormZ,\nthey'll be a gift from heaven, even without side benefits like\nlocal u/v.\n\n\n\n\n>   Am I going about it all wrong -- e.g., should I\n> be using subdivision surfaces instead of t-meshes?\n\n\nI had to look up the term, but... I'm not sure whether meshes vs.\nsubdivision surfaces are really equivalent alternatives to each\nother.\n\n\nThere may be implementation issues on your end that I don't see\nat the moment, but for me the big question is where the geometry\ndata actually comes from. In practise, this will be any of the\nstandard (or not so standard) CAD programs.\n\n\nIt should be relatively straightforward for a modelling program\nlike trueSpace to generate smoothed meshes from their subdivision\nsurfaces on export. But it will be rather hard for any other CAD\nprogram to generate subdivision surfaces from their more\ntraditional mesh data. As far as I am concerned, that would\nsettle the question for Radiance.\n\n\n\n\n> Smoothed meshes are\n> notorious for creating reflection and refraction problems due to\n> inconsistent normals, which was my other excuse for avoiding them all\n> these years.\n\n\nPeople modelling optical lenses that way will have to blame\nthemselfes for the results... ;)\n\n\n\n\n-schorsch\n\n\n\n\nGeorg Mischler  --  simulations developer  --  schorsch at schorsch com\n+schorsch.com+  --  lighting design tools  --  http://www.schorsch.com/\n___\n<sup>Automatically generated content from [radiance mailing-list](https://radiance-online.org/pipermail/radiance-dev/2003-February/000059.html).</sup>", "attachments": [], "created_by_name": "Georg Mischler", "created_at": "February 28, 2003 at 05:46PM", "created_by": "Georg_Mischler", "parent_id": "radiance-dev_000056", "id": "radiance-dev_000059"}