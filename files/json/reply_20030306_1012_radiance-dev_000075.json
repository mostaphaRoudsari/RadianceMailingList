{"body": "Peter A-B writes:\n> Alias are treated quite asymmetric in Radiance, as they are  \n> \"primitives\"\n> syntactically, but filtered out directly at the time the rad file is \n> read.\n> Treating them as primitives and thus preserving the information they\n> contain wouldn't break anything. To the user they would be absolutely\n> identical. Internally the price is following one additional object \n> lookup,\n> which would be neglectable, as far as I guess.\n\n\nActually, an \"alias\" primitive does not fit with the syntax of standard \nprimitives at all, in that it doesn't have a variable list of \narguments.  It has just one argument, which is the alias target.\n\n\nI checked the code, and it seems I was confused about the current \nbehavior -- rview actually does record and report the ID of the alias, \nrather than the alias target.  So, in my previous e-mail, rview would \nin fact tell me that my wall was made of \"wall_material,\" rather than \n\"beige870.\"  Isn't this what you're requesting?  I'm more confused than \never.  The only thing that's really lost when the scene is loaded, is \nthe fact that we had an alias, rather than a modifier that happened to \nhave the same type and arguments as the target.  Is this somehow a \nproblem for you?\n\n\nIn checking the code, I noticed that there's a bug in the way aliased \nobjects are freed the same as other objects.  Since I just copy the \nOBJREC oargs struct without duplicating allocated memory, the oargs \nmemory gets freed twice or more in freeobjects(), a real no-no with \nmost malloc implementations.  Once we figure out what we want to do \nwith aliases (if anything), I'll be sure to fix this as well.\n\n\nJack de Valpine writes:\n> Now, since the can of worms is open, the problem with using aliases in \n> this way is the use of compound or modified materials. Say in mats.lib \n> we had a brightfunc defined called foo.bf , in order to apply that \n> modifier it needs to occur in mats.abc.rad:\n>\n> foo.bf alias abc_c101 foo.white\n>\n> I understand why this is the case, but it would be really nice to able \n> to have fully defined compound material definitions that can just be \n> applied in the fourth position of the alias. So instead, I could do \n> the following:\n>\n> in mats.generic.lib\n>\n> void brightfunc foo.bf\n> 2 .5 .\n> 0\n> 0\n>\n> foo.bf plastic foo.white\n> 0\n> 0\n> 5 1 1 1 0 0\n>\n> in mats.abc.rad\n>\n> void alias abc_c101 foo.white\n>\n> where now abc_c101 'inherits' both modifier and material \n> characteristics.\n\n\nI like this suggestion.  However, I don't think using \"void\" to \nindicate that the alias should use the same modifiers as the original \nis a good idea, as one might want to break the modifier chain in \ncreating an alias, and this is a valid use of \"void\" in the current \nimplementation.  However, we could introduce, for this one purpose, a \nmodifier keyword to associate with the alias pseudotype -- let's call \nit \"linked\".  Then, your example above becomes:\n\n\n   linked alias abc_c101 foo.white\n\n\nThe \"linked\" modifier gets replaced with the \"foo.bf\" modifier from the \n\"foo.white\" target.  The only problem for backward compatibility would \nbe the unlikely case where someone had chosen \"linked\" as their \nmodifier in some scene file somewhere.  I think we can live with that \npossibility, or we could come up with an even more obscure but still \nsensible keyword.  (Suggestions? -- \"full\" was the other keyword that \noccurred to me.)\n\n\n-Greg\n___\n<sup>Automatically generated content from [radiance mailing-list](https://radiance-online.org/pipermail/radiance-dev/2003-March/000075.html).</sup>", "attachments": [], "created_by_name": "Greg Ward", "created_at": "March 06, 2003 at 10:12AM", "created_by": "Greg_Ward", "parent_id": "radiance-dev_000072", "id": "radiance-dev_000075"}