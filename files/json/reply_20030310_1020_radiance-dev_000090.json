{"body": "Peter A-B writes:\n> why not put the modifier number in iargs ?\n>\n>      oldmod_string  ALIAS  newmod_string  oldbase_string\n>\n> is converted to\n>\n>      newmod_orec->omod = oldbase_number\n>      newmod_orec->oname = newmod_string\n>      newmod_orec->oargs->iargs[0] = oldmod_id\n\n\nThis would indeed be handy if IARGS were defined in the source, which \nit is not.  Defining it would not only create a problem with octree \nformat compatibility, it would increase scene storage size by 8 \nbytes/object, whether alias'es are present or not.  I don't think it's \nworth it.\n\n\nThe solution I suggested, where the modifier chain is used in the \nnormal case where we are not changing it with the alias, won't take any \nextra memory and won't incur a lookup during rendering.  Only if the \nmodifier was changed by the alias will we have to call lastmod(), and \nthis should be a small minority of the cases.  I don't see why a CAD \ntranslator would ever use this feature, for example.  In cases where \nthe user is playing with modifier chains, they would hopefully do so \nall in the same materials file, in which case the cost of calling \nlastmod() would be minimal, as the modifier is only a few objects away \nfrom the alias in the input.  We could add a note of advice along these \nlines to the reference manual when we document the new \"inherit\" alias \nkeyword.\n\n\nI do not believe that octrees will be invalidated by these changes -- \nwe should be able to maintain backward compatibility.  Frozen octrees \nwill certainly not be affected.  Since the old aliases occupied an \nobject record just as the new alias will, the object count won't change \nin a standard octree, so they should be fine as well.  Adding new \nprimitive types never affects backward compatibility, since we build a \ntype lookup when reading in an octree.  The only thing that causes \nproblems is removing a primitive type that is referenced in an octree, \nas one might expect.\n\n\nJack de Valpine writes:\n> Another area where alias handling can be a problem is in the \n> specification of a material for exclusion in the ambient calculation. \n> As things currently stand you must pass the name/id that is actually \n> used to modify the geometry, when in fact it might be preferable in \n> some cases to pass the name of the alias, e.g., if I have a material \n> \"black\" defined I would rather pass this name for exclusion than some \n> exporter derived name applied to the geometry.\n\n\nRegrettably, such a change would require some extensive coding.  Also, \nat what point in the modifier chain do you stop checking?  When you get \nto a material?  What about mixtures of two or more materials?  Some \npeople might be using the alias name as a way of controlling what to \ninclude or exclude from the ambient calculation.  I wouldn't want to \nmess them up in the process, either.\n\n\nUnless there are any objections, I'm going to go ahead and implement \nthese changes as I have outlined.  I'm also working on the new mesh \nprimitive, which I should be able to finish this week if all goes well. \n  Then, we can do a little testing and package a new release.\n\n\n-Greg\n___\n<sup>Automatically generated content from [radiance mailing-list](https://radiance-online.org/pipermail/radiance-dev/2003-March/000090.html).</sup>", "attachments": [], "created_by_name": "Greg Ward", "created_at": "March 10, 2003 at 10:20AM", "created_by": "Greg_Ward", "parent_id": "radiance-dev_000081", "id": "radiance-dev_000090"}