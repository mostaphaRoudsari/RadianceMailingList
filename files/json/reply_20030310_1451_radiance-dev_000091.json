{"body": "Greg Ward wrote:\n\n\n> The solution I suggested, where the modifier chain is used in the\n> normal case where we are not changing it with the alias, won't take any\n> extra memory and won't incur a lookup during rendering.  Only if the\n> modifier was changed by the alias will we have to call lastmod(), and\n> this should be a small minority of the cases.  I don't see why a CAD\n> translator would ever use this feature, for example.\n\n\nThe translator as such probably not, but Rayfront uses this all\nthe time to manipulate modifier trees. As it is now, Rayfront\nstores all modifier definitions in one file per project, which\ngets loaded first. The primitives in that file all have no\nmodifier of their own. The modifier trees that are then assigned\nto each geometry \"object\" are composed exclusively through\nrecursive aliases (I posted a simple example earlier in this\nthread).\n\n\nThis system was the only way that I could figure out that gives\nthe user complete freedom in combining materials and modifiers in\na GUI environment, so I'm not really prepared for any fundamental\nchanges in how it works.\n\n\n\n\n> In cases where\n> the user is playing with modifier chains, they would hopefully do so\n> all in the same materials file, in which case the cost of calling\n> lastmod() would be minimal, as the modifier is only a few objects away\n> from the alias in the input.\n\n\nRight now, Rayfront writes the !xform for each scene file and its\nassociated modifier/alias tree together, which would mean that\nthe aliases for the last scene file would have the complete scene\nahead of them to search through. I could change this, so that the\naliases come first, and the !xforms get combined together at the\nend in one block, which would move the geometry out of the way.\nThat's not quite as nice for someone looking at the file in an\neditor, although nobody should really need to do that...\n\n\nBut I'm still not happy with generating additional name lookups\nat runtime at all. Somehow I'm starting to think that using the\nsame data structure for geometry and modifier primitives might\nnot be quite such a good idea after all.\n\n\nIn an object oriented architecture, this problem would be solved\nby polyformism, which means that the aliases would get a\ndifferent brand of oargs, that includes niargs and *iarg.  This\nis also possible to do in C, just that the language doesn't\nexplicitly help us to get it right. The disadvantage is that the\nroutines allocating and freeing those structures need to know\nabout the difference and treat each instance accordingly.\n\n\nI actually think that this could still be done without backwards\nincompatible changes to the octree format. It should be possible\nto resolve the names once when loading the octree (which is a lot\nmore acceptable than repeatedly during a simulation), so that\nniargs and *iarg will only ever exist in memory.\n\n\nAll that probably sounds a lot more complicated than it actually\nis, and it would give us the best of both worlds. We could even\ngo further, and use the same principle to save more memory.\nAssume that polygons (and most other primitives) used a version\nof oargs that doesn't carry nsargs and **sarg around. That's an\neasy gain of several MB of RAM with non-trivial scenes. Ok, so I\nsaid that I'm against adding complexity just for relatively small\nmemory gains, but it could easily be that all it takes would be\ntwo more typedefs and a few carefully placed casts.\n\n\n\n\nThoughts? Counter arguments? Flames? ;)\n\n\n-schorsch\n\n\n\n\nGeorg Mischler  --  simulations developer  --  schorsch at schorsch com\n+schorsch.com+  --  lighting design tools  --  http://www.schorsch.com/\n___\n<sup>Automatically generated content from [radiance mailing-list](https://radiance-online.org/pipermail/radiance-dev/2003-March/000091.html).</sup>", "attachments": [], "created_by_name": "Georg Mischler", "created_at": "March 10, 2003 at 02:51PM", "created_by": "Georg_Mischler", "parent_id": "radiance-dev_000081", "id": "radiance-dev_000091"}