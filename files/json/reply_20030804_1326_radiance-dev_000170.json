{"body": "On Mon, Aug 04, 2003 at 12:19:58PM -0700, Greg Ward wrote:\n> Is there some way within a Unix program to determine where the \n> executable was found, other than researching the $PATH environment \n> variable to find where argv[0] lives?\n> \n\n\nI do not believe so, except in the Mac OS X Cocoa environment.  Even\nargv[0] is not certain, since it is only convention that it contain\nthe program name that was actually used.  System utilities usually\nresolve this with a file in /etc, but I don't like that solution for\nRadiance.\n\n\n> >\n> >>1. Calcomp.h and otypes.h have a pointer to an unprototype-able\n> >>function in their definitions. I haven't studied these enough to have\n> >>formed ideas on how to approach the problem, though I've discarded\n> >>several early approaches.  Would it be all right to bring this up on\n> >>the radiance-dev list?\n> >\n> >I brought those two up last time, since I assumed they are\n> >somehow related. I see that the functions involved actually all\n> >are X(void), but I'd like more input about what actually happens\n> >there before changing the prototypes. Greg?\n> \n> The function pointer declared in otypes.h cannot be easily prototyped, \n> as I'm using this pointer with different parameters depending on \n> whether it's being called by oconv or the renderers.  I'd rather leave \n> it this way.\n> \n\n\nI would, too.  But it's not mainstream C any more, and it won't work\nat all in C++, where that construct is equivalent to (*f)(void).  I do\nwish ISO C allowed (*f)(...), but it does not.  As I said, I have some\nthoughts on this that I want to explore futher.\n\n\n> The progotype for the eoper[] dispatch array in calcomp.h was easy to \n> prototype on the other hand, and I have done so.\n\n\nGreat!\n\n\n> I could do the same for the library function pointer in the LIBR\n> struct, except that it is assigned in so many places that it would\n> be a bit of a hassle to track them all down.  This pointer takes a\n> single char * argument, which is usually neither defined nor\n> examined by callers.  This makes it a big hassle to include as a\n> prototype, with little potential benefit to us as developers.  I'd\n> leave this as is, also.\n\n\nPerhaps just change it to void *, eventually?  That seems to me in\nline with your intentions.  The compiler can locate the references.\n\n\n> \n> I really consider these to be minor problems, though it would be nice \n> to build without installing.  The current rmake sans arguments builds \n> in the working directory without copying the executables anywhere.\n>\n\n\nI've seen that some things don't get built without \"install\"--the\nOpenGL files in common are one example, but I think I remember othes.\nTrying to make it so that all things got built without install led to\nmy deciding that the problem is non-trivial--I can do it with csh and\nmake, but I can't do it simply and portably.\n\n\n> \n> As for header files, it's not difficult to keep the Rmakefile's up to \n> date so long as you pay attention to what you're doing as you're doing \n> it.  It would be nice to have an automatic way to create the \n> dependencies, but mkdep is not fool-proof either, as it's easy to \n> forget to include all the relevant files that are in other directories \n> (mostly ../common) when you run it.\n> \n\n\nscons, which I've been playing with a bit, does all this.  And it\nseems to be clear.  But I'm still learning how to use it.  More on\nthis when I know more.\n\n\nRandolph\n___\n<sup>Automatically generated content from [radiance mailing-list](https://radiance-online.org/pipermail/radiance-dev/2003-August/000170.html).</sup>", "attachments": [], "created_by_name": "Randolph Fritz", "created_at": "August 04, 2003 at 01:26PM", "created_by": "Randolph_Fritz", "parent_id": "radiance-dev_000151", "id": "radiance-dev_000170"}