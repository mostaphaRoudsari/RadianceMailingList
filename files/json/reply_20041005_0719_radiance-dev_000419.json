{"body": "On Mon, Oct 04, 2004 at 04:20:47AM -0400, Georg Mischler wrote:\n> \n> >  More\n> > seriously, one might encounter systems where the alignment requirement\n> > is \"long double\" rather than \"double\", and future code which attempted\n> > to cast the result of bmalloc() to \"long double\" would fail.\n> \n> So on some systems you won't be able to increment a char* pointer\n> anymore? I'm not quite as pessimistic... ;)\n> \n\n\nOn some current RISC systems you can't do so with impunity.  For example:\n\n\n  offset = 2;\n  p = malloc(2*sizeof(double));\n  dp = (double *) (p + offset);\n  *dp = 1.0;  /* runtime error */\n\n\nI have little doubt that we will soon encounter RISC systems with\n128-bit wide data buses that require offset to be 16.  It is for this\nreason that the results of void* arithmetic is undefined by the\nstandard; there is no way to define it that is fast, space-conserving,\nand portable.  At the same time, every C compiler supports some\nversion of unbound pointer arithmetic because it is required for\nwriting storage allocators like calloc()/malloc()/free().\n\n\nI'd really rather not see more platform-dependent Radiance code.\nUnfortunately, it at least used to be the case that\nplatform-dependencies made for substantial performance improvements.\n\n\nMy long-term recommendation on such matters has not changed: it is\nbest, first, to test for performance problems and use existing library\nfacilities where performance problems are absent, second, to to use\nplatform-dependent code in a clean way when it is of value.\n\n\nRandolph\n___\n<sup>Automatically generated content from [radiance mailing-list](https://radiance-online.org/pipermail/radiance-dev/2004-October/000419.html).</sup>", "attachments": [], "created_by_name": "Randolph Fritz", "created_at": "October 05, 2004 at 07:19AM", "created_by": "Randolph_Fritz", "parent_id": "radiance-dev_000395", "id": "radiance-dev_000419"}