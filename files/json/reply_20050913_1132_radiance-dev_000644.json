{"body": "Greg Ward wrote:\n\n\n> Francesco wrote:\n>> I've finally started looking at rtcontrib to replace my own scripts to\n>> calculate daylight coefficients, and need to use it with windows\n>> (unfortunately!) and without cygwin, so I've been \"forced\" to try\n>> the mingw\n>> (http://www.mingw.org/) version of gcc to compile Radiance.\n>\n> Is this the target compiler we had in mind?  I don't know anything\n> about what's available under Windows, if schorsch (Georg Mischler)\n> meant for people to use the more common (and nasty) Visual C\n> standard.\n\n\nThere's no target compiler per se. Compiler specific stuff is\ndefined in the platform/*.cfg files, and the SCons magic will\n(hopefully) figure out which one to use.\n\n\nThe only difficulty here is that while we're compiling and\nlinking to the standard Windows libraries (apparently), the\ngcc in mingw expects other command line arguments than the\nVC compiler. We should create a seperate platform/mingw.cfg with\nthe parameters found. Francesco: Did you find any easy way to\ntell the difference from within SCons/Python? We already have a\nseperate *.cfg file for normal cygwin (using posix libraries),\nbut I don't remember how we figured out when to use that.\n\n\nFor the time being, you could try adding the following special\ncase to build_utils/load_plat.py (which should work, even if it's\nnot really pretty). I already checked in this change so it should\nbe in todays HEAD dump:\n\n\ndef load_plat(env, args, platform=None):\n\tfor k,v in env.items(): print k,v\n\tif os.name == 'posix':\n\t\tPOSIX_setup(env)\n\tif platform == None: # override\n\t\tp = sys.platform\n\telse: p = platform\n\tif p == 'win32' and 'gcc' in env['TOOLS']: # special case\n\t\tp = 'mingw'\n\tpl = []\n\tprint 'Detected platform \"%s\" (%s).' % (sys.platform, os.name)\n\t[etc...]\n\n\n\n\nPrinting all items of env might produce better clues. Also, what\ndoes mingw put in os.name and sys.platform?\n\n\n\n\n>> and had to manually add some extra RAD_COMPAT inside a couple\n>> of SConstruct files (maybe somebody can suggest a better\n>> CPPDEFINES line ...).\n\n\nWhat were the RAD_COMPAT entries?\n\n\n\n\n>> As for the source files:\n>>\n>> 1.\n>> I had to redefine kill() inside rad.c and ranimate.c\n>> using \"RT_PID pid\" instead of \"int pid\":\n>> int\n>> kill(RT_PID pid, int sig) /* win|unix_process.c should also wait\n>> and kill */\n>> {\n>>     return 0;\n>> }\n>\n> This seems a safe enough change, though rtprocess.h, where RT_PID is\n> defined, is not currently included in ranimate.c and will need to be\n> added.\n\n\nYes, the change as such is safe, although there were a few more\nplaces where int needed to be replaced by RT_PID (and should have\nbeen pid_t to start with). Of course, the real fix would be to\nuse our own process abstraction open_process() and friends\ninstead of fork() and exec(). In other words: both programs may\ncompile on Windows with those changes (now in CVS), but will not\nnecessarily work as expected yet.\n\n\n\n\n>> Also, inside win_process.c for the close_process() function:\n>> was -----------------> int win_kill(pid, 0);\n>> i've changed it to --> win_kill(pid, 0);\n>\n> I don't know if this affects compatibility under other compilers, so\n> I'll leave it to schorsch.\n\n\nwin_kill() is a drop-in replacement for posix kill(), so it\nmust return an int for status information (even if it doesn't\nactually do anything useful with it right now).\n\n\n\n\n>> 2.\n>> The mingw version of signal.h doesn't have a definition for\n>> SIGALRM, so\n>> killpersist() inside mkillum.c needs to be changed:\n>> It is like this:\n>> if (fscanf(fp, \"%*s %d\", &pid) != 1 || kill(pid, SIGALRM) < 0)\n>> but I've used SIGTERM instead of SIGALRM, don't know if this make\n>> much sense ...\n>\n> The only difference this will make is that the waiting rtrace process\n> will report an error instead of going quietly.\n\n\nI'm not sure if I understand this right now (but then, I just\nreturned from Mongolia, so don't expect too much).\n\n\n\n\n>> 3.\n>> rtcontrib was calling rtrace with a wrong command line. It was\n>> something like\n>> this:\n>>\n>> c:\\radiance\\bin/rtrace.exe rtrace [args ...]\n>>\n>> After some little searching I used this quick workaround inside\n>> win_process.c\n>>\n>>             cmdpath = getpath(av[0], getenv(\"PATH\"), X_OK);\n>> added by me -->    av[0] = \"\";\n>>             cmdstr = quoted_cmdline(cmdpath, av);\n>>\n>> that may have broken something somewhere else, so probably\n>> a better solution would be to do some extra checks inside the\n>> _WIN32 section\n>> of getpath.c.\n>>\n>> I am interested only in rtcontrib right now, so I haven't checked\n>> if other programs that call open_process() are still working or not.\n>\n> win_process.c is all schorsch's work, so he'll have to respond to\n> this one as well.\n\n\nI don't think your change breaks anything, but it's still not\nthe nice thing to do. Instead of feeding an empty string (which\nresults in a double width space in the command line) just pass\nonly the remainder of the argument list to quoted_cmdline():\n\n\n  cmdstr = quoted_cmdline(cmdpath, av+1);\n\n\n(Now in CVS)\nI think this is save, because the first item will always be\nthe name of the command, and if there are no arguments, then\nthe second item will be NULL, which quoted_cmdline() should\nhandle correctly (I don't have a Windows system at hand right\nnow, though, so it's up to you to try...).\n\n\n\n\n>> 4.\n>> Mingw doesn't have fseeko(), and I replaced it with fseek() inside\n>> rtcontrib.c.\n>> This seems to have broken the file output, that is working well\n>> with both\n>> cygwin and linux. Is there an easy workaround for this? I don't\n>> have very\n>> much experience to figure it out myself. Output to stdout now works\n>> fine ...\n> The original call:\n>\n>      if (fseeko((FILE *)e->data, *(off_t *)p, SEEK_CUR) < 0) {\n>\n> could be replaced by:\n>\n>      if (fseek((FILE *)e->data, *(off_t *)p, SEEK_CUR) < 0) {\n>\n> or even -Dfseeko=fseek on the compile line and it should work for\n> files less than 2 GB in size.  I assume that off_t is defined in your\n> system, otherwise you would have had other errors.  If it isn't\n> defined as \"long\", then you might need another cast, like so:\n>\n>      if (fseek((FILE *)e->data, (long)*(off_t *)p, SEEK_CUR) < 0) {\n>\n> Once we find a working substitute, we can add the appropriate macro\n> to platform.h.\n\n\nMicrosoft only supports long files in the low level _lseeki64(), but\nnot in the stream routine(s). In the short term, -Dfseeko=fseek\nlooks like a reasonable workaround.\n\n\nActually, it seems that eg. recover_output() does both fseeko()\nand lseek(fileno(fp)) on the same file (the latter through\nmyseeko()). Is this actually so? And if yes, what does it exactly\nmean? Can we substitute _lseeki64(fileno(fp), offset, origin) for\nfseeko(fd, offset, whence) when _FILE_OFFSET_BITS is set to 64 or\ndo the two calls have different semantics?\n\n\n\n\nI also updated some of the SConscript files in CVS, most\nprominently to work with the new tifflib, and a few other more\ncosmetic changes.\n\n\n\n\n-schorsch\n\n\n\n\nGeorg Mischler  --  simulations developer  --  schorsch at schorsch com\n+schorsch.com+  --  lighting design tools  --  http://www.schorsch.com/\n___\n<sup>Automatically generated content from [radiance mailing-list](https://radiance-online.org/pipermail/radiance-dev/2005-September/000644.html).</sup>", "attachments": [], "created_by_name": "Georg Mischler", "created_at": "September 13, 2005 at 11:32AM", "created_by": "Georg_Mischler", "parent_id": "radiance-dev_000641", "id": "radiance-dev_000644"}