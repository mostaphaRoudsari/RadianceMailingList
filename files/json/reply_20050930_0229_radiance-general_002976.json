{"body": "\"It is possible [to do almost anything in any language].  However, just\nbecause one can get a pea up a mountain by pushing it with one's nose does\nnot mean that is the best way of getting it there!\"--(I forget who)\n\n\nOne can do shell-like scripting in most languages these days.  Language\npreferences divide sharply, and often people simply prefer the language\nthey have learned first.  On the commercial side, language choices are\noften made for non-technical reasons, and there is something to be said\nfor using languages best fitted to a platform; if one is integrating\nRadiance with AutoCAD, there is much to be said for AutoLISP or even (woe)\nVisual Basic.\n\n\nThat said, I will offer these opinions:\n\n\n1. Generally, Python is widely accepted as a simple, object-oriented\ninterpretive language that can be used for serious applications work. \nRuby, though less widely used, is also considered good for such jobs. \nPerl can be used in this way, but one must be disciplined in its use, or\nit will have the problems of a shell.\n\n\n2. The heavy use of textual substitution as a programming technique in\ntraditional shells (sh, ksh, bash, csh, and so on) makes for large scripts\nthat are difficult to read and maintain--there is a particular problem\nwith file names that contain punctuation or spaces; if one makes extensive\nuse of variable substitution in Perl one has the same problems.  And,\ndistressingly, no-one actually knows what languages the traditional shells\naccept, not even the people who maintain them; one is often forced to rely\non testing to determine the results of a particular incantation and there\nis no guarantee one will see consistent behavior across platforms.\n\n\n3. There are a number of useful but less popular languages with devoted\nfollowings: the \"rc\" shell and LISP itself, the grandad of all\nprogrammerly interpretive languages, come to mind.  However, if one wants\ntools to be accessible to the widest developer community, it is probably\nbest to stick with more widely accepted tools.  There are oddities, too:\none could, for instance, use the web server language PHP, but I cannot see\na good reason to do so.\n\n\n4. While it is possible to do shell-like tasks in compiled languages like\nC, the debugging and maintenance effort is such that it is probably not\nusually worth the trouble.  Microsoft's much-promoted C# has some of the\nsame problems.\n\n\n5. Java.  Well, it can do the job.  But it seems to me to combine some of\nthe difficulties of programming in a compiled language (a persnicketty\ntyping system and a relatively long learning curve) with the difficulties\nof interpretation (slowness).  The sheer amount of study (not to mention\nthe cost of texts) required to learn the Java class libraries is daunting.\n Still, it is pervasive, so maybe there is a role for it.\n\n\nLots of choices.  Personally, I'd recommend Perl, Python, or Ruby as one\nis most comfortable.  If one doesn't already know a shell well, I'd say\nthat Python is the easiest to learn, and is most satisfying to a beginner\nbecause of it, but one can get good results using any of those languages. \nGreg uses csh, and it's worth knowing it just to read existing Radiance\nscripts, but of the shells it is the most cranky, and I wouldn't advise\nstarting there.  It helps to know a bit of Unix to get the best use out of\nany shell, even if one is programming for Windows; I still recommend the\nold CACM Unix article as a worthy reference.\n\n\nHope this helps!\n\n\nRandolph\n___\n<sup>Automatically generated content from [radiance mailing-list](https://radiance-online.org/pipermail/radiance-general/2005-September/002976.html).</sup>", "attachments": [], "created_by_name": "Randolph Fritz", "created_at": "September 30, 2005 at 02:29AM", "created_by": "Randolph_Fritz", "parent_id": "radiance-general_002966", "id": "radiance-general_002976"}