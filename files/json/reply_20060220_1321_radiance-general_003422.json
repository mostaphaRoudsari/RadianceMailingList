{"body": "On 20.02.2006, at 10:39, Francesco Anselmo wrote:\n\n\n> I remember having similar problems and having fixed them with this\n> check:\n> w,h = img.getSize()\n> if w>h:\n>    objfile.write(\"vt \" + str(uvco[0]*(float(w)/float(h))) + \" \" +\n> str(uvco[1]) + \"\\n\")\n> else:\n>    objfile.write(\"vt \" + str(uvco[0]) + \" \" +\n> str(uvco[1]*(float(h)/float(w))) + \"\\n\")\n\n\nThanks for the hint. I mad a few tests with different images\nand found that the exported UV coords are always in the range\n(0,1) for _both_ dimensions. I think this is the common range\nfor UVs in all CG applications except Radiance. Here we have\ncoords range (0,1) for the smaller dimension and (0,l/s) for\nthe larger, so above 1 for all non-square images.\n\n\nAs a result the texture image area is croped to the lower left\nsquare of the image. Your code multiplies the coords for the\nlarger side with the image aspect (>1!) to cover the whole\nimage in Radiance texture space. I'll have to go that way, too,\n(no big thing for a dedicated Radiance exporter) but I wish\nthere was a way to define the texture with the right image aspect\nso any uv enabled *.obj file could be mapped correctly without\nrewriting the coords.\n\n\n> void colorpict facematerialbasename\n> 7 red green blue facematerialbasename.pic . Lu Lv\n> 0\n> 0\n\n\nJust checked the meaning of 'frac()' and I think Lu/Lv is in\nfact the better choice for uv coord mapping than frac(Lu/Lv).\nThe vertices do not have to cover the whole image after all.\n\n\n> Hope to have understood your problem, and that this helps.\n\n\nYes. Another step closer to Blender world domination.\n\n\nThomas\n___\n<sup>Automatically generated content from [radiance mailing-list](https://radiance-online.org/pipermail/radiance-general/2006-February/003422.html).</sup>", "attachments": [], "created_by_name": "Thomas Bleicher", "created_at": "February 20, 2006 at 01:21PM", "created_by": "Thomas_Bleicher", "parent_id": "radiance-general_003417", "id": "radiance-general_003422"}