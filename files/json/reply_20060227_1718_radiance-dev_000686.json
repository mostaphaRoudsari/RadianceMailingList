{"body": "Well, it's a bit out of date, but there's the old document that  \ndescribes the source tree.  Probably not really what you're looking  \nfor, but it's all I know about:\n\n\n\thttp://radsite.lbl.gov/radiance/refer/srctree.pdf\n\n\nWhile I agree there may be some vectorization possibilities offered  \nby the many color and vector operations in the code, I don't know  \nthat they would really pay off as the set-up time (overhead) would  \nprobably eliminate any savings you got from a single assignment or  \ndot product.  Vectorization helps much more when you have longer  \nvectors and arrays, and everything is 3-vectors in Radiance.\n\n\nIf you want to test the idea if short vectors can actually speed up  \nthe code, work on the known bottlenecks first, like the ray traversal  \ncode in src/rt/raytrace.c.  In particular, the raymove() routine.   \nTry vectorizing:\n\n\n\tpos[0] += r->rdir[0]*t;\n\tpos[1] += r->rdir[1]*t;\n\tpos[2] += r->rdir[2]*t;\n\n\nI suspect you will see negligible gains, because (1) the overhead  \nwill kill you and (2) the conditional code above this dominates on  \nmodern pipelined processors.\n\n\n-G\n___\n<sup>Automatically generated content from [radiance mailing-list](https://radiance-online.org/pipermail/radiance-dev/2006-February/000686.html).</sup>", "attachments": [], "created_by_name": "Greg Ward", "created_at": "February 27, 2006 at 05:18PM", "created_by": "Greg_Ward", "parent_id": "radiance-dev_000683", "id": "radiance-dev_000686"}