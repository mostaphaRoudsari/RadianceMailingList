{"body": "> If you want to test the idea if short vectors can actually speed up \n> the code, work on the known bottlenecks first, like the ray traversal \n> code in src/rt/raytrace.c.  In particular, the raymove() routine.  Try \n> vectorizing:\n>\n> \tpos[0] += r->rdir[0]*t;\n> \tpos[1] += r->rdir[1]*t;\n> \tpos[2] += r->rdir[2]*t;\n>\n> I suspect you will see negligible gains, because (1) the overhead will \n> kill you and (2) the conditional code above this dominates on modern \n> pipelined processors.\n\n\nI think also oconv and the intersection tests (rt/o_*) would benefit, \nBUT: altivec supports float at most, while vectors (fvect) in radiance \nusually are doubles as long as I do not define SMLFLT. That means there \nis really no hope at the moment.\n\n\nCU Lars.\n___\n<sup>Automatically generated content from [radiance mailing-list](https://radiance-online.org/pipermail/radiance-dev/2006-March/000690.html).</sup>", "attachments": [], "created_by_name": "Lars O. Grobe", "created_at": "March 04, 2006 at 03:37PM", "created_by": "Lars_O._Grobe", "parent_id": "radiance-dev_000683", "id": "radiance-dev_000690"}