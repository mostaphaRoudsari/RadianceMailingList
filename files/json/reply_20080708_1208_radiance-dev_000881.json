{"body": "Hi Randolph,\n\n\nJust a quick comment on your idea of implementing a mini-shell within  \nRadiance's scene description language -- I assume you mean this to  \ntake care of the \"!command\" lines in the input, correct?  In any  \ncase, you should not underestimate the difficulties in converting  \neven a small number of command-line tools into library calls, as the  \ngeneral assumption of separate process spaces means the use of i/o  \nand globals is a big mess to clean up.  Personally, I can't imagine  \nit being worth the effort, as there would be no real gain in  \nfunctionality, and worse maintenance headaches down the line.  Taking  \na system like Radiance, which is based on the Unix toolbox model, and  \nturning it into a set of library routines, is not a weekend task.  Do  \nyou know of any examples of systems that have been successfully  \nconverted in this way?  I'd be interested to hear of any.\n\n\nI'm curious how a system like Radiance could be fit into a set of C++  \nclasses.  There must be a way, and I'm not saying it's a bad idea,  \nbut the general toolbox approach is standardized on a (preferably  \nsmall) set of stream data formats.  I guess you would try to hook the  \noutput of one object into the input of another, or something like  \nthat.  It seems feasible, at least in principle.\n\n\nAnyone else have thoughts on this?\n\n\n-Greg\n___\n<sup>Automatically generated content from [radiance mailing-list](https://radiance-online.org/pipermail/radiance-dev/2008-July/000881.html).</sup>", "attachments": [], "created_by_name": "Greg Ward", "created_at": "July 08, 2008 at 12:08PM", "created_by": "Greg_Ward", "parent_id": "radiance-dev_000878", "id": "radiance-dev_000881"}