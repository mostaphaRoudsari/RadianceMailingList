{"body": "> I'm curious how a system like Radiance could be fit into a set of C++\n> classes.  There must be a way, and I'm not saying it's a bad idea,\n> but the general toolbox approach is standardized on a (preferably\n> small) set of stream data formats.  I guess you would try to hook the\n> output of one object into the input of another, or something like\n> that.  It seems feasible, at least in principle.\n\n\nThat was basically my thinking; the C++ streambuf template is a  \nwonderful thing; one might even be able to get away with using the  \nistrstream and ostrstream classes in many cases, preserving the  \nexisting model with very little effort. The second thought was to (in  \nplaces where operations can be serialized) copy globals to class  \ninstance variables, thereby encapsulating the existing app in the  \nclass. This clearly won't work in all cases, but it might work in  \nenough to be worth using.\n\n\n> Just a quick comment on your idea of implementing a mini-shell within\n> Radiance's scene description language -- I assume you mean this to\n> take care of the \"!command\" lines in the input, correct?  In any\n> case, you should not underestimate the difficulties in converting\n> even a small number of command-line tools into library calls, as the\n> general assumption of separate process spaces means the use of i/o\n> and globals is a big mess to clean up.  Personally, I can't imagine\n> it being worth the effort, as there would be no real gain in\n> functionality, and worse maintenance headaches down the line.\n\n\nIf it turns out to be possible, I think there would be a substantial  \ngain in the speed of reading of scene description files because of a  \nreduction in process creation, especially on Windows, where processes  \nare heavyweight. Even on Unix, creating two processes for a common  \noperation like xform seems to me a lot of overhead, especially when  \none of those processes is a large modern shell. I agree it would be  \nharder to maintain--memory leaks and unbounded pointers are a pain in  \na large app--but not that much harder; large applications do this all  \nthe time, these days. Hopefully, it could be done with a minimum of  \nchanges to existing code. I would like to try, at least, provided I  \ncan find the time.\n\n\n> Taking a system like Radiance, which is based on the Unix toolbox  \n> model, and\n> turning it into a set of library routines, is not a weekend task.  Do\n> you know of any examples of systems that have been successfully\n> converted in this way?  I'd be interested to hear of any.\n\n\nNo, that I don't--anyone else? But it seems to me that this is at  \nleast a plausible approach, and one that preserves most of the  \nexisting code and model. I very much like the Unix toolbox model.  \nUnfortunately, the current widely used UI technologies are hostile to  \nthat model and I would like to adapt Radiance to work with those  \ntechnologies.\n\n\n> Anyone else have thoughts on this?\n\n\nPlease!\n\n\nRandolph\n___\n<sup>Automatically generated content from [radiance mailing-list](https://radiance-online.org/pipermail/radiance-dev/2008-July/000887.html).</sup>", "attachments": [], "created_by_name": "R Fritz", "created_at": "July 09, 2008 at 09:22AM", "created_by": "R_Fritz", "parent_id": "radiance-dev_000878", "id": "radiance-dev_000887"}