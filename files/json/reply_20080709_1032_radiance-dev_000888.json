{"body": "Hi Randolph,\n\n\n From a performance standpoint, the vast majority of time is spent on  \nthe ray-tracing part for most of what people do using Radiance.   \nHence, there's not much point in optimizing the loading of scene  \nfiles or connecting up the various subordinate utilities in dynamic  \nlibraries.  You simply won't save much over shelling out the commands  \nand reading and writing the files or connecting up pipes (or whatever  \nthe Windows equivalent is).  If 99% of the time is consumed by rpict  \nor rtrace or rvu, why bother optimizing the rest, especially if it's  \na ton of work?  You don't need dynamic libraries to create a GUI --  \nschorsch has done quite well using Rayfront to generate the necessary  \ninputs and parameters for Radiance commands and running them as  \nseparate processes.\n\n\nYou also have to think about what kind of functionality you are  \ntrying to add with your GUI.  A big reason Radiance is used in so  \nmany disciplines is thanks to the toolbox model, which allows you to  \ncombine programs in all sorts of ways the authors never intended.  A  \nGUI typically defeats this benefit, unless you follow a data flow  \nmodel in your interface.  Give the user a menu, take away 1000  \nopportunities.  It makes the easy things easy, but the difficult  \nthings become impossible.\n\n\nJudicious use of make and the oconv -f option ameliorates most of the  \npain of loading hierarchical Radiance scene descriptions, as the  \ncommands are only run the first time (or when the scene changes).\n\n\nHaving worked both on GUI applications (mostly Photosphere) and  \ncommand-line tools, I know the programming paradigm is very  \ndifferent.  Lots of things will get you in a monolithic application  \nthat simply were not a problem with a set of tools.  Although I'm  \ngenerally pretty good with memory, I don't usually free stuff in a  \ntool when I know I'll need the memory until the process exits.   \nWhat's worse, I will call exit(1) when something goes wrong, and  \nerror handling is generally much less robust in a tool environment,  \nsince individual processes are considered expendable.  I have  \nextensive error management in Photosphere compared to Radiance, and  \nit's not something that's easy to add as an afterthought.  You can  \nplay some games like \"#define exit(s) my_return_jump(s)\" using  \nlongjump(3), but you end up with a real mess in terms of memory leaks  \nand the like.  (I've had to do this with the JPEG library, so I know.)\n\n\n-Greg\n___\n<sup>Automatically generated content from [radiance mailing-list](https://radiance-online.org/pipermail/radiance-dev/2008-July/000888.html).</sup>", "attachments": [], "created_by_name": "Greg Ward", "created_at": "July 09, 2008 at 10:32AM", "created_by": "Greg_Ward", "parent_id": "radiance-dev_000878", "id": "radiance-dev_000888"}