{"body": "> From a performance standpoint, the vast majority of time is spent on  \n> the ray-tracing part for most of what people do using Radiance.   \n> Hence, there's not much point in optimizing the loading of scene  \n> files or connecting up the various subordinate utilities in dynamic  \n> libraries.  You simply won't save much over shelling out the  \n> commands and reading and writing the files or connecting up pipes  \n> (or whatever the Windows equivalent is).  If 99% of the time is  \n> consumed by rpict or rtrace or rvu, why bother optimizing the rest,  \n> especially if it's a ton of work?  You don't need dynamic libraries  \n> to create a GUI -- schorsch has done quite well using Rayfront to  \n> generate the necessary inputs and parameters for Radiance commands  \n> and running them as separate processes.\n\n\nI haven't seen Rayfront in a few years, so I don't know where it's  \ngone; I have seen Ecotect, and it's cranky. And you're right, of  \ncourse, that to overall rendering time improving oconv doesn't matter  \nvery much, but to the user experience it does matter; people complain  \nabout oconv delays, even though they're not most of the time it takes  \nto use Radiance.\n\n\n> You also have to think about what kind of functionality you are  \n> trying to add with your GUI.  A big reason Radiance is used in so  \n> many disciplines is thanks to the toolbox model, which allows you to  \n> combine programs in all sorts of ways the authors never intended.  A  \n> GUI typically defeats this benefit, unless you follow a data flow  \n> model in your interface.  Give the user a menu, take away 1000  \n> opportunities.  It makes the easy things easy, but the difficult  \n> things become impossible.\n\n\nThe intention is to maintain the existing toolbox, and also have a GUI.\n\n\n> Judicious use of make and the oconv -f option ameliorates most of  \n> the pain of loading hierarchical Radiance scene descriptions, as the  \n> commands are only run the first time (or when the scene changes).\n\n\nMmmm...I'm aiming at a different user base.\n\n\n> Having worked both on GUI applications (mostly Photosphere) and  \n> command-line tools, I know the programming paradigm is very  \n> different.  Lots of things will get you in a monolithic application  \n> that simply were not a problem with a set of tools.  Although I'm  \n> generally pretty good with memory, I don't usually free stuff in a  \n> tool when I know I'll need the memory until the process exits.   \n> What's worse, I will call exit(1) when something goes wrong, and  \n> error handling is generally much less robust in a tool environment,  \n> since individual processes are considered expendable.  I have  \n> extensive error management in Photosphere compared to Radiance, and  \n> it's not something that's easy to add as an afterthought.  You can  \n> play some games like \"#define exit(s) my_return_jump(s)\" using  \n> longjump(3), but you end up with a real mess in terms of memory  \n> leaks and the like.  (I've had to do this with the JPEG library, so  \n> I know.)\n\n\nOw. That's non-trivial. I suppose using garbage collection, and  \ntrapping the exit() calls in atexit() would resolve most of these  \nissues, but it would have to be looked at carefully. Ideally only  \ninclude it in the wrapper code, so that the existing apps would  \ncontinue to work as before. Maybe the Boehm/Demers/Weiser collector?  \nAnyone have any experience with it?\n\n\nRandolph\n\n\nRef: Boehm GC, <http://www.hpl.hp.com/personal/Hans_Boehm/gc/>\n___\n<sup>Automatically generated content from [radiance mailing-list](https://radiance-online.org/pipermail/radiance-dev/2008-July/000889.html).</sup>", "attachments": [], "created_by_name": "R Fritz", "created_at": "July 09, 2008 at 12:41PM", "created_by": "R_Fritz", "parent_id": "radiance-dev_000878", "id": "radiance-dev_000889"}