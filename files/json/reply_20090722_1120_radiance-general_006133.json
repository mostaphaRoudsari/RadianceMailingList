{"body": "Like so many other aspects of Radiance, the notion of view files has  \nevolved to where it is, and changing things at this point would  \nprobably mean breaking a lot of scripts.\n\n\nAs Jack pointed out, rpict takes the LAST (not the first) view in a  \nview file as the valid one.  Technically, it takes the accumulation  \nof view settings, so if for some reason a person had in their file:\n\n\nVIEW= -vta -vh 180 -vv 150 -vp 10 5 3 -vd .1 .9 -.1\nVIEW= -vtv -vh 50 -vv 35\n\n\nThe actual view used would be \"-vtv -vh 50 -vv 35 -vp 10 5 3 -vd .1 . \n9 -.1\"\n\n\nSince rvu appends to a view file a complete specification, the  \nearlier views are generally irrelevant.  The reason rvu appends  \nrather than overwrites this file is two-fold:\n\n\n\t1) It is often handy to edit the view file to get back to a previous  \nview that you realize you liked better than the final view you wrote  \nthere.\n\n\n\t2) You can use the append feature and the fact that anything  \nfollowing the view file in the rvu \"view\" command is added at the end  \nof the line makes for a convenient way to store key frames and time  \nfrom the previous keyframe, which the spline.cal function can then  \nuse to interpolate animated paths -- see footnote at the end of this  \nmessage.\n\n\nHaving rpict ignore all but the last view in a file was the most  \nconvenient way to get the behavior I wanted.  If your wish is to have  \nrpict render all views in the file instead, you can simply run it as:\n\n\n\trpict [options] -S 1 -o frame%02d.hdr octree < vlist.vf\n\n\nAnother nice thing about doing it this way is that you can start as  \nmany rpict processes as you have processors and you get to run your  \nsequence in parallel.  This is what rad does in fact, using also the - \nPP option to share memory as well.\n\n\nGetting back to your suggested modification to rad's behavior, I  \nexpect it would cause some confusion and consternation for users who  \ncreate their view files with rvu and overwrite previous views if they  \ngot multiple renderings they weren't expecting of views they didn't  \nwant.  Also, I'd have to think up yet another naming scheme for the  \nmultiple output pictures, which I'm very reluctant to do.\n\n\n-Greg\n\n\n-Greg\n\n\nFootnote:\n\n\nUsing rvu to create key frame positions and interpolating these for a  \nwalk-through animation path:\n\n\n\t\t(in rvu): view key.vf -t 1.5\n\t\t(in rvu): [some view changes to get to the next key frame position]\n\t\t(in rvu): view key.vf -t 2.5\n\t\tetc.\n\n\nThe view file can then be converted to something usable with:\n\n\n\trcalc -i key.fmt -e '$1=px;$2=py;$3=pz;$4=dx;$5=dy;$6=dz;$7=vh;$8=vv; \n$9=t' \\\n\t| tabfunc Px Py Pz Dx Dy Dz Ah Av T > key.cal\n\n\nWhere \"key.fmt\" contains:\nrvu -vtv -vp ${px} ${py} ${pz} -vd ${dx} ${dy} ${dz} -vu 0 0 1 -vh $ \n{vh} -vv ${vv} -vo 0 -va 0 -vs 0 -vl 0 -t ${t}\n\n\nInterpolating a path of 1000 frames can be done with something like:\n\n\n\tcnt 1000 | rcalc -f key.cal -f spline.cal -o view.fmt -e 't=Ttot/999* \n$1' \\\n\t\t-s vt=v -e 'vux=0;vuy=0;vuz=1;vo=0;va=0;vs=0;vl=0' \\\n\t\t-e 'vpx=s(Px);vpy=s(Py);vpz=s(Pz);vh=s(Ah);vv=s(Av)' \\\n\t> animpath.vf\n\n\nBoth \"spline.cal\" and \"view.fmt\" are provided in ray/src/cal/cal/.   \nThis path can then be handed to ranimate for a nice walk-through  \nsequence.\n\n\nThis is mostly from memory, so I may have messed up on a detail or  \ntwo...\n___\n<sup>Automatically generated content from [radiance mailing-list](https://radiance-online.org/pipermail/radiance-general/2009-July/006133.html).</sup>", "attachments": [], "created_by_name": "Greg Ward", "created_at": "July 22, 2009 at 11:20AM", "created_by": "Greg_Ward", "parent_id": "radiance-general_006122", "id": "radiance-general_006133"}