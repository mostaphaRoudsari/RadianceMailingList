{"body": "Hi Axel,\n\n\n>> In lieu of reprojecting the image with pinterp, which is as you say unsupported, it is possibly to apply a correction to the image values to account for the difference in solid angle at each pixel.  Given that the solid angle of the equisolid-angle projection is the same for each pixel, we really only need the solid angle for the equidistant projection.  This can be computed with a simple expression, which is sin(theta)/theta.\n> \n> You see, this is where I get a little lost between 'projection',\n> 'distortion', and 'vignetting'. They are, of course, different things.\n> Something like (don't quote me on it):\n> - projection: that would be 'equidistant' or 'equisolidangle'\n> - distortion: the deviation from the ideal 'projection'. Think pin\n> cushion or barrel\n> - vignetting: drop-off in image brightness towards the image horizon\n> \n> Would not the sin(theta)/theta correction account only for the pixel\n> brightness? In other words: the pixel 'location' on the photographic\n> plate/CCD chip would still be wrong, so that the Guth index in the UGR\n> formula would be off?\n\n\nThe brightness of the pixel will be correct once you've accounted for vignetting.  The sin(theta)/theta multiplier is used to reweight the pixel so that it contributes the same amount to luminous flux (luminance times steradians) everywhere in the image.  This is what you need for the glare source calculations, I think.  Otherwise, you would be treating the light sources near the view horizon as bigger than they should be.\n\n\n> I can imagine that one could create a pcomb cal file that builds up a\n> new image from the corrected radial distance of the pixel in the\n> source image. If this get too aliased (blocky), one could average over\n> the nearby pixels using the optional x,y offset that pcomb provides,\n> e.g. (spaces added for clarity):\n> ro=.5*ri(1) + .5*( ri(1,-1,0)+ri(1,1,0)+ri(1,0,-1)+ri(1,0,1) )/4 etc\n> which is effectively a box filter. Not tested! Don't try this at home!\n> One could fiddle with the pixel/off-pixel multipliers (both .5 in this\n> case) to see what would look best. I'm not sure how floating point\n> pixel coordiantes are handled by pcomb. Are they just rounded off?\n\n\nI suppose this would work, but it seems more work than is necessary.  Yes, floating point pixel coordinates are rounded off.\n\n\n> This approach would, of course, smudge out the luminance of the new,\n> constructed pixel to a certain extend, but considering that the lens\n> rensponse function does this anyhow, it's probably a small price to\n> pay for a smooth-as-a-baby's-bottom image.\n> \n> This would correct the pixel 'position', but where I get confused with\n> all this is this: How would one then have to correct the pixel\n> brightness (vignetting?) to account for this re-projection of pixel\n> locations, while still maintaining photometric integrity of the image\n> as a whole (vertical illuminance, say... Or UGR)?\n\n\nI guess you'd want to correct for vignetting in whatever projection you measured your vignetting error, probably before getting to this reprojection stage.  I still think the easiest thing is to correct for vignetting and pixel size at the same time, then go ahead and treat the image as if its an equidistant projection.  In other words, divide by the solid angle ratio (i.e., multiply each pixel by theta/sin(theta)) and then pass it through findglare as you would normally.\n\n\nMake sense?\n-Greg\n___\n<sup>Automatically generated content from [radiance mailing-list](https://radiance-online.org/pipermail/hdri/2012-February/000351.html).</sup>", "attachments": [], "created_by_name": "Greg Ward", "created_at": "February 03, 2012 at 01:00PM", "created_by": "Greg_Ward", "parent_id": "hdri_000348", "id": "hdri_000351"}