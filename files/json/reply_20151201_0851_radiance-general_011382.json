{"body": "Hi Jan,\n\n\nAs you discovered, the code isn't sophisticated enough to handle virtual source materials (mirror, prism, prism2) through the mixfunc interface.  (BTW, mixfunc also fails for light sources.)  However, you can use the \"alternate material\" argument to the mirror primitive to specify a different behavior for when the mirror is not directly participating in the virtual source relay calculation.  You could have a chain like this, which would work:\n\n\nvoid metal mat1\n[arguments]\n\n\nvoid plastic mat2\n[arguments]\n\n\nvoid mixfunc mat1+2\n4 mat1 mat2 mixing_var mixit.cal\n0\n0\n\n\nvoid mirror mmat1+2\n1 mat1+2\n0\n3 .5 .5 .5\n\n\n\n\nWhen the mirror material is participating in the virtual source calculation, it reflects everything at 50%.  When it's participating in the interreflection calculation, or you look at it directly, then it switches to the mixfunc mat1+2's behavior.\n\n\nIf one of your goals is to have the mixfunc control the amount of reflected light in the virtual calculation, I'm afraid you will need to use a brightfunc modifier on the mirror material, instead.  You can do this in conjunction with an alternate material to make the behavior consistent if you like.  In the example above, let's say that mat1 is mirror-like with 80% reflectance and mat2 is diffusing.  You could use the same cal file for your brightfunc, modifying the mirror primitive like so:\n\n\nvoid brightfunc mir_amt\n2 mixing_var mixit.cal\n0\n0\n\n\nmir_amt mirror mmat1+2\n1 mat1+2\n0\n3 .8 .8 .8\n\n\n\n\nDoes this make sense?\n\n\n-Greg\n___\n<sup>Automatically generated content from [radiance mailing-list](https://radiance-online.org/pipermail/radiance-general/2015-December/011382.html).</sup>", "attachments": [], "created_by_name": "Greg Ward", "created_at": "December 01, 2015 at 08:51AM", "created_by": "Greg_Ward", "parent_id": "radiance-general_011381", "id": "radiance-general_011382"}