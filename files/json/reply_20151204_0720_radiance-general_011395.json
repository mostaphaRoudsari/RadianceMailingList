{"body": "Hello Wouter,\n\n\nI remember doing this quite a while ago. My approach was to create a sky\nwith the actual patch values and render just one image. To do this I:\n\n\n\n\n   1. Generate the sky vector values using... using -h for removing the\n   header might be useful.\n      - gensky XXXXXXX | genskyvec -h | rcalc -e '$1 =\n      $1*0.265+$2*0.67+$3*0.065\n      - This will lead to one a vector of one value per sky patch.\n   2. modified the reinhartb.cal file to create a mod_reinhartb.cal (see\n   below). Be aware of modifying the MF parameter according to your needs.\n   3. Paste the vector generated on Step 1 in the mod_reinhartb.cal\n   4. Write the sky.rad file.\n   5. oconv sky.rad > octree.oct\n   6. rpict -vth -vd 0 0 1 -vu 0 1 0 -vh 180 -vv 180 -vp 0 0 0 -ab 3\n   octree.oct > sky.hdr\n\n\nYou can also plot the values generated on step 1\n\n\nHope this help\n\n\nGerm\u00e1n\n\n\n\n\n\n\n\n\n\n\n#sky.rad\n\n\nvoid brightfunc skyfunc\n2 rad ./mod_reinhartb.cal\n0\n0\n\n\nskyfunc glow skyglow\n0\n0\n4 1 1 1 0\n\n\nskyglow source sky\n0\n0\n4 0 0 1 180\n\n\n\n\n\n\n######################################\n######################\n\n\n\n\n### mod_reinhartb.cal\n{ RCSid $Id: reinhartb.cal,v 2.6 2015/03/27 18:58:06 greg Exp $ }\n{\nCompute Reinhart high-density sky patch bin (rbin)\n\n\nMF - Subdivision value (usually a power of two)\nDx,Dy,Dz - Incident direction (normalized, towards surface face)\nrNx,rNy,rNz - Surface normal (normalized, away from surface)\nUx,Uy,Uz - Up direction vector (does not need to be normalized)\n\n\nModified from reinhart.cal\n\n\nJuly 2014 G. Ward\n}\n{ Useful factors and functions }\nDEGREE : PI/180;\nAsin(x) : if(x-1, PI/2, if(-1-x, -PI/2, asin(x))) / DEGREE;\nposangle(a) : if(-a, a + 2*PI, a) / DEGREE;\nAtan2(y,x) : posangle(atan2(y,x));\n\n\n{ Default to Tregenza sky }\nMF = 1;\n{ Set to -1 for left-handed coordinate system }\nRHS = 1;\n{ Default axis orientation (+Y == north) }\nrNx = 0; rNy = 0; rNz = -1;\nUx = 0; Uy = 1; Uz = 0;\n{ Compute oriented axis angles }\ninc_dz = -Dx*rNx-Dy*rNy-Dz*rNz;\ninc_rx = -RHS*(Dx*(Uy*rNz-Uz*rNy) + Dy*(Uz*rNx-Ux*rNz) +\nDz*(Ux*rNy-Uy*rNx));\ninc_ry = Dx*Ux+Dy*Uy+Dz*Uz + inc_dz*(rNx*Ux+rNy*Uy+rNz*Uz);\n\n\nr_alt = Asin(inc_dz);\nr_azi = Atan2(inc_rx,inc_ry);\n\n\nalpha = 90/(MF*7 + .5); { Separation between rows in degrees }\n{ Number of patches per row }\ntnaz(r) : select(r, 30, 30, 24, 24, 18, 12, 6);\nrnaz(r) = if(r-(7*MF-.5), 1, MF*tnaz(floor((r+.5)/MF) + 1));\n\n\nraccum(r) = if(r-.5, rnaz(r-1) + raccum(r-1), 0);\n\n\nr_row = floor(r_alt/alpha);\n\n\nr_inc = 360/rnaz(r_row);\n\n\nr_azn = if(359.9999-.5*r_inc - r_azi, floor((r_azi +.5*r_inc)/r_inc), 0);\n\n\n{ Final bin value, -1 for \"ground\" }\nrbin = if (r_alt, raccum(r_row) + r_azn, -1);\n\n\nNrbins = raccum(7*MF+1); { total number of bins }\n\n\n\n\nrad = select(rbin,\n0.8778734094,\n        0.3797278557,\n        ..... one value per patch.\n        ..... Paste the vector generated on step 1 here\n);\n\n\n\n\n2015-12-04 11:31 GMT-03:00 ascendilex | Wouter Beck <\nwouter.beck at ascendilex.nl>:\n___\n<sup>Automatically generated content from [radiance mailing-list](https://radiance-online.org/pipermail/radiance-general/2015-December/011395.html).</sup>", "attachments": [], "created_by_name": "Germ\u00e1n Molina Larrain", "created_at": "December 04, 2015 at 07:20AM", "created_by": "Germ\u00e1n_Molina_Larrain", "parent_id": "radiance-general_011393", "id": "radiance-general_011395"}