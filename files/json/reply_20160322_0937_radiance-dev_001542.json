{"body": "This is getting good...\n\n\nOn 3/22/16, 10:02 AM, \"Gregory J. Ward\" <gregoryjward at gmail.com> wrote:\n\n\n>\n>Thinking on it some more, the main issue I have with Python is probably\n>the object-oriented structure, which moves it even further from a\n>command-line interpreter.  For me, the main benefit of using a scripting\n>language is that it is close to the command-line, which is where Radiance\n>(mostly) lives.  If you introduce too much structure, you're getting back\n>to something resembling a C program, and you may as well just write it\n>that way, instead.\n>\n>Perl looks a lot like traditional interpreter shells with the added\n>benefit of more useful built-in commands and expression evaluation.  You\n>can open a Perl script and read through it like you're reading a sequence\n>of commands.  User-defined functions have a bare-bones call structure and\n>don't have to be defined before they're used, so they don't interrupt the\n>flow as you read through the code.  Scripting languages need to be easy\n>to write and easy to read to be useful in my opinion.  They don't have to\n>be beautiful.\n>\n>Also, relying heavily on add-on libraries comes at a cost, which is\n>expanded vocabulary one must learn.  We get by in Perl with just one\n>library for making temp files, I think, and that was added to avoid some\n>of the system incompatibilities with Windows and is only called in a\n>couple of places.\n\n\n\n\nEh, I respectfully disagree, here. Languages like Python and Ruby are\nmaking it easy for meatheads like me to write functional cross-platform\nprograms that can leverage Radiance tools well, and offer users niceties\nlike command line help, threading, queuing, etc. One could write these\nwith minimal library support and blow off making functions where they make\nsense and leave one with a very linear, readable (and maintainable)\nprogram. On the other hand, wrapping a few redundant bits into a function\nhere and there makes it cleaner, easier to maintain, and IMO does not come\nanywhere close to the price of admission of writing the same shit in C or\nC++.(!)\n\n\n\n\n\n\n>Well, we may need to devise some tests to be sure this is still a\n>problem, but in the past, Windows would deliver binary files in 128-byte\n>chunks, meaning that the last chunk might have garbage at the end of it\n>that was not actually produced by the program that sent it.  So long as\n>the receiving program knows exactly how much data to expect, which is\n>frequently the case, there is no problem.  However, if the receiving\n>program is counting bytes to see how much data it gets (like rcalc,\n>total, etc.) then it screws up the results, which is why we've been\n>sticking with ASCII data in Windows despite the horrendous overhead\n>translating between ASCII and IEEE floating-point.\n\n\n\n\nThis was still a problem last year when I was writing the\nRadiance-OpenStudio stuff, and is a major roadblock for doing large scale\nanalysis with Radiance on Windows, I'm finding. =(\n___\n<sup>Automatically generated content from [radiance mailing-list](https://radiance-online.org/pipermail/radiance-dev/2016-March/001542.html).</sup>", "attachments": [], "created_by_name": "Rob Guglielmetti", "created_at": "March 22, 2016 at 09:37AM", "created_by": "Rob_Guglielmetti", "parent_id": "radiance-dev_001529", "id": "radiance-dev_001542"}