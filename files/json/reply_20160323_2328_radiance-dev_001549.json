{"body": ">>  It may or may not be worth to convert\n>> them, and in some cases the Python version may actually become a\n>> literal translation without any added structure.\n> \n> OK, I suppose I would have to see an example of that, preferably\n> something that wasn't organized around a class.  One of the things I\n> have always disliked about C++ is how you have to dig around in the\n> headers to figure out what the heck the code is doing.  Python at\n> least keeps it together, but it's still a mess in the sense that the\n> code layout has little to do with control flow.  It's an extra hurdle\n> to understanding I could do without.\n\n\nThis is the straight and complete Python translation of the original\nrlux.csh (inheriting most of its usability and portability problems):\n\n\n\n\nimport os, sys\nif len(sys.argv) < 2:\n     print(\"Usage: $0 [rtrace args] octree\")\nos.system(\"rtrace -i+ -dv- -h- -x 1 %s | rcalc -e \n'$1=47.4*$1+120*$2+11.6*$3' -u\" % ' '.join(sys.argv[1:]))\n\n\n\n\nThe boilerplate I added around that is simply there for user\nfriendlyness, and the use of direct process management for platform\nindependence. With any script as popular as rlux, we *should* add\nthose things.\n\n\n\n\n> There's still the issue of all the supporting libraries, their many\n> classes and associated methods.\n\n\nI don't quite see why that is supposed to be a problem.\n\n\nActually, I think you've got this one exactly backwards.\nUsing modules from Python's standard library does not add\ndependencies, it reduces them! Those modules are very well documented,\nand anyone working with Python will be familiar with them.\n\n\nI think this is a bit different with Perl, where many popular modules\ncome from third party sources, and may or may not be present in a\ngiven installation.\n\n\nYou're not refusing to use something like <stdio.h> \"because of its\nmany functions\" either, are you?\n\n\n\n\n>> This ease of maintenance is also one of the reasons why those things\n>> should rather *not* be converted to C. There's simply no need to do \n>> that,\n>> as long as we can delegate the number crunching to other tools.\n\n\n> However, I don't see how Python is less work\n> than Perl given the examples I've seen.  Why not Ruby?  Why not any of\n> the other myriad languages out there?  You have your favorite; I have\n> none.  I simply went with something that was familiar and supported,\n> and don't feel like changing canoes midstream as the expression goes.\n\n\nSome years ago I would have argued solely with Pythons practical\nmerits, and its \"batteries included\" approach bringing such a complete\nand useful standard library. It used to be my \"secret weapon\", giving\nme a significant productivity advantage.\n\n\nToday, another added benefit is the large pool of people who know how\nto work with it (probably larger than Perl and Ruby together).\nRuby has many similarities with Python (not sure about its library), but\nin comparison it's still a niche language. Without Ruby-on-rails it \nmight\nstill be largely unknown.\n\n\n\n\n>   Your rlux.py ended\n> up being a bit more complex than its C-shell progenitor...\n> As for\n\n\nThat added \"complexity\" has little to do with the fact that it's\nwritten in Python (apart from not really being very complex).\n\n\n\n\n> ugliness, I don't really see the differences you do.  I have employed\n> languages like TCL, which I do consider write-only (to use Randoph's\n> term), but Perl is OK for me.\n\n\nVery few people will be able to make that last claim. And if you\nmanage to avoid Perls many syntactical and semantical pitfalls, then\nyou are truly a rare exception. For most people, Perl is just an\naccident waiting to happen.\n\n\n\n\n> I do find Perl easy to read compared to Python, mostly because I don't\n> have to jump around the class methods or read up on the add-on\n> libraries.  There are plenty of functions in Perl, no doubt about\n> that, but they aren't such a growing concern.\n\n\nYou're mixing up choice of language with choice of design method here.\n\n\nPerl also offers object oriented possibilities nowadays, even if by\nfar not as simple and elegant. Those features just don't seem to be as\npopular with the target audience.\n\n\n\n\n> I don't own a Windows box, so it's difficult for me to produce test\n> cases.  I only hear complaints from people about certain commands not\n> behaving with binary data on Windows, even when it doesn't go into an\n> intermediate file.  In other words, piping the binary output of one\n> command into another still screws up.  Does Windows create a temporary\n> file when it does this?  Maybe if it's on a FAT filesystem (as\n> Randolph mentioned), this is the source of the problem.  It would be\n> nice to track this down.  Although I don't have a ready solution, it\n> would be good to at least determine the parameters of the problem.\n> (Radiance's binary files are immune: octrees, HDR pictures, triangle\n> meshes, even binary matrix data -- it's just the raw IEEE floats &\n> doubles that usually mess up.)\n\n\nI've searched for similar complaints online. In the few instances I've\nfound, it usually was because a terminating null byte wasn't written\nto the receiving buffer for some reason. The purportedly received\ngarbage data was then simply the previous random contents of that\nbuffer. That may or may not be the cause here as well.\n\n\nIf there really was an inherent problem with using pipes on Windows,\nthen I'm sure I would have found a lot more information about it.\n\n\nCheers\n-schorsch\n\n\n\n\nGeorg Mischler  --  simulations developer  --  schorsch at schorsch com\n+schorsch.com+  --  lighting design tools  --  http://www.schorsch.com/\n___\n<sup>Automatically generated content from [radiance mailing-list](https://radiance-online.org/pipermail/radiance-dev/2016-March/001549.html).</sup>", "attachments": [], "created_by_name": "Georg Mischler", "created_at": "March 23, 2016 at 11:28PM", "created_by": "Georg_Mischler", "parent_id": "radiance-dev_001529", "id": "radiance-dev_001549"}