{"body": "Am 2016-03-24 17:58, schrieb Gregory J. Ward:\n>   Does rlux even work under Windows?  I suppose it\n> does, or you wouldn't bother.  Also, where does this program exit?\n> How does it return an error if it doesn't get at least two arguments?\n> Shouldn't there be a call to os.exit(1) after the print call?  Why\n> isn't print() os.print() or sys.print()?  These things seem mysterious\n> to me in the land of the \"language that doesn't get in they way.\"  The\n> mixture of straight function calls, method calls on class names, and\n> calls on null objects like ''.doSomethingWithString() seems eccentric,\n> or at the least, inconsistent.\n\n\nThe \"big\" version of rlux.py runs on *any* platform supporting both\nRadiance and Python. The \"small\" one would require some fiddling with\nquotes to run on Windows, as long as there are no spaces involved.\n\n\nPython programs can exit in three different ways (quite similar to\nPerl, I think):\n  By running off the bottom without error (exit value 0)\n  By the builtin function exit(n)/quit(n) (with the given exit value)\n  Via an uncaught exception (exit value 1)\nThat just reminds me that I probably should exit with a no-zero value\nat the very bottom when catching the \"Error\" exception.\n\n\nAnd a closely related bug you correctly detected in my quick-and-dirty\ntranslation: Next to printing the usage message, it should indeed\nexit() with a non-zero value as well.\n\n\nOne of the purposes of modules is to unclutter the local namespace.\nHowever, there's still a number of very frequently used objects and\nfunctions directly accessible from any context. Those include\n   the system exceptions\n   the type objects (which also serve as conversion functions)\n   other type conversion functions that aren't types themselfes\n   quit() and exit() (really the same thing)\n   print()\n   a smallish number of other very elementary functions\nPart of that selection is necessarily arbitrary (design choice), and\nhas been reduced quite a bit over the evolution of the language.\nThe print function is global because it is probably one of the most\nused functions of all. In earlyer versions of Python it actually used\nto be a language keyword instead of a function.\n\n\nSomething like ''.split() or ''.join() is absolutely consistent with\nthe general object model, and handled pretty much the same in all\nobject oriented languages. It would rather be excentric to still\ntreat a string as an \"array of char\" in this context.\n\n\nThe use of qualified names for functions and methods serves to keep\nnamespaces seperate, in oder to avoid confusion. I understand that it\nmay not be obvious to you right now whether you see a function call in\na module, or a method call in an object instance (I don't think I'm\nusing any class methods in my code). But that will become clearer each\ntime you look at it.\n\n\n\n\n> My main concern is just the add-on nature of the libraries, and that\n> there can be too many to choose from.  Having basic facilities that\n> everyone uses establishes conventions that make it easier to read\n> other people's code.  So long as everyone chooses the same library to\n> make the same calls, and those calls don't change with new versions of\n> the libraries or of Python, then I don't have a problem with it.  It's\n> not that I distrust libraries per se, just \"extensionitis.\"  Seeing\n> things like:\n> \n> import os\n> import sys\n> import math\n> import tempfile\n> import argparse\n> import subprocess\n> \n> at the top of a module is a bit scary -- it means I need to be\n> familiar with these classes to understand the code.  It's just more\n> work.  I prefer to avoid unnecessary work.\n\n\nThat block may look impressive (I could have written it on one line,\nand you might have hardly noticed it). But the actual modules are\nvery common and rather obvious.\n\n\n\n\nThe documentation describes the most often used two modules as:\n   os - Miscellaneous operating system interfaces\n   sys - System-specific parameters and functions\n\n\nYou need \"math\" as soon as you want to do calculations beyond the basic\noperators and min()/max().\n\n\n\"Tempfile\" knows where the standard temp directories on every platforma\nare, and helps to prevent tampering. I know that the latter is not\nreally critical for Radiance, but it's just good programming practise.\n\n\n\"Argparse\" has an obvious name. Don't get fooled by the visually massive\nappearance of the related code blocks, that is only because they\ninclude all the text strings for the usage help output.\n\n\nThe \"subprocess\" module may be the least trivial of the lot, but it\nsimplifies things by encapsulating platform differences. And I've\nagain encapsulated its use in pyradlib/pyrad_proc. In the actual\nscripts, we only need it for the constant subprocess.PIPE.\nWe could actually offer that for import through pyrad_proc, to make\nit more obvious what it's used for.\n\n\n\n\nThose are all very good questions that show your increasig grasp of\nPython. All hope is not lost... ;)\nAn outside view is also quite helpful in finding the bugs hiding in\nsome of my own blind spots.\n\n\n\n\n>> Perl also offers object oriented possibilities nowadays, even if by\n>> far not as simple and elegant. Those features just don't seem to be as\n>> popular with the target audience.\n> \n> I suppose it's what you're used to.  As I said earlier, the issue with\n> libraries is mostly about vocabulary and what you need to know that\n> isn't right before you.  To me, writing a class to do something that\n> should be straightforward doesn't make sense.  I might even argue that\n> writing a class where you only expect to create a single object in\n> that class also doesn't make sense, unless you plan to share the class\n> with other classes or modules.\n\n\nPeople have built whole life philosophies around that question...\nIn my case, after working with object oriented methods for so many\nyears, it has just become second nature to start with a class.\nExperience shows that as things grow, they tend to turn into a class\nanyway, so I'm usually saving on one of the refactoring stages.\n\n\nWhen converting those scripts, I chose to use the same pattern for all\nof them for consistency. I was fully aware that I was adding around 90%\nof boilerplate to rlux.py, hence the comment at the top of the file.\n\n\nBut we also need to keep in mind, that when we start distributing\nthose things as exe files on Windows, those users may not want to go\nto look up the sources on radiance-online just to see how the script\nis invoked correctly. So the script itself really needs to give them\ngood diagnostics and usage instructions. And in the extreme case of\naround three lines of actual functionality, that will lead to this\nseemingly absurd ratio of content to packaging.\n\n\nBtw.: That doesn't mean that the original csh scripts need to go away!\nThey may serve as a reference implementation verified by you, that we\ncan use to compare the translations against. As long as you haven't\nfamiliarized yourself with Python enough to check the more complex\nexamples directly, they can happily live next to each other.\n\n\n\n\nCheers\n-schorsch\n\n\n\n\nGeorg Mischler  --  simulations developer  --  schorsch at schorsch com\n+schorsch.com+  --  lighting design tools  --  http://www.schorsch.com/\n___\n<sup>Automatically generated content from [radiance mailing-list](https://radiance-online.org/pipermail/radiance-dev/2016-March/001557.html).</sup>", "attachments": [], "created_by_name": "Georg Mischler", "created_at": "March 25, 2016 at 06:24AM", "created_by": "Georg_Mischler", "parent_id": "radiance-dev_001529", "id": "radiance-dev_001557"}