{"body": "Am 2016-03-25 15:35, schrieb Georg Mischler:\n> Moving this to a seperate thread.\n> \n> \n> The sequence below consistently gives me 703 on Vista, with the only\n> difference that the DOS box asks for double quotes.\n> \n> But...\n> \n> turning up n to values beyond 2000, the MSC binary of rcalc begins to\n> write(!) some bytes less(!) to stdout. Which obviously falsifies the\n> result of the chain.\n> \n> Interesingly, the NREL binary doesn't do that.\n> Rob mentioned using gcc, so there seems to be a disagreement between\n> the two compilers as to the semantics of writing to stdout on program\n> termination.\n> \n> Going to have some discussion with the debugger on this one.\n> I'd only be too happy if a simple flush() would solve the problem...\n> \n> Ah, and first I should probably create a few test cases to cover this\n> kind of bug.\n> \n> \nround two:\n\n\nI've detected the problem by redirecting the output of rcalc\ninto a file, which ends up too small.\nIt always happens when running in bash.\nIt currently gives the correct output about one time out of\nfour running in cmd.exe.\nWhen reading from a file instead of through a pipe from cnt,\nthe output is always correct.\nAdding a fflush() doesn't change anyhting, as mentioned the\nexit() will do that anyway.\nThere's no problem when feeding the same data through\ncall_one() from pyradlib.\nPassing in the output of cnt through call_two() currently runs\ninto a deadlock that I can't quite explain.\n\n\nIt's getting more and more mysterious...\n\n\n-schorsch\n\n\n\n\n> Cheers\n> -schorsch\n> \n> \n>>> I've searched for similar complaints online. In the few instances \n>>> I've\n>>> found, it usually was because a terminating null byte wasn't written\n>>> to the receiving buffer for some reason. The purportedly received\n>>> garbage data was then simply the previous random contents of that\n>>> buffer. That may or may not be the cause here as well.\n>>> \n>>> If there really was an inherent problem with using pipes on Windows,\n>>> then I'm sure I would have found a lot more information about it.\n>> \n>> Well, in our case, it's not about null bytes not being sent -- it's\n>> about knowing exactly when we've reached end-of-data, which we expect\n>> the system to tell us in some cases.  Radiance's binary formats for\n>> octrees, ambient files, pictures, etc., we know when we've reached EOD\n>> regardless because the file header tells us how much to expect.\n>> However, when we're sending binary streams of floats to rcalc, which\n>> is simply operating on them and counting on the OS to stop sending\n>> data when it's out of data, we run into trouble if the OS doesn't tell\n>> us exactly when the party is over.\n>> \n>> I suppose a simple test would be something like:\n>> \n>> \tcnt 37 | rcalc -of -e '$1=recno' | total -if\n>> \n>> This should give us a value of 703, or n*(n+1)/2 for any n (i.e.,\n>> 37*(37+1)/2==703).  We could try running the above on a Windows box\n>> with a FAT or ExFAT filesystem to determine if this is a problem or\n>> not.  We should probably try it with some large numbers as well, being\n>> aware that we end on a 128-byte boundary when n is a multiple of 32.\n>> \n>> We can also try it while writing with an intermediate file between\n>> rcalc and total, to see if that makes any difference.\n\n\n\n\nGeorg Mischler  --  simulations developer  --  schorsch at schorsch com\n+schorsch.com+  --  lighting design tools  --  http://www.schorsch.com/\n___\n<sup>Automatically generated content from [radiance mailing-list](https://radiance-online.org/pipermail/radiance-dev/2016-March/001564.html).</sup>", "attachments": [], "created_by_name": "Georg Mischler", "created_at": "March 25, 2016 at 12:19PM", "created_by": "Georg_Mischler", "parent_id": "radiance-dev_001558", "id": "radiance-dev_001564"}