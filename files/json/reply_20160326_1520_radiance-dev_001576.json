{"body": "It looks like we're dealing with a broken fgets() included\nwith Visual Studio 2015 Community edition.\n\n\nWhen a newline character falls exactly to the end of the\npipe buffer, it will be ignored. This means that instead of\n\"\\t1328\\n\" the received string will be \"\\t1328\\t1329\\n\".\nAny time that happens, nrecs is only incremented once for\ntwo actual input values, which accounts for the lower nuber\nof output values in the end.\n\n\nGuess I'll have to try if our own fgetline() has better success.\n\n\nBut again, this is probably not the \"garbage date from binary\npipe\" problem that we were previously discussing. We should still\nlook for test cases to identify that one.\n\n\nCheers\n-schorsch\n\n\n\n\n\n\nAm 2016-03-25 15:35, schrieb Georg Mischler:\n> Moving this to a seperate thread.\n> \n> \n> The sequence below consistently gives me 703 on Vista, with the only\n> difference that the DOS box asks for double quotes.\n> \n> But...\n> \n> turning up n to values beyond 2000, the MSC binary of rcalc begins to\n> write(!) some bytes less(!) to stdout. Which obviously falsifies the\n> result of the chain.\n> \n> Interesingly, the NREL binary doesn't do that.\n> Rob mentioned using gcc, so there seems to be a disagreement between\n> the two compilers as to the semantics of writing to stdout on program\n> termination.\n> \n> Going to have some discussion with the debugger on this one.\n> I'd only be too happy if a simple flush() would solve the problem...\n> \n> Ah, and first I should probably create a few test cases to cover this\n> kind of bug.\n> \n> \n> Cheers\n> -schorsch\n> \n> \n>>> I've searched for similar complaints online. In the few instances \n>>> I've\n>>> found, it usually was because a terminating null byte wasn't written\n>>> to the receiving buffer for some reason. The purportedly received\n>>> garbage data was then simply the previous random contents of that\n>>> buffer. That may or may not be the cause here as well.\n>>> \n>>> If there really was an inherent problem with using pipes on Windows,\n>>> then I'm sure I would have found a lot more information about it.\n>> \n>> Well, in our case, it's not about null bytes not being sent -- it's\n>> about knowing exactly when we've reached end-of-data, which we expect\n>> the system to tell us in some cases.  Radiance's binary formats for\n>> octrees, ambient files, pictures, etc., we know when we've reached EOD\n>> regardless because the file header tells us how much to expect.\n>> However, when we're sending binary streams of floats to rcalc, which\n>> is simply operating on them and counting on the OS to stop sending\n>> data when it's out of data, we run into trouble if the OS doesn't tell\n>> us exactly when the party is over.\n>> \n>> I suppose a simple test would be something like:\n>> \n>> \tcnt 37 | rcalc -of -e '$1=recno' | total -if\n>> \n>> This should give us a value of 703, or n*(n+1)/2 for any n (i.e.,\n>> 37*(37+1)/2==703).  We could try running the above on a Windows box\n>> with a FAT or ExFAT filesystem to determine if this is a problem or\n>> not.  We should probably try it with some large numbers as well, being\n>> aware that we end on a 128-byte boundary when n is a multiple of 32.\n>> \n>> We can also try it while writing with an intermediate file between\n>> rcalc and total, to see if that makes any difference.\n\n\n\n\nGeorg Mischler  --  simulations developer  --  schorsch at schorsch com\n+schorsch.com+  --  lighting design tools  --  http://www.schorsch.com/\n___\n<sup>Automatically generated content from [radiance mailing-list](https://radiance-online.org/pipermail/radiance-dev/2016-March/001576.html).</sup>", "attachments": [], "created_by_name": "Georg Mischler", "created_at": "March 26, 2016 at 03:20PM", "created_by": "Georg_Mischler", "parent_id": "radiance-dev_001558", "id": "radiance-dev_001576"}