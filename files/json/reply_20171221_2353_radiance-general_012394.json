{"body": "Hi Antoine,\n\n\nit is always difficult to give a general answer when it comes to \nRadiance, since everything depends on the parameters you chose. Still \nI'll try to give some hints.\n\n\n> First I did /rtrace/ simulations for \"point in time\" analysis with a \n> basic set of parameter that DAYSIM uses.\nIt would be good if you note down at least all parameters starting with \n-a. These control the indirect-diffuse calculation, which takes most of \nyour rendering times. So you should look out for -ab (number of ambient \n\"bounces\"), -ad (number of directions that are sampled at each bounce), \n-aa and -ar (defining at which points the illuminance on the surfaces \nwill be computed, otherwise a quick interpolation happens in the ambient \ncache).\n> After I wanted to do Climate Based simulations with the matrix method \n> of Daylight Coefficients. So I used /rfluxmtx./\n> I'm wondering why I need to use a different set of parameters for this \n> two kind of simulations, especially for -ad and -lw.\nThe main difference is that each pixel value is computed independently \nfrom all others with rfluxmtx (and rcontrib), while rtrace with -aa > \n0.0 re-uses a lot of data between pixels. This is what I meant by \n\"ambient cache\" above. The - computationally expensive - ambient \ncalculation can, in most scenes, happen at a lower resolution than the \ndirect and specular calculation. Therefore, the illuminance on the \nsurfaces is not computed pixel by pixel, but for a coarse set of points \n(initial defined by -ar, then refined according to the required accuracy \n-aa). If the parameters are too low, you will see typical artefacts such \nas splotchy images (like soft, cloudy patterns in areas illuminated by \ndiffuse light).\n\n\nWith rfluxmtx and rcontrib, this mechanism has to be disabled (they set \n-aa 0), since the algorithm cannot know the illuminance gradient from \nthe contribution coefficients (the light sources are unknown at this \npoint). Without the ambient cache, Radiance will compute the illuminance \n(coefficients) each time a ray hits a surface. Making the whole \nrendering much slower. A typical artefact of this pixel-by-pixel \napproach is pixel noise [1]. To reduce it, you must ensure that a lot (a \nlot!) of rays are send out at each ambient bounce. Therefore, you will \ntypically set high -ad, e.g. 16384, and low -lw, which should be just \nsmaller than 1/ad (e.g. 1/16384 leading to -lw 6e-5).\n> I also noticed that rfluxmtx is much faster than rtrace (even with \n> Reinhart sky subdivision -m4) but I do not understand why.\nUnfortunately, most of us experience the very opposite, rtrace being \nfaster due to the ambient cache. However, again, it depends on the \nparameters, and on the scene. The use of the ambient cache can be \ninefficient e.g. for very complex scenes [1]. Since you took your rtrace \nparameters from Daysim, these might be more strict than the default \nrfluxmtx parameters. To compare, you would call both programs with the \nsame parameters (just -aa, -ar would be ignored in rfluxmtx).\n\n\nCheers,\nLars.\n\n\n[1] See Mark's page for a test of parameters to use with very detailed \nscenes and no ambient cache: \nhttp://markjstock.org/radmisc/aa0_ps1_test/final.html\n___\n<sup>Automatically generated content from [radiance mailing-list](https://radiance-online.org/pipermail/radiance-general/2017-December/012394.html).</sup>", "attachments": [], "created_by_name": "Lars O. Grobe", "created_at": "December 21, 2017 at 11:53PM", "created_by": "Lars_O._Grobe", "parent_id": "radiance-general_012389", "id": "radiance-general_012394"}