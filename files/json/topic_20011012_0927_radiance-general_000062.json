{"topic": "Radiance-general digest, Vol 1 #22 - 2 msgs", "category": "radiance-general", "attachments": [], "created_by_name": "Greg Ward", "created_at": "October 12, 2001 at 09:27AM", "body": "This is a multi-part message in MIME format.\n--------------F2F6EFC25830270349AF3F12\nContent-Type: text/plain; charset=us-ascii\nContent-Transfer-Encoding: 7bit\n\n\nRon wrote:\n\n\nI would like to recover the surface normals of the surfaces visible in\nevery pixel of a Radiance scene.  In other words, I want to trace the\ninitial ray cast for each pixel, and find the surface normal of the first\nsurface that ray hits.  I figured out that I could do this using rtrace\n-on, if I feed rtrace the rays corresponding to each pixel in my\nimage.  Is there an easy way to compute all of these rays automatically\nusing an existing Radiance program, or will I need to write a special .cal\nfile for rcalc?  I have the feeling that some Radiance gurus could\naccomplish this task in one or two lines.\n\n\n\n\nThere are two solutions to this problem.  As you say, it is a very handy\nthing to be able to do, so I wrote a C program to do just that.  It is\npart of the Unix distribution I've been working on and plan to release\nas soon as I figure out how.  In the meantime, I am attaching the C file\nand manual page to this message, which are fairly short.  The nice thing\nabout this solution is that it will work with any Radiance view type,\nand will generate the exact rays corresponding to the center of each\npixel.  (If you want an absolute guarantee that these correspond to\nthe pixels sampled with rpict, you will need to set the -pj 0 option\nin your rendering.)\n\n\nThe second solution is to apply the following .cal script with rcalc,\nwhich works only for perspective views, found in ray/lib/lib:\n\n\n{\n\tproj.cal - calculate image projection vector\n}\n\t\t\t\t{ View Point }\nVPx = 0; VPy = 0; VPz = 0;\n\t\t\t\t{ View Up }\nVUx = 0; VUy = 0; VUz = 1;\n\t\t\t\t{ View Direction }\nVDx = 0; VDy = 1; VDz = 0;\n\t\t\t\t{ View Horizontal and Vertical angles }\nVH = 45; VV = 45;\n\t\t\t\t{ X and Y resolution }\nX = 512; Y = 512;\n\t\t\t\t{ Projected Direction (computed) }\nPDx = NVDx + h*IHx + v*IVx;\nPDy = NVDy + h*IHy + v*IVy;\nPDz = NVDz + h*IHz + v*IVz;\nh = x - (X-1)/2; v = y - (Y-1)/2;\n\t\t\t\t{ Normalized View Direction }\nNVDx = VDx/VDl; NVDy = VDy/VDl; NVDz = VDz/VDl;\nVDl = sqrt(VDx*VDx + VDy*VDy + VDz*VDz);\n\t\t\t\t{ Increment Horizontal }\nIHx = IHF*NTIHx; IHy = IHF*NTIHy; IHz = IHF*NTIHz;\nNTIHx = TIHx/TIHl; NTIHy = TIHy/TIHl; NTIHz = TIHz/TIHl;\nTIHx = VDy*VUz-VDz*VUy; TIHy = VDz*VUx-VDx*VUz; TIHz = VDx*VUy-VDy*VUx;\nTIHl = sqrt(TIHx*TIHx + TIHy*TIHy + TIHz*TIHz);\nIHF = 2*tan(PI/180/2*VH)/X;\n\t\t\t\t{ Increment Vertical }\nIVx = IVF*(NTIHy*NVDz-NTIHz*NVDy);\nIVy = IVF*(NTIHz*NVDx-NTIHx*NVDz);\nIVz = IVF*(NTIHx*NVDy-NTIHy*NVDx);\nIVF = 2*tan(PI/180/2*VV)/Y;\n\n\nPI = 3.14159265358979323846\n\n\n\n\nThe horizontal and vertical increment vectors get added to a unit\ndirection vector to get the final view direction computed in PDx,\nPDy, and PDz.  The view point (origin) remains the same for a\nperspective view.  An example application of the above file with\na specific view origin, direction, and angle might be:\n\n\ncnt 512 512 | rcalc -f proj.cal -e 'VPx=15.3;VPy=10.1;VPz=-3.3;' \\\n\t-e 'VDx=.394;VDy=-.731;VDz=-.053;' \\\n\t-e 'VH=30;VV=30;' -e '$1=VPx;$2=VPy;$3=VPz;' \\\n\t-e '$4=PDx;$5=PDy;$6=PDz;' | rtrace [rtrace options]\n\n\nHope this helps.\n-Greg\n--------------F2F6EFC25830270349AF3F12\nContent-Type: text/plain; charset=us-ascii; x-mac-type=\"54455854\"; x-mac-creator=\"522A6368\";\n name=\"vwrays.1\"\nContent-Transfer-Encoding: 7bit\nContent-Description: Unknown Document\nContent-Disposition: inline;\n filename=\"vwrays.1\"\n\n\n.\\\" SCCSid \"@(#)vwrays.1 3.5 1/15/99 SGI\"\n.TH VWRAYS 1 1/15/99 RADIANCE\n.SH NAME\nvwrays - compute rays for a given picture or view\n.SH SYNOPSIS\n.B vwrays\n.B \"[ -i -f{a|f|d} | -d ]\"\n{\n.B \"view opts ..\"\n|\n.B picture\n.B [zbuf]\n}\n.SH DESCRIPTION\n.I Vwrays\ntakes a picture or view specification and computes the ray origin and\ndirection corresponding to each pixel in the image.\nThis information may then be passed to\n.I rtrace(1)\nto perform other calculations.\nIf a given pixel has no corresponding ray (because it is outside the\nlegal view boundaries), then six zero values are sent instead.\n.PP\nThe\n.I -i\noption may be used to specify desired pixel positions on the standard\ninput rather than generating all the pixels for a given view.\n.PP\nThe\n.I -f\noption may be used to set the record format to something other than the\ndefault ASCII.\nUsing raw float or double records for example can reduce the time\nrequirements of transferring and interpreting information in\n.I rtrace.\n.PP\nView options may be any combination of standard view parameters described\nin the\n.I rpict(1)\nmanual page, including input from a view file with the\n.I \\-vf\noption.\nAdditionally, the target X and Y dimensions may be specified with\n.I -x\nand\n.I -y\noptions, and the pixel aspect ratio may be given with\n.I -p.\nThe default dimensions are 512x512, with a pixel aspect ratio of 1.0.\nJust as in\n.I rpict,\nthe X or the Y dimension will be reduced if necessary\nto best match the specified pixel\naspect ratio, unless this ratio is set to zero.\n.PP\nIf the\n.I -d\noption is given, then\n.I vwrays\njust prints the computed image dimensions, which are based on the view\naspect and the pixel aspect ratio just described.\nThe\n.I -ld\nswitch will also be printed, with\n.I -ld+\nif the view file has an aft clipping plane, and\n.I -ld-\notherwise.\nThis is useful for passing options to the\n.I rtrace\ncommand line.\n(See below.)\n.PP\nIf the view contains an aft clipping plane\n.I (-va\noption), then the magnitudes of the ray directions will\nequal the maximum distance for each pixel, which will be interpreted\ncorrectly by\n.I rtrace\nwith the\n.I -ld+\noption.\nNote that this option should not be given unless there is an aft\nclipping plane, since the ray direction vectors will be normalized\notherwise, which would produce a uniform clipping distance of 1.\n.PP\nIf a picture is given on the command line rather than a set of view options,\nthen the view and image dimensions are taken from the picture file, and\nthe reported ray origins and directions will exactly match the center of each\npixel in the picture.\n.PP\nIf a depth buffer file is given as well, then\n.I vwrays\ncomputes the intersection point of each pixel ray (equal to the ray origin\nplus the depth times the ray direction), and reports this instead of the\nray origin.\nThe reported ray direction will also be reversed.\nThe interpretation of this data is an image of origins and directions\nfor light rays leaving the scene surfaces to strike each pixel.\n.SH EXAMPLES\nTo compute the ray intersection points and returned directions corresponding\nto a picture and its depth buffer:\n.IP \"\" .2i\nvwrays scene_v2.pic scene_v2.zbf > scene_v2.pts\n.PP\nTo determine what the dimensions of a given view would be:\n.IP \"\" .2i\nvwrays -d -vf myview.vf -x 2048 -y 2048\n.PP\nTo generate a RADIANCE picture using\n.I rtrace\ninstead of\n.I rpict:\n.IP \"\" .2i\nvwrays -ff -vf view1.vf -x 1024 -y 1024 |\nrtrace `vwrays -d -vf view1.vf -x 1024 -y 1024` -ffc scene.oct > view1.pic\n.SH AUTHOR\nGreg Ward Larson\n.SH ACKNOWLEDGMENT\nThis work was supported by Silicon Graphics, Inc.\n.SH BUGS\nAlthough\n.I vwrays\ncan reproduce any pixel ordering (i.e., any image orientation) when given\na rendered picture, it will only produce standard scanline-ordered rays when \ngiven a set of view parameters.\n.SH \"SEE ALSO\"\nrcalc(1), rpict(1), rtrace(1)\n\n\n--------------F2F6EFC25830270349AF3F12\nContent-Type: text/plain; charset=us-ascii; x-mac-type=\"54455854\"; x-mac-creator=\"522A6368\";\n name=\"vwrays.c\"\nContent-Transfer-Encoding: 7bit\nContent-Description: Unknown Document\nContent-Disposition: inline;\n filename=\"vwrays.c\"\n\n\n/* Copyright (c) 1997 Silicon Graphics, Inc. */\n\n\n#ifndef lint\nstatic char SCCSid[] = \"@(#)vwrays.c 3.3 10/17/97 SGI\";\n#endif\n\n\n/*\n * Compute rays corresponding to a given picture or view.\n */\n\n\n\n\n#include \"standard.h\"\n\n\n#include \"view.h\"\n\n\n#include \"resolu.h\"\n\n\nextern int\tputf(), putd(), puta();\n\n\nint\t(*putr)() = puta;\n\n\nVIEW\tvw = STDVIEW;\n\n\nRESOLU\trs = {PIXSTANDARD, 512, 512};\n\n\ndouble\tpa = 1.;\n\n\nint\tzfd = -1;\n\n\nint\tfromstdin = 0;\n\n\nchar\t*progname;\n\n\n\n\nmain(argc, argv)\nint\targc;\nchar\t*argv[];\n{\n\tchar\t*err;\n\tint\trval, getdim = 0;\n\tregister int\ti;\n\n\n\tprogname = argv[0];\n\tif (argc < 2)\n\t\tgoto userr;\n\tfor (i = 1; i < argc && argv[i][0] == '-'; i++)\n\t\tswitch (argv[i][1]) {\n\t\tcase 'f':\t\t\t/* output format */\n\t\t\tswitch (argv[i][2]) {\n\t\t\tcase 'a':\t\t\t/* ASCII */\n\t\t\t\tputr = puta;\n\t\t\t\tbreak;\n\t\t\tcase 'f':\t\t\t/* float */\n\t\t\t\tputr = putf;\n\t\t\t\tbreak;\n\t\t\tcase 'd':\t\t\t/* double */\n\t\t\t\tputr = putd;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tgoto userr;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 'v':\t\t\t/* view file or option */\n\t\t\tif (argv[i][2] == 'f') {\n\t\t\t\trval = viewfile(argv[++i], &vw, NULL);\n\t\t\t\tif (rval <= 0) {\n\t\t\t\t\tfprintf(stderr,\n\t\t\t\t\t\t\"%s: no view in file\\n\",\n\t\t\t\t\t\t\targv[i]);\n\t\t\t\t\texit(1);\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\trval = getviewopt(&vw, argc-i, argv+i);\n\t\t\tif (rval < 0)\n\t\t\t\tgoto userr;\n\t\t\ti += rval;\n\t\t\tbreak;\n\t\tcase 'd':\t\t\t/* report dimensions only */\n\t\t\tgetdim++;\n\t\t\tbreak;\n\t\tcase 'x':\t\t\t/* x resolution */\n\t\t\trs.xr = atoi(argv[++i]);\n\t\t\tif (rs.xr <= 0) {\n\t\t\t\tfprintf(stderr, \"%s: bad x resolution\\n\",\n\t\t\t\t\t\tprogname);\n\t\t\t\texit(1);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 'y':\t\t\t/* y resolution */\n\t\t\trs.yr = atoi(argv[++i]);\n\t\t\tif (rs.yr <= 0) {\n\t\t\t\tfprintf(stderr, \"%s: bad y resolution\\n\",\n\t\t\t\t\t\tprogname);\n\t\t\t\texit(1);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 'p':\t\t\t/* pixel aspect ratio */\n\t\t\tpa = atof(argv[++i]);\n\t\t\tbreak;\n\t\tcase 'i':\t\t\t/* get pixels from stdin */\n\t\t\tfromstdin = 1;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tgoto userr;\n\t\t}\n\tif (i > argc | i+2 < argc)\n\t\tgoto userr;\n\tif (i < argc) {\n\t\trval = viewfile(argv[i], &vw, &rs);\n\t\tif (rval <= 0) {\n\t\t\tfprintf(stderr, \"%s: no view in picture\\n\", argv[i]);\n\t\t\texit(1);\n\t\t}\n\t\tif (i+1 < argc) {\n\t\t\tzfd = open(argv[i+1], O_RDONLY);\n\t\t\tif (zfd < 0) {\n\t\t\t\tfprintf(stderr,\n\t\t\t\t\t\"%s: cannot open depth buffer\\n\",\n\t\t\t\t\t\targv[i+1]);\n\t\t\t\texit(1);\n\t\t\t}\n\t\t}\n\t}\n\tif ((err = setview(&vw)) != NULL) {\n\t\tfprintf(stderr, \"%s: %s\\n\", progname, err);\n\t\texit(1);\n\t}\n\tif (i == argc)\n\t\tnormaspect(viewaspect(&vw), &pa, &rs.xr, &rs.yr);\n\tif (getdim) {\n\t\tprintf(\"-x %d -y %d -ld%c\\n\", rs.xr, rs.yr,\n\t\t\t\tvw.vaft > FTINY ? '+' : '-');\n\t\texit(0);\n\t}\n\tif (fromstdin)\n\t\tpix2rays(stdin);\n\telse\n\t\tputrays();\n\texit(0);\nuserr:\n\tfprintf(stderr,\n\t\"Usage: %s [ -i -f{a|f|d} | -d ] { view opts .. | picture [zbuf] }\\n\",\n\t\t\tprogname);\n\texit(1);\n}\n\n\n\n\npix2rays(FILE *fp)\n{\n\tstatic FVECT\trorg, rdir;\n\tfloat\tzval;\n\tdouble\tpx, py;\n\tint\tpp[2];\n\tdouble\td;\n\tregister int\ti;\n\n\n\twhile (fscanf(fp, \"%lf %lf\", &px, &py) == 2) {\n\t\tif (px < 0 || px >= rs.xr ||\n\t\t\t\tpy < 0 || py >= rs.yr) {\n\t\t\tfprintf(stderr,\n\t\t\t\t\"%s: (x,y) pair (%.0f,%.0f) out of range\\n\",\n\t\t\t\t\tpx, py);\n\t\t\texit(1);\n\t\t}\n\t\tif (zfd >= 0) {\n\t\t\tloc2pix(pp, &rs, px/rs.xr, py/rs.yr);\n\t\t\tif (lseek(zfd,\n\t\t\t\t(pp[1]*scanlen(&rs)+pp[0])*sizeof(float), 0)\n\t\t\t\t\t< 0 ||\n\t\t\t\t\tread(zfd, &zval, sizeof(float))\n\t\t\t\t\t< sizeof(float)) {\n\t\t\t\tfprintf(stderr, \"%s: depth buffer read error\\n\",\n\t\t\t\t\t\tprogname);\n\t\t\t\texit(1);\n\t\t\t}\n\t\t}\n\t\td = viewray(rorg, rdir, &vw, px/rs.xr, py/rs.yr);\n\t\tif (d < -FTINY)\n\t\t\trorg[0] = rorg[1] = rorg[2] =\n\t\t\trdir[0] = rdir[1] = rdir[2] = 0.;\n\t\telse if (zfd >= 0)\n\t\t\tfor (i = 0; i < 3; i++) {\n\t\t\t\trorg[i] += rdir[i]*zval;\n\t\t\t\trdir[i] = -rdir[i];\n\t\t\t}\n\t\telse if (d > FTINY) {\n\t\t\trdir[0] *= d; rdir[1] *= d; rdir[2] *= d;\n\t\t}\n\t\t(*putr)(rorg, rdir);\n\t}\n\tif (!feof(fp)) {\n\t\tfprintf(stderr, \"%s: expected px py on input\\n\", progname);\n\t\texit(1);\n\t}\n}\n\n\n\n\nputrays()\n{\n\tstatic FLOAT\tloc[2];\n\tstatic FVECT\trorg, rdir;\n\tfloat\t*zbuf;\n\tint\tsc;\n\tdouble\td;\n\tregister int\tsi, i;\n\n\n\tif (zfd >= 0) {\n\t\tzbuf = (float *)malloc(scanlen(&rs)*sizeof(float));\n\t\tif (zbuf == NULL) {\n\t\t\tfprintf(stderr, \"%s: not enough memory\\n\", progname);\n\t\t\texit(1);\n\t\t}\n\t}\n\tfor (sc = 0; sc < numscans(&rs); sc++) {\n\t\tif (zfd >= 0) {\n\t\t\tif (read(zfd, zbuf, scanlen(&rs)*sizeof(float)) <\n\t\t\t\t\tscanlen(&rs)*sizeof(float)) {\n\t\t\t\tfprintf(stderr, \"%s: depth buffer read error\\n\",\n\t\t\t\t\t\tprogname);\n\t\t\t\texit(1);\n\t\t\t}\n\t\t}\n\t\tfor (si = 0; si < scanlen(&rs); si++) {\n\t\t\tpix2loc(loc, &rs, si, sc);\n\t\t\td = viewray(rorg, rdir, &vw, loc[0], loc[1]);\n\t\t\tif (d < -FTINY)\n\t\t\t\trorg[0] = rorg[1] = rorg[2] =\n\t\t\t\trdir[0] = rdir[1] = rdir[2] = 0.;\n\t\t\telse if (zfd >= 0)\n\t\t\t\tfor (i = 0; i < 3; i++) {\n\t\t\t\t\trorg[i] += rdir[i]*zbuf[si];\n\t\t\t\t\trdir[i] = -rdir[i];\n\t\t\t\t}\n\t\t\telse if (d > FTINY) {\n\t\t\t\trdir[0] *= d; rdir[1] *= d; rdir[2] *= d;\n\t\t\t}\n\t\t\t(*putr)(rorg, rdir);\n\t\t}\n\t}\n\tif (zfd >= 0)\n\t\tfree((char *)zbuf);\n}\n\n\n\n\nputa(ro, rd)\t\t/* put out ray in ASCII format */\nFVECT\tro, rd;\n{\n\tprintf(\"%.5e %.5e %.5e %.5e %.5e %.5e\\n\",\n\t\t\tro[0], ro[1], ro[2],\n\t\t\trd[0], rd[1], rd[2]);\n}\n\n\n\n\nputf(ro, rd)\t\t/* put out ray in float format */\nFVECT\tro, rd;\n{\n\tfloat v[6];\n\n\n\tv[0] = ro[0]; v[1] = ro[1]; v[2] = ro[2];\n\tv[3] = rd[0]; v[4] = rd[1]; v[5] = rd[2];\n\tfwrite(v, sizeof(float), 6, stdout);\n}\n\n\n\n\nputd(ro, rd)\t\t/* put out ray in double format */\nFVECT\tro, rd;\n{\n\tdouble v[6];\n\n\n\tv[0] = ro[0]; v[1] = ro[1]; v[2] = ro[2];\n\tv[3] = rd[0]; v[4] = rd[1]; v[5] = rd[2];\n\tfwrite(v, sizeof(double), 6, stdout);\n}\n\n\n--------------F2F6EFC25830270349AF3F12--\n___\n<sup>Automatically generated content from [radiance mailing-list](https://radiance-online.org/pipermail/radiance-general/2001-October/000062.html).</sup>", "id": "radiance-general_000062", "created_by": "Greg_Ward"}