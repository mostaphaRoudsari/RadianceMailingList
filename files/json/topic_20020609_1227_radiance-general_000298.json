{"topic": "ANSI vs. C++", "category": "radiance-general", "attachments": [], "created_by_name": "Georg Mischler", "created_at": "June 09, 2002 at 12:27PM", "body": "*phew*, what have I started here?\nI really hope we're not scaring any non-developers away from this\ngeneral purpose list with such a highly technical discussion!\n\n\nIf ANSI C created portability problems at the time it was\nintroduced (I don't think it still does today, btw.) then\nC++ will be a true nightmare in comparison. Before switching\nan existing codebase over to C++ you need several *very* good\nreasons, and I can't personally think of even one good reason in\nthis case. I am really surprised that Greg reports about good\nporting experiences with C++, as pretty much everybody else I\ntalk to warns me about exactly the opposite. The most experienced\nC++ developers I know invariably call the language \"a bloody mess\".\n\n\nAs a more technically solid argument: Remember that you can\nalways call foreign C code from your C++ programs, but if you\nwant to call C++ from C, then the only way to do so is through\nshared libraries, which opens yet another can of worms in terms\nof portability and functional limitations. The performance issues\nwith a more complex language have already been mentioned. This is\nno surprise, as there has gone around 20 years of experience into\nC compiler technology, and only a fraction of that into any  C++\ncompiler. This alone would be alarming, even when ignoring that\nC++ is at least an order of magnitude more complex to compile,\nand the standard has been in flux until very recently.\n\n\nThere are much simpler ways to make Radiance more modular than it\ncurrently is, without throwing out all the work that has already\nbeen invested in it. ANSIfication will be a great step into that\ndirection, forcing all function prototypes into header files.\nAs a second step, if we then manage to encapsulate the global\nvariables of each functional unit into a struct that can get\npassed around as a pointer, then we might already have all the\nmodularity we need, without introducing anything that would\nprevent Greg from still recognizing his own programs.\n\n\nAs a principle, I'm a big fan of object oriented programming (90%\nof my own work is object oriented), but neither is C++ a good\nobject oriented language, nor do I think that object orientation\nwould be of any benefit for this specific task. The core\nimplementation of Radiance has to remain as simple as possible,\nand using ANSI C is one of the factors that will keep it simple.\nI really can't see how the introduction of \"mindbending\nabstractions\" would be of any benefit at this level.\n\n\nI do support the idea of relegating some parts of the system to\n\"legacy\" status. I guess this would only put a formal label on\nthose modules that haven't been touched for several years anyway.\nMaybe this label could simply result in putting them into a\nseperate and optional support package.\n\n\nIt could also be interesting to consider another implementation\nframework for all the helper programs circulating around the\nactual Radiance core. Some of the csh scripts have been rewritten\nin C for Windows, with limited flexibility and robustness. My\npersonal favourite language for this kind of task would be Python\n(with some parts already existing). Note that such a more\nportable reimplementation of individual small programs can be\ndone one by one, and there's no problem in keeping the old\nversions around as long as necessary.\n\n\nThe problem of platform specific code variations is actually\nindependent from the ANSI conversion. In part, the ANSI standard\nwas supposed to reduce those incompatiblities, but succeeded in\nthat point only to a certain degree. I have no experience with\nGNU autoconf myself, but maybe that would be a reasonable way to\neliminate the need to actually know which platform has what kind\nof quirks. The configure scripts generated by autoconf simply\ntest the target machine and set the right compile variables\nautomatically. Again, this will probably have to be a step by\nstep replacement effort, but I think it would be worth it in the\nlong run. In the end, the #ifdefs in the code won't be about\nspecific OSes anymore, but simply about feature variations in the\navailable APIs.\n\n\nThanks for mentioning the Windows issue! The code of Radiance for\nWindows includes some changes in the way how the stored ambient\nvalues are accessed, which apparently were written for a\ncompletely different platform. As far as I understand, those\nchanges are responsible for a large part of the performance\nimprovements that can be observed under Windows. I must admit\nthat I didn't find the time yet to have a look at the code of\n3R4, so I have no idea whether it already includes the same\nmodifications. If not, then it might be a good idea to keep them\naround during the merge, although that might make the task quite\na bit more involved.\n\n\nIgnoring this aspect, the merge of the core functionality will\nbe relatively straightforward. The Windows code base is not very\nclean (there are several conflicting compatiblity libraries in\nuse), so most of the result should probably be based on the unix\ncode. There are a number of details involving line endings in\ntext files and other differences between the systems where\nRadiance needs to be more tolerant in the input it accepts, but I\nhave already fixed most of those for the binaries included in\nRayfront. I don't expect any major obstacles in porting those\nfixes back to 3R4, especially after ANSIfication. The GUI based\nprograms are a different problem that needs to be tackled\nseperately.\n\n\n\n\n-schorsch\n\n\n\n\nGeorg Mischler  --  simulations developer  --  schorsch at schorsch.com\n+schorsch.com+  --  lighting design tools  --  http://www.schorsch.com/\n___\n<sup>Automatically generated content from [radiance mailing-list](https://radiance-online.org/pipermail/radiance-general/2002-June/000298.html).</sup>", "id": "radiance-general_000298", "created_by": "Georg_Mischler"}