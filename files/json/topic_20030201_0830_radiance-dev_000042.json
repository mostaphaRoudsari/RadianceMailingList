{"topic": "Before we give up on lock files...", "category": "radiance-dev", "attachments": [], "created_by_name": "Greg Ward", "created_at": "February 01, 2003 at 08:30AM", "body": "Schorch wrote:\n>\n> And you think sockets are nasty?\n>\n> One of the few things that I know about lockfiles is that they're\n> not exactly simple to get right.\n>\n> - What happens if the lockfile owner gets killed?\n>   Will the others be able to figure out that the lock file is\n>   stale and override it? Or will that require human intervention?\n>   I think that NFS locks get purged when the owner dies, so we\n>   might lose quite some convenience here.\n>\n> - What happens process b checks for the file after process a\n>   does, but before process a actually creates the new file?\n>\n> There's no way to make checking and creating an atomic operation,\n> so that this situation must be handled explicitly and gracefully.\n> In a big simulation, it may well be that a dozen processes are\n> competing for the lock file several times a second for hours or\n> even days. Race conditions *will* happen.\n\n\nThe open() call with the O_EXCL flag is supposed to be atomic with the \nfile system -- i.e., if the file exists, the call fails, so if \ncompeting processes compete in a race, only one can win.  If the open() \ncall fails, then our process moves on as if the lock file were there \nall along.  To avoid race problems, we use a random number of ambient \nvalues between checks, which will gradually increase each time a lock \ncheck fails.  This is the same method used to reduce packet collisions \non a network, and it works quite well at avoiding perpetual races.\n\n\nAs for processes that die unexpectedly in the middle of an ambient sync \noperation, we could either disregard this possibility as neither likely \nnor disasterous -- it would just untie all the processes so their \nvalues wouldn't get written out -- not a disaster.  Or, we could employ \nsome check on the file creation time and if a lock has been around more \nthan a certain period (a minute would be extremely generous), any of \nthe processes that's been failing to obtain it can remove it after \ntheir Nth failure.\n\n\nThe total code for the above procedure would not be much longer than \nwhat is currently in ambient.c, and wouldn't require any network \ntransactions, which I'd rather avoid.  There's no such code currently \nin Radiance, and it adds a whole set of dependencies I don't want to \ndeal with.\n\n\nHaving said that, I'm willing to go along with Schorsch's suggestion of \nimplementing multiple methods.  I'll go ahead and give this one a shot, \nand you guys can try yours as well if you like.\n\n\n-Greg\n___\n<sup>Automatically generated content from [radiance mailing-list](https://radiance-online.org/pipermail/radiance-dev/2003-February/000042.html).</sup>", "id": "radiance-dev_000042", "created_by": "Greg_Ward"}