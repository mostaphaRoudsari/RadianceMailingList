{"topic": "alias handling - the infernal internals", "category": "radiance-dev", "attachments": [], "created_by_name": "Greg Ward", "created_at": "March 06, 2003 at 03:27PM", "body": "Peter A-B writes:\n> If we would have an alias primitive in the sense of  common/otypes.h  \n> ,  we\n> could put the alias information itself in an OBJREC strcture and follow\n> the  omod  link as we do with other materials (e.g. textures and \n> patterns).\n> That would work regardless of the different \"alias\" syntax in the rad \n> file.\n>\n> If we would have an alias primitive in the sense of  common/otypes.h  \n> ,  we\n> could put the alias information itself in an OBJREC strcture and follow\n> the  omod  link as we do with other materials (e.g. textures and \n> patterns).\n> That would work regardless of the different \"alias\" syntax in the rad \n> file.\n\n\nWe would still have to store the target ID in a separate string \nargument, or else we'd lose the ability to change the modifier chain, \nwhich was one of the principal purposes I had in mind for aliases.  \nThis then requires a lastmod() to identify the target material at \nruntime, which can take some time if the target was a long ways back in \nthe input stream.\n\n\nThis gets a bit convoluted, but we could use a string argument in the \ncase when we're replacing the modifier in the change, and a straight \nlink with the OBJREC omod member in the more common case where we are \nnot.  That way, the common case wouldn't require any extra memory or \ntake any extra time during rendering.  Following the chain in rshow \nthen requires an extra check for the presence of string arguments to \ndetermine which modifier was aliased, but this also makes it explicit \nwhen the modifier chain was altered or not.\n\n\n-Greg\n___\n<sup>Automatically generated content from [radiance mailing-list](https://radiance-online.org/pipermail/radiance-dev/2003-March/000081.html).</sup>", "id": "radiance-dev_000081", "created_by": "Greg_Ward"}