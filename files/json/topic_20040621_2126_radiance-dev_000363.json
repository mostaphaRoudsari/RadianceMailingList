{"topic": "Trouble with ray-triangle intersection optimization", "category": "radiance-dev", "attachments": [], "created_by_name": "Marcus Jacobs", "created_at": "June 21, 2004 at 09:26PM", "body": "Dear Group\n\n\nAs a personal project of mine, I wanted to integrate the M\u00f6ller-Trumbore \n(see white paper at http://www.graphics.cornell.edu/pubs/1997/MT97.html) \nalgorithm for ray-triangle intersection into Radiance. The reason why I \nchose this algorithm is because it was simple to implement and for front \nfacing, early division can be avoided. I have read the white paper and the \nmath all checks out. The algorithm has been out for some time and has been \nimplemented in numerous other raytracers. I have not heard any problems with \nthe algorithm but in my own implementation neither the algorithm for front \nor back facing seem to work properly. I have check the code, which was \nadapted from the source code given in the paper, but it still doesn\u0092t work \nlike it should. I have thrown my hands up because I do not know what I have \ndone wrong. I have considered the Segura-Feito method (implemented in \no_mesh.c) but the problem here is that this method isn\u0092t ray-triangle \nintersection but segment-triangle intersection. The only way that I know of \nhow to calculate the ray segment length is find the ray length via ray-plane \nintersection. Unfortunately, this requires division which negates the \nprimary advantage of the Segura-Feito method. Here is the modified version \nof o_face.c that I have been working on for M\u00f6ller-Trumbore. Any help\u0085. \nPlease?\n\n\nRegards,\n\n\nMarcus\n\n\n\n\n#ifndef lint\nstatic const char RCSid[] = \"$Id: o_face.c,v 2.4 2003/03/11 17:08:55 greg \nExp $\";\n#endif\n/*\n*  o_face.c - compute ray intersection with faces.\n*/\n#include \"copyright.h\"\n#include  \"ray.h\"\n#include  \"face.h\"\n#include  \"standard.h\"\n#include  \"object.h\"\n#include  \"fvect.h\"\no_face(o, r)\t\t/* compute intersection with polygonal face */\nOBJREC  *o;\nregister RAY  *r;\n{\n\tdouble  rdot;\t\t/* direction . normal */\n\tdouble  t;\t\t/* distance to intersection */\n\tFVECT  pisect;\t\t/* intersection point */\n\tregister FACE  *f;\t/* face record */\n\tregister int  i;\n\n\n\n\n\tf = getface(o);\n\t/*\n\t *  First, we find the distance to the plane containing the\n\t *  face.  If this distance is less than zero or greater\n\t *  than a previous intersection, we return.  Otherwise,\n\t *  we determine whether in fact the ray intersects the\n\t *  face.  The ray intersects the face if the\n\t *  point of intersection with the plane of the face\n\t *  is inside the face.\n\t */\n\t/* compute dist. to plane */\n\tif(f->nv == 3)\n\t\t{\n\t\t\tif (intersect_triangle(r,f) == 0)\n\t\t\t  \treturn(0);\n\n\n\t\t}\n\telse\n\t\t{\n\t\t\trdot = -DOT(r->rdir, f->norm);\n\t\t\tif (rdot <= FTINY && rdot >= -FTINY)\t/* ray parallels plane */\n\t\t\t\tt = FHUGE;\n\t\t\telse\n\t\t\t\tt = (DOT(r->rorg, f->norm) - f->offset) / rdot;\n\t\t\tif (t <= FTINY || t >= r->rot)\t\t/* not good enough */\n\t\t\t\treturn(0);\n\t\t\t/* compute intersection */\n\t\t\tfor (i = 0; i < 3; i++)\n\t\t\t\tpisect[i] = r->rorg[i] + r->rdir[i]*t;\n\t\t\tif (!inface(pisect, f))\t\t\t/* ray intersects face? */\n\t\t\t\treturn(0);\n\t\t\tr->rot = t;\n\t\t\tVCOPY(r->rop, pisect);\n\t\t\tr->rod = rdot;\n\t\t}\n\tr->ro = o;\n\tVCOPY(r->ron, f->norm);\n\tr->pert[0] = r->pert[1] = r->pert[2] = 0.0;\n\tr->uv[0] = r->uv[1] = 0.0;\n\tr->rox = NULL;\n\treturn(1);\t\t\t\t/* hit */\n}\n/****************************************************************************/\n/* The following function is adapted from the M\u00f6ller-Trumbore  algorithm \n***/\n/****************************************************************************/\nint\nintersect_triangle(r, f)\nFACE  *f;\nregister RAY  *r;\n{\n\tdouble *u, *v, *t;\n\tdouble det,inv_det, d;\n\tint i;\n\tdouble  rdot;\n\tFVECT tvec, pvec, qvec, edge1, edge2;\n\n\n\tVSUB(edge1, VERTEX(f,1), VERTEX(f,0));\n\tVSUB(edge2, VERTEX(f,2), VERTEX(f,0));\n\n\n\t/* begin calculating determinant - also used to calculate U parameter */\n\tVCROSS(pvec, r->rdir, edge2);\n\t/* if determinant is near zero, ray lies in plane of triangle */\n\tdet = DOT(edge1, pvec);\n\tif (det > -FTINY && det < FTINY)\n\t\treturn 0;\n\tinv_det = 1.0 / det;\n\t/* calculate distance from vert0 to ray origin */\n\tVSUB(tvec, r->rorg, VERTEX(f,0));\n\t/* calculate U parameter and test bounds */\n\t*u = DOT(tvec, pvec)* inv_det;\n\tif (*u < 0.0 || *u > 1.0)\n\t\treturn 0;\n\t/* prepare to test V parameter */\n\tVCROSS(qvec, tvec, edge1);\n\t/* calculate V parameter and test bounds */\n\t*v = DOT(r->rdir, qvec) * inv_det;\n\tif (*v < 0.0 || *u + *v > 1.0)\n\t\treturn 0;\n\t/* calculate t, scale parameters, ray intersects triangle */\n\n\n\t*t = DOT(edge2, qvec) * inv_det;\n\n\n\tif (*t <= FTINY || *t >= r->rot)\t  /* not good enough */\n\t\treturn(0);\n\tr->rot = *t;\n\trdot = -DOT(r->rdir, f->norm);\n\tr->rod = rdot;\n\tfor (i = 0; i < 3; i++)\n\t\tr->rop[i] = r->rorg[i] + r->rdir[i]* r->rot;\n\treturn 1;\n}\n\n\n_________________________________________________________________\nMSN Movies - Trailers, showtimes, DVD's, and the latest news from Hollywood! \nhttp://movies.msn.click-url.com/go/onm00200509ave/direct/01/\n___\n<sup>Automatically generated content from [radiance mailing-list](https://radiance-online.org/pipermail/radiance-dev/2004-June/000363.html).</sup>", "id": "radiance-dev_000363", "created_by": "Marcus_Jacobs"}