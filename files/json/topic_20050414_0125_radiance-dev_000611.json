{"topic": "thoughts brewing...", "category": "radiance-dev", "attachments": [], "created_by_name": "Greg Ward", "created_at": "April 14, 2005 at 01:25AM", "body": "As most of you know, Christoph Reinhart's Daysim program offers an \nefficient means to perform annual simulations based on a modified \nversion of Radiance.  I am planning to meet with Christoph (for the \nfirst time) on Monday to discuss how this calculation might be \nincorporated into the main distribution.  I confess that I haven't \nspent much time looking at the modifications, but from my understanding \nof the method, it requires conditional compiles in a lot of different \nroutines, which makes me nervous.\n\n\nSo, I was thinking there might be a less invasive approach that would \nenable not only programs like Daysim but other applications as well, \nsuch as optical and daylighting systems design.\n\n\nThe basic idea I'm considering is to introduce some new \"recording\" \nmaterial type(s) that will output ray path \"relationships\" discovered \nduring the rendering/tracing process.  Each ray that intersects a \nsurface with the given material will be stored in a named data file as:\n\n\norigin_x origin_y origin_z\todir_x odir_y odir_z\ndest_x dest_y dest_z\tddir_x ddir_y ddir_z\nweight_r weight_g weight_b\n\n\nThe origin and direction would correspond to the initial primary ray, \nand the RGB weights could be computed accurately, corresponding to the \ntransmission and reflection of all surfaces encountered along the way.  \nUsing floats, this data amounts to 60 bytes/ray, which is going to add \nup quickly, so I'd probably offer the option of outputting to a program \nrather than a file, which could do the processing on the fly.\n\n\nIn a program like Daysim, we might create a recording source that \ncaptures the sky intersections and correlates them to particular origin \npoints, either on an image or a workplane or whatever.  These \ncorrelations could then be applied in a daylight coefficient approach.\n\n\nNote that the above will not work for diffuse interreflection unless \n-aa is set to 0, so we don't hide contributions by the caching process. \n  However, I think this is something we can live with -- it's still more \nefficient than computing a great many runs for different sky sources, \nas John Mardaljevic and others have been doing successfully for years.\n\n\nThis method has the advantage that it requires only minimal, isolated, \nand easy to maintain changes to the source code.  The main change is in \nthe use of the rcol member of the RAY struct, which will now mean one \nthing going out (the ray coefficient) and another thing coming back \n(the ray value -- its current meaning).  To this we add a material type \nand corresponding module to record the ray relationships -- not a big \ndeal.\n\n\nWith such an addition, it should also be possible to use Radiance for \ncertain optical design problems that it hasn't been able to do before \n-- ones where we are attempting to characterize some complex \ninput/output relationship.  However, not having thought about these \nproblems before, I'm hoping to get some feedback before I do this as to \nthings I might be forgetting.\n\n\n-Greg\n___\n<sup>Automatically generated content from [radiance mailing-list](https://radiance-online.org/pipermail/radiance-dev/2005-April/000611.html).</sup>", "id": "radiance-dev_000611", "created_by": "Greg_Ward"}