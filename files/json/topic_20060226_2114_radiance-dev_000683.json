{"topic": "vectorization data types", "category": "radiance-dev", "attachments": [], "created_by_name": "Lars O. Grobe", "created_at": "February 26, 2006 at 09:14PM", "body": "Hi!\n\n\n> I don't know quite understand how changing the struct's to union's \n> would help in vectorizing the code -- you'll have to give me an \n> explicit example, and this is probably one for radiance-dev.\n\n\nThis is the altivec way, I am not sure about other vector processors.\n\n\nA common approach to integrate altivec in conventional code is to keep \nusing arrays. The problem is that data has to be aligned for altivec. \nIf it isn't, one has to do quite a lot of operations before the actual \ncomputation. As on altivec machines, I hace a type \"vector\", I can \nenforce alignment of data in an array by the following:\n\n\ntypedef union { float arrayData[4]; vector float vectorData; } myVector;\n\n\nNow, I can still access elements in the array, but the compiler will \nalign the data, and for altivec, I can use the vector directly without \nany shifts.\n\n\nI came across this when I found an old posting from Georg, who proposed \nthat someone could take a look at multmat, which is perfect for \naltivec. But as mat4 and fvect are not aligned, the overhead is too \nlarge to really optimize code without changing data outside those \nfunctions.\n\n\nFinally, I feel I really HAVE to say that I am not a programmer, if, \nthe lousiest c and c++ \"scripter\" out there... ;-)\n\n\nCU, Lars.\n___\n<sup>Automatically generated content from [radiance mailing-list](https://radiance-online.org/pipermail/radiance-dev/2006-February/000683.html).</sup>", "id": "radiance-dev_000683", "created_by": "Lars_O._Grobe"}