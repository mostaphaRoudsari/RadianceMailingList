{"topic": "Cross-platform pcomb command-line processing", "category": "radiance-dev", "attachments": [], "created_by_name": "Randolph Fritz", "created_at": "April 20, 2010 at 01:44PM", "body": "The variations across platforms you see is because pcomb itself does  \nnot process the quotes, relying instead on the OS and the C API to get  \nthe arguments. So arguments are processed in different ways. At the  \nrisk of providing too much information, here's a writeup of how and why.\n\n\nOn Unix, the OS passes pcomb a list of arguments without quotes and  \nany substitutions done to pcomb, which never sees the quotes or  \nsubstitutions at all. A Unix shell processes single and double quotes  \nand does command-line substitutions.\n\n\nOn Windows a string is passed to the C library, which creates the list  \nof arguments and then invokes pcomb. The C library only recognizes  \ndouble quotes. The full arcane details of the Microsoft C library's  \nargument processing are documented at http://msdn.microsoft.com/en-us/library/aa243471%28VS.60%29.aspx \n. I'm not sure what the GNU C library (mingw) does on Windows.\n\n\nThe Python \"subprocess\" module can be used in two different ways: to  \ninvoke pcomb directly (shell=False), in which case a sequence is  \npreferred, and no processing is done on the sequence; \"subprocess\"  \nmakes every effort to see that that sequence becomes pcomb's argument  \nlist on all platforms. If, on the other hand, if shell=True is used, a  \nstring argument is preferred, and pcomb is invoked indirectly through  \na shell. My general preference is for shell=False, since one can get  \namazingly confusing results passing already-processed arguments  \nthrough a shell, but there are some uses for shell=True.\n\n\nRandolph\n___\n<sup>Automatically generated content from [radiance mailing-list](https://radiance-online.org/pipermail/radiance-dev/2010-April/001021.html).</sup>", "id": "radiance-dev_001021", "created_by": "Randolph_Fritz"}