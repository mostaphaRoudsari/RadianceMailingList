{"topic": "strange artifacts in rendering (and Yosemite bug)", "category": "radiance-general", "attachments": [], "created_by_name": "Greg Ward", "created_at": "August 21, 2015 at 11:59AM", "body": "As it turns out, this appears *not* to be a problem with Yosemite after all, but an issue with the last official release (4.2.2), whose accuracy isn't quite as good as the latest (HEAD or 5.0a) with respect to its Hessian interpolation method.  The artifacts MJ noticed were due to inaccuracies in the interreflection calculation, for which this scene is something of a worst case.  Decreasing the -aa parameter while increasing -ad seems to resolve these issues, especially with the latest code.\n\n\nWhile playing around with Yosemite trying to reproduce these artifacts, I discovered that the problems I thought I was having with the system select() call were in fact due to a bug in the way Yosemite handles application-level file locking.  This was a complete surprise, but it turns out not to be so difficult to work around.\n\n\nWithout getting too much into the details, the stdio library has these lock/unlock calls to make the library thread-safe, which of course I don't care about because I don't use threads, but they severely impact performance even on unthreaded code.  In some cases, it requires a mutex lock/block/unlock procedure for every character that is input or output, completely defeating the purpose of i/o buffering that is the purpose of stdio in the first place.  Therefore, I had some workarounds in place to reduce or eliminate this overhead, basically locking the files once at the outset to avoid the per-call mutex overhead.\n\n\nThis all worked fine up until the latest release of Mac OS X (10.10), when Apple changed the behavior of fork() such that it preserves application-level i/o locking for no conceivable reason.  Since these locks are designed to negotiate between threads sharing memory (i/o buffers), and separate processes don't share memory, the locks should sever on fork().  Every Unix out there does this, except Mac OS X 10.10.x.  Therefore, when I made a call to flockfile() at the start of rvu or rtrace, then forked its children, each child would deadlock the instant it tried to use a shared file pointer (i.e., the ambient file).\n\n\nYou could say I was being cavalier about the use of flockfile(), but I was just trying to work around a horrible performance bottleneck introduced with automatic application-level locking in stdio.  It's one thing to introduce a new feature and suggest that people using multi-threading take advantage of it.  It's another thing to implement locking as the new default behavior, while decreasing i/o performance by about 90% (no exaggeration) even when it is not needed, then not even offer a means to disable it.\n\n\nIn any event, I checked in a change that I'm hoping fixes this issue under Yosemite, while not costing us too much on all the other Unix platforms that don't have this issue.\n\n\nCheers,\n-Greg\n___\n<sup>Automatically generated content from [radiance mailing-list](https://radiance-online.org/pipermail/radiance-general/2015-August/011215.html).</sup>", "id": "radiance-general_011215", "created_by": "Greg_Ward"}