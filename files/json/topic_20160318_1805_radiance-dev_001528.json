{"topic": "Winrview", "category": "radiance-dev", "attachments": [], "created_by_name": "Georg Mischler", "created_at": "March 18, 2016 at 06:05PM", "body": "Alright, I got winrview working with R5 (without extensive testing)\n\n\nWith the help of a modern compiler, some non-standard coding had\nto be eliminated. Then I found that lots of function and variable\nnames in Radiance had changed over the years. And finally there was\njust the usual weirdness of fiddling with someone elses code...\n\n\nInstead of copying certain key files from Radiance and chainging them\nlike last time, I tried to adapt the other way now. I threw out all\ncopied files and most copied functions, linking directly to the \noriginals.\nFor that to work, I had to actually implement the display driver \nprotocol,\nso the library would link with no missing symbols (just pro-forma for \nnow,\nthe protocol doesn't actually do anything useful yet).\nThe result is still a bit quirky, but it runs and displays simulations.\n\n\nWinrview uses the standard Windows method to handle background\ncomputations. The MFC library offers a way to have tasks invoked by an\n\"onIdle\" handler, which means they will be started any time the user\nleaves the GUI alone (I think it's even in a seperate thread).\nAs soon as the user touches anything, the running simulation should\nbe signalled to pause and then restart with the new parameters.\nThe controlling agent is not the rvu core, nor even winrview itself,\nbut the event loop of a windows library.\n\n\nRvu manages its own command loop, and a queue of rays to simulate\nwhile waiting for user input. I don't quite understand yet how a GUI\n\"driver\" will maintain its indepence and responsiveness next to that,\nbut as qtrvu demonstrates, it seems to be possible.\n\n\nYears ago we worried a lot about response times, as a GUI is supposed\nto react instantly to user input. In fact, we had tweaked some\nrendering functions deep inside Radiance, so we could interrupt a\nsimulation even in the middle of computing an individual ray, no\nmatter how many recursions deep.\n\n\nI didn't bother with that this time. Given the increased CPU power\navailable, I'm not sure if it would still be of any benefit.\nI remember waiting long seconds for (x)rvu to react to input.\nBut now it usually answers almost instantly even with a largish model\nand tough parameters.\n\n\nWhat's still to do?\n\n\n  * At the end of a simulation, the very first large tiles suddenly\n    overlap the new and smaller ones again - until the next refresh, eg.\n    when the window is moved around a bit. I blame my OpenGL driver.\n\n\n  * Full implementation of the display driver protocol. If this works\n    while maintaining sufficient responsiveness, then it would\n    reduce the duplicated functionality, and simplify the whole thing.\n\n\n  * It doesn't know about any of the recently added simulation options\n    (pmap, etc.). Both the GUI and the command line should learn about\n    those (the latter possibly via the task above).\n\n\n  * The program currently doesn't have a command protocol window, but\n    presents \"urgent\" info via entertaining popups.\n\n\n  * Command line parameters are used, but not propagated to the\n    dialog box (it opens showing the default values).\n\n\n  * The GUI is quite functional with dockable toolbars, but has the\n    typical 90-ies look of Windows NT.\n\n\n  * There's qite a bit of cruft in the code to clean up.\n    (eg. checking registry entries for paths, left over from DR.)\n\n\nAny takers? ;)\n\n\nThere are 12x files of C++, 7x files of C, a bunch of headers, plus\nsome resources. It builds with both Visual Studio 2015 and SCons.\n\n\n-schorsch\n\n\n\n\nGeorg Mischler  --  simulations developer  --  schorsch at schorsch com\n+schorsch.com+  --  lighting design tools  --  http://www.schorsch.com/\n___\n<sup>Automatically generated content from [radiance mailing-list](https://radiance-online.org/pipermail/radiance-dev/2016-March/001528.html).</sup>", "id": "radiance-dev_001528", "created_by": "Georg_Mischler"}