{"topic": "\"under the hood\" handle of Ambient File, Octree (oconv) and ray tracing for a C++ program", "category": "radiance-dev", "attachments": [], "created_by_name": "Germ\u00e1n Molina Larrain", "created_at": "September 13, 2017 at 02:57PM", "body": "Hello all,\n\n\nI am experimenting with Radiance code, with the purpose of creating a\ncalculation engine for Groundhog.\n\n\nIn the process, I have managed to write a C++ program (early tests have\npassed, so far) that can read SketchUp model and export it in Radiance\nformat. However, my intention is to allow it to calculate things, thus\navoiding the need of exporting and handling thousands of files and\nscripting.\n\n\nMy idea is to generate a program that basically receives a SketchUp model\nand perform several calculations... a very simple call\n\n\ngh_calc_engine Model.skp > results.txt\n\n\nThe program will need, of course, to create the octree (not from a text\nfile, but from the internal data structure) and run rtrace or something\nlike that. I am checking how to do it and haven't gotten very far... could\nyou guys help me?\n\n\nFor what I understand, a program would need some sort of structure as shown\nbelow my signature, but I am unsure. I am far from compiling.... for now, I\nam trying to understand how Radiance works underneath.\n\n\nYour help/hints and other things will be very appreciated\n\n\nKind regards,\n\n\nGerm\u00e1n\n\n\n\n\n/* Groundhog RTRACE analog */\n\n\n/* START */\nextern CUBE thesene = {{0.0, 0.0, 0.0}, 0.0, EMPTY}; // Define \"the scene\"\nextern OBJECT nsceneobjs; // number of objects\n... // some more externs such as raynum, nrays, etc. present in\n\"src/rt/ray.h\"\n\n\n/* OCONV */\n\n\nfor (size_t i=0; i < nobjects; i++){\n// THIS WILL BE DONE WITH MATERIALS AS WELL\n\n\n// as shown in getobject function in readobj.c\nif(obj = newobject() == OVOID)\nerror(\"Out of space\")\nobjp = objptr(obj);\n\n\n// translate\ngroundhog_object = objects[i];\nobjp->omod = groundhog_object.material.name; // this would be an int\nobjp->otype = groundhog_object.type;\nobjp->oname = groundhog_object.name;\ngroundhog_object.setRadianceArguments(&objp->oargs); // arguments are\nvalidated by Groundhog\n\n\n// insert\ninsertobject(obj);\n\n\n}\n\n\n/* RTRACE --- as seen in rt/rtmain.c*/\nFVECT orig;\nFVECT dir;\nRAY thisray;\nCOLOR rayvalue;\nmarksources();\nsetambient();\nfor(size_t i=0; i < nrays; i++){\norigin= groundhog_rays[i].origin; // need to normalize\norig[0] = origin.getX();\norig[1] = origin.getY();\norig[2]= origin.getZ();\n\n\ndirection = groundhog_rays[i].direction; // need to normalize\ndir[0] = direction.getX();\ndir[1] = direction.getY();\ndir[2]= direction.getZ();\n\n\n// Set up and trace rays ... as in rtcompute\nrayorigin(&thisray,PRIMARY,NULL,NULL);\nif (imm_irrad) { // What does this do? acts like the +i param in RTRACE?\nVSUM(thisray.rorg, org, dir, 1.1e-4);\nthisray.rdir[0] = -dir[0];\nthisray.rdir[1] = -dir[1];\nthisray.rdir[2] = -dir[2];\nthisray.rmax = 0.0;\nthisray.revf = rayirrad;\n} else {\nVCOPY(thisray.rorg, org);\nVCOPY(thisray.rdir, dir);\nthisray.rmax = dmax;\nif (castonly)\nthisray.revf = raycast;\n}\n// Get value\nrayvalue(&thisray); // not sure what this does\nrayvalue = thisray.rcol; // Will this give me the RGB values to convert\ninto Lux or whatever?\n// Sync ambient\nambsync(); // How do I initialize this ambient file????\n}\n___\n<sup>Automatically generated content from [radiance mailing-list](https://radiance-online.org/pipermail/radiance-dev/2017-September/001713.html).</sup>", "id": "radiance-dev_001713", "created_by": "Germ\u00e1n_Molina_Larrain"}