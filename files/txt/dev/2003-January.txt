From radiance-dev@radiance-online.org  Wed Jan  1 03:30:23 2003
From: radiance-dev@radiance-online.org (Robert Kalocay)
Date: Wed, 01 Jan 2003 14:30:23 +1100
Subject: [Radiance-dev] archicad add-on
Message-ID: <F3owspDKicUbvBDxroC00000479@hotmail.com>

hi everyone there,

I would like to know if anybody tried to deploy radiance rendering engine 
into Archicad? If not, is anybody interested in developing such a thing?

any information would be highly welcomed

robert




_________________________________________________________________
The new MSN 8 is here: Try it free* for 2 months 
http://join.msn.com/?page=dept/dialup


From radiance-dev@radiance-online.org  Sat Jan 18 11:44:43 2003
From: radiance-dev@radiance-online.org (Georg Mischler)
Date: Sat, 18 Jan 2003 06:44:43 -0500 (EST)
Subject: [Radiance-dev] Re: multiprocessor systems, Radiance, and you
In-Reply-To: <3E293BBE.B65B6737@t-online.de>
Message-ID: <Pine.BSF.4.44.0301180640540.90303-100000@emancholl.pair.com>

Carsten Bauer wrote:

> there's one master distributing the blocks, the workers
> which do the tracing, a collector receiving finished scanlines (and in
> the end  puzzles everything together for the big picture) and of course
> the ambient slave, who receives amb. values and broadcasts them to all
> the other workers. This ambient slave alone has access to the file for
> storing them. Only at the beginning of a new run the workers can access
> an already existing ambfile for reading in values.


In a thread on the dev list from Wed, 12 Jun 2002
http://www.radiance-online.org/pipermail/radiance-dev/2002-June/000001.html
I said the following, which was received with quite a bit
of scepticism:

   Since Windows doesn't support NFS file locking
  (and neither did cygwin, last time I looked), we'll need to find
  a better solution for concurrent access to ambient files. I can
  think of two portable ways to do this: Either we invent a file
  based locking mechanism, or we establish a seperate server
  process that accepts network store and retreival requests by the
  actual simulation processes. The latter would be more technicall
  involved, but probably a lot more robust. Any thoughts?

And now, half a year later, you tell us that you already have such
a server implemented? Only that you call it "slave"... ;)
Does your "slave" require PVM? If yes, then that would probably make
it platform independent, otherwise you'd have to tell us some more
details. Personally, I think that this alone would be worth adding
to the ANSified Radiance core, with the management stuff up for
discussion.

But maybe we can now really move the details to the dev list. I'm
cross-posting this, so there's no need to reply on the general list.


-schorsch

-- 
Georg Mischler  --  simulations developer  --  schorsch at schorsch com
+schorsch.com+  --  lighting design tools  --  http://www.schorsch.com/


From radiance-dev@radiance-online.org  Sat Jan 18 12:48:18 2003
From: radiance-dev@radiance-online.org (Carsten Bauer)
Date: Sat, 18 Jan 2003 13:48:18 +0100
Subject: [Radiance-dev] Re: multiprocessor systems, Radiance, and you
References: <Pine.BSF.4.44.0301180640540.90303-100000@emancholl.pair.com>
Message-ID: <3E294D12.724E4E8F@t-online.de>

Hi Schorsch,

just a quick crude reply right now, have to leave soon, maybe more next
week..

OK, I didn't really promote my PVM stuff vigourously. In 2001, I had a
short email-contact with Charles, I offered the stuff for publication.
(Some small bugs had been in it at that time, and the parallel rview was
much too slow, it's the problem of the rview-style itself which makes
parallel rview rather impossible/inefficient, so I abandoend it
finally).

But the rpict mode works fine and reliable, esp after some later
improvement.

On all occasions of my mentioning it later, I had the impression that
the interest in it was rather limited, besides, I concentrated on other
work (direct cache), so I kept my mouth shut on it.. :-) This isn't
meant as a complaint, really not. It's just a self-evident fact that
there are several 'philosophies' concerning the future Radiance
development, so there will always be more ideas then final (official)
realisations.

Additionally, I know nothing about Windows or OS X, so that platform
independent PVM Version would be something for a team to be built, if at
all. I'm currently just a single bozo (who by the way learned
C-programming by exploring the Radiance-code) so I did experiment a lot
but mainly persued personal preferences (additionally receiving no
funding, too, which I have to consider, such is the hard reality of
life). If the stuff is of public interest, however, I'm of course all
ears and willing to join in some cooperative effort.

So long for now

-Carsten

From radiance-dev@radiance-online.org  Thu Jan 23 19:16:52 2003
From: radiance-dev@radiance-online.org (Jack de Valpine)
Date: Thu, 23 Jan 2003 14:16:52 -0500
Subject: [Radiance-dev] Re: multiprocessor systems, Radiance, and you
References: <Pine.BSF.4.44.0301180640540.90303-100000@emancholl.pair.com>
Message-ID: <3E303FA4.6010800@visarc.com>

--------------040204060307080608010706
Content-Type: text/plain; charset=us-ascii; format=flowed
Content-Transfer-Encoding: 7bit

Hi Georg, Carsten, Peter, Greg and others,

As in my other post, sorry to be weighing in a week late. In any event, 
what is the current summary of  ways to develop distributed rendering 
for Radiance? Based on my understanding of the topic, it seems that 
there are several approaches that have been put on the table:

    * file based locking:
          * NFS - as currently implemented and with all the NFS related
            issues
          * Samba - I recall that Georg had mentioned this as a possibly
            more reliable mechanism
          * Custom - homegrown solution for locking files
    * client/server - presumably a socket based client server mechanism
      but not relying on pvm/mpi
    * pvm/mpi:
          * LBNL - is this pvm or mpi and is it available to the open
            source development team?
          * Carsten - has done something with pvm, is there more
            information description?
          * Roland Koholka, Heinz Mayer, Alois Goller ("MPI-parallelized
            Radiance on SGI CoW and SMP" - Parallel Computation, 4th
            International ACPC Conference, Salzburg, Austria, LNCS 1557,
            pages 549- 558, February 1999.) - I do have the modified
            code (ambient.c, rmain.c, and rpict.c) for this that I
            downloaded at somepoint long ago if anyone is interested as
            well as a pdf of the paper. 

I guess the very general question that I would have is what is the best 
solution architecturally for Radiance:

    * Is it easiest to develop a file based locking solution, possibly
      around samba, which is a robust mechanism based on what I have read?
    * What are the implementation issues relating to doing a
      client/server model vs. something like pvm/mpi, how much of the
      guts of radiance need to be worked on for either option, what is
      most robust, extensible and os dependant/independant

If it is worth it to the development team, I would be happy to dig back 
into the archives and try to put together a fuller summary of the 
various options that have been put on the table. Let me know.

Regards,

-Jack de Valpine

Georg Mischler wrote:

>Carsten Bauer wrote:
>
>>there's one master distributing the blocks, the workers
>>which do the tracing, a collector receiving finished scanlines (and in
>>the end  puzzles everything together for the big picture) and of course
>>the ambient slave, who receives amb. values and broadcasts them to all
>>the other workers. This ambient slave alone has access to the file for
>>storing them. Only at the beginning of a new run the workers can access
>>an already existing ambfile for reading in values.
>>
>
>
>In a thread on the dev list from Wed, 12 Jun 2002
>http://www.radiance-online.org/pipermail/radiance-dev/2002-June/000001.html
>I said the following, which was received with quite a bit
>of scepticism:
>
>   Since Windows doesn't support NFS file locking
>  (and neither did cygwin, last time I looked), we'll need to find
>  a better solution for concurrent access to ambient files. I can
>  think of two portable ways to do this: Either we invent a file
>  based locking mechanism, or we establish a seperate server
>  process that accepts network store and retreival requests by the
>  actual simulation processes. The latter would be more technicall
>  involved, but probably a lot more robust. Any thoughts?
>
>And now, half a year later, you tell us that you already have such
>a server implemented? Only that you call it "slave"... ;)
>Does your "slave" require PVM? If yes, then that would probably make
>it platform independent, otherwise you'd have to tell us some more
>details. Personally, I think that this alone would be worth adding
>to the ANSified Radiance core, with the management stuff up for
>discussion.
>
>But maybe we can now really move the details to the dev list. I'm
>cross-posting this, so there's no need to reply on the general list.
>
>
>-schorsch
>

-- 
#	John E. de Valpine
#	president
#
#	visarc incorporated
#	http://www.visarc.com
#
#	channeling technology for superior design and construction



--------------040204060307080608010706
Content-Type: text/html; charset=us-ascii
Content-Transfer-Encoding: 7bit

<html>
<head>
</head>
<body>
Hi Georg, Carsten, Peter, Greg and others,<br>
<br>
As in my other post, sorry to be weighing in a week late. In any event, what
is the current summary of&nbsp; ways to develop distributed rendering for Radiance?
Based on my understanding of the topic, it seems that there are several approaches
that have been put on the table:<br>
<ul>
  <li>file based locking:</li>
  <ul>
    <li>NFS - as currently implemented and with all the NFS related issues</li>
    <li>Samba - I recall that Georg had mentioned this as a possibly more
reliable mechanism</li>
    <li>Custom - homegrown solution for locking files <br>
    </li>
  </ul>
  <li>client/server - presumably a socket based client server mechanism but
not relying on pvm/mpi</li>
  <li>pvm/mpi:</li>
  <ul>
    <li>LBNL - is this pvm or mpi and is it available to the open source
development team?</li>
    <li>Carsten - has done something with pvm, is there more information
description?</li>
    <li>Roland Koholka, Heinz Mayer, Alois Goller ("MPI-parallelized Radiance
on SGI CoW and SMP" - Parallel Computation, 4th International ACPC Conference,
Salzburg, Austria, LNCS 1557, pages 549- 558, February 1999.) - I do have
the modified code (ambient.c, rmain.c, and rpict.c) for this that I downloaded
at somepoint long ago if anyone is interested as well as a pdf of the paper.&nbsp;</li>
  </ul>
</ul>
I guess the very general question that I would have is what is the best solution
architecturally for Radiance:<br>
<ul>
  <li>Is it easiest to develop a file based locking solution, possibly around
samba, which is a robust mechanism based on what I have read?</li>
  <li>What are the implementation issues relating to doing a client/server
model vs. something like pvm/mpi, how much of the guts of radiance need to
be worked on for either option, what is most robust, extensible and os dependant/independant</li>
</ul>
If it is worth it to the development team, I would be happy to dig back into
the archives and try to put together a fuller summary of the various options
that have been put on the table. Let me know.<br>
<br>
Regards,<br>
<br>
-Jack de Valpine<br>
<br>
Georg Mischler wrote:<br>
<blockquote type="cite" cite="mid:Pine.BSF.4.44.0301180640540.90303-100000@emancholl.pair.com">
  <pre wrap="">Carsten Bauer wrote:<br><br></pre>
  <blockquote type="cite">
    <pre wrap="">there's one master distributing the blocks, the workers<br>which do the tracing, a collector receiving finished scanlines (and in<br>the end  puzzles everything together for the big picture) and of course<br>the ambient slave, who receives amb. values and broadcasts them to all<br>the other workers. This ambient slave alone has access to the file for<br>storing them. Only at the beginning of a new run the workers can access<br>an already existing ambfile for reading in values.<br></pre>
    </blockquote>
    <pre wrap=""><!----><br><br>In a thread on the dev list from Wed, 12 Jun 2002<br><a class="moz-txt-link-freetext" href="http://www.radiance-online.org/pipermail/radiance-dev/2002-June/000001.html">http://www.radiance-online.org/pipermail/radiance-dev/2002-June/000001.html</a><br>I said the following, which was received with quite a bit<br>of scepticism:<br><br>   Since Windows doesn't support NFS file locking<br>  (and neither did cygwin, last time I looked), we'll need to find<br>  a better solution for concurrent access to ambient files. I can<br>  think of two portable ways to do this: Either we invent a file<br>  based locking mechanism, or we establish a seperate server<br>  process that accepts network store and retreival requests by the<br>  actual simulation processes. The latter would be more technicall<br>  involved, but probably a lot more robust. Any thoughts?<br><br>And now, half a year later, you tell us that you already have such<br>a server implemented? O
nly that you call it "slave"... ;)<br>Does your "slave" require PVM? If yes, then that would probably make<br>it platform independent, otherwise you'd have to tell us some more<br>details. Personally, I think that this alone would be worth adding<br>to the ANSified Radiance core, with the management stuff up for<br>discussion.<br><br>But maybe we can now really move the details to the dev list. I'm<br>cross-posting this, so there's no need to reply on the general list.<br><br><br>-schorsch<br><br></pre>
    </blockquote>
    <br>
    <pre class="moz-signature" cols="$mailwrapcol">-- 
#	John E. de Valpine
#	president
#
#	visarc incorporated
#	<a class="moz-txt-link-freetext" href="http://www.visarc.com">http://www.visarc.com</a>
#
#	channeling technology for superior design and construction</pre>
    <br>
    </body>
    </html>

--------------040204060307080608010706--


From radiance-dev@radiance-online.org  Fri Jan 24 06:40:01 2003
From: radiance-dev@radiance-online.org (Charles Ehrlich)
Date: Thu, 23 Jan 2003 22:40:01 -0800 (PST)
Subject: [Radiance-dev] Re: multiprocessor systems, Radiance, and you
In-Reply-To: <3E303FA4.6010800@visarc.com>
Message-ID: <20030124064001.87682.qmail@web80002.mail.yahoo.com>

--0-1498359771-1043390401=:87663
Content-Type: text/plain; charset=us-ascii


Hi,
There is already an implementation of the ambient file sharing/locking and rpiece (I think) using Samba.  It was developed for cygwin.  The modifications were very minor.  Shall I try to dig up these mods and post them here?
The LBNL multiprocessor version is built around MPI.  There is a version for the Cray T3E and a version for the SGI Onyx 2000.  Apparently MPI is not terribly cross-platform.  I do not speak for LBNL, but I would expect this version to be Open Source along with the rest of the kettle.
Has anyone played around with Greg's multiprocessor client/server model?  He developed "rholo" (as in holodeck) while working at SGI.  It has some fancy ray-caching mechanisms for near real-time walkthroughs, and also has a back-end that effectively manages the resources of 64 processors or more.  I don't know what procedure mechanism he uses.  Knowing him, he probably started from scratch.  
-Chas

--0-1498359771-1043390401=:87663
Content-Type: text/html; charset=us-ascii

<P>Hi,
<P>There is already an implementation of the ambient file sharing/locking and rpiece (I think) using Samba.&nbsp; It was developed for cygwin.&nbsp; The modifications were very minor.&nbsp; Shall I try to dig up these mods and post them here?
<P>The LBNL multiprocessor version is built around MPI.&nbsp; There is a version for the Cray T3E and a version for the SGI Onyx 2000.&nbsp; Apparently MPI is not terribly cross-platform.&nbsp; I do not speak for LBNL, but I would expect this version to be Open Source along with the rest of the kettle.
<P>Has anyone played around with Greg's multiprocessor client/server model?&nbsp; He developed "rholo" (as in holodeck) while working at SGI.&nbsp; It has some fancy ray-caching mechanisms for near real-time walkthroughs, and also has a back-end that effectively manages the resources of 64 processors or more.&nbsp; I don't know what procedure mechanism he uses.&nbsp; Knowing him, he probably&nbsp;started from scratch.&nbsp; 
<P>-Chas</P>
--0-1498359771-1043390401=:87663--

From radiance-dev@radiance-online.org  Fri Jan 24 21:55:42 2003
From: radiance-dev@radiance-online.org (Greg Ward)
Date: Fri, 24 Jan 2003 13:55:42 -0800
Subject: [Radiance-dev] Re: multiprocessor systems, Radiance, and you
In-Reply-To: <20030124110002.5926.93062.Mailman@darkside-animation.com>
Message-ID: <9565D0A4-2FE6-11D7-B7EA-00306540F848@lmi.net>

I'm a little confused as to which list to reply to on this subject, as 
things have been sent to both lists.  So, I'll send my reply to both 
places...

I have been working on an ANSI-C version of Radiance, which is mostly 
ready at this point.  The library files in src/common and the rendering 
code in src/rt now uses prototypes for all its functions, and I have 
collected the rendering code into a new library that may be linked to 
other applications.  I have also added an interface to this library 
that provides sequential and parallel (multiprocessor -- not 
distributed) ray-tracing.  Using this interface, I have developed a new 
animation program, called "ranimove", which in a single process 
performs object and camera animation with image-based rendering 
(similar to pinterp but without interpolating frames) and optimized, 
progressive rendering of animations with task focus.  All rendering, 
filtering, etc. is handled in a single process.  Only xform and oconv 
are executed to update the scene octree at each frame.

That's mostly an aside, but I wanted to mention it as background for 
what I'm about to say on ambient value sharing.  The code in rholo 
works similarly to the code in rpiece and ranimate, which use separate 
invocations of rtrace or rpict to do their ray calculations.  The code 
in the new ranimove program is different in the sense that the 
rendering happens in the same process (or identical children of the 
same process), but ambient value sharing is the same.

The main issue I have with using Samba or MPI or PVM or whatever you 
want to use is the difficulty of requiring or including a third-party 
library with Radiance.  If you require that the user have this software 
in order to install Radiance on their platform, that can be an 
insurmountable burden for some people, and an inconvenience at the very 
least for others.  If you include the library with Radiance, then you 
invite at least three problems:

	1) The user may already have a version of the same library.
	2) The library may be updated asynchronously by its author, causing 
incompatibilities.
	3) The library may not be portable to all the systems Radiance is.

For this reason, I have only made rare exceptions to the "no library 
dependencies" rule in Radiance.  One is for TIFF import/export, where I 
have the very well-established and stable TIFF library by Sam Leffler 
to rely on.  Another is X11, which is almost ubiquitous on Unix.  The 
third is for OpenGL, which is supported on most platforms, and may be 
excluded from compilation without too much difficulty.  I do not 
include an OpenGL library with Radiance.

If we want to share ambient values without using the NFS lock manager, 
we either have to employ some third-party library (Samba, MPI, PVM, 
EIEIO, whatever), or we need to find a way to do it that is universally 
supported on Unix.

Unfortunately, the only universally supported interprocess 
communication call for Unix (as far as I know) is the socketpair(2) 
call.  This is just about as nasty as any system call I've ever 
encountered, which is why I've avoided it.  It requires all sorts of 
knowledge about the network to link up with another process somewhere, 
and I've never been able to fathom the intracacies to making it work.  
(If anyone has some simple example code, please share it with me.)  
Also, there is no hope of porting this to Windows.

This brings us back to my original question when this thread was 
started sometime last Spring (I think) -- is there a stable, portable 
library for sharing process data across the network.  I thought the 
consensus was that Samba was the best.  Can it be distributed and 
compiled, or is it readily available for all platforms?  How much of a 
burden is it to users to install this along with Radiance?  Should we 
offer it only as an option for people who want to do parallel rendering 
on platforms with unreliable NFS lock managers, or should we make it a 
requirement for everyone on every platform?

-Greg


From radiance-dev@radiance-online.org  Sat Jan 25 04:29:25 2003
From: radiance-dev@radiance-online.org (Randolph Fritz)
Date: Fri, 24 Jan 2003 20:29:25 -0800
Subject: [Radiance-dev] Re: multiprocessor systems, Radiance, and you
In-Reply-To: <9565D0A4-2FE6-11D7-B7EA-00306540F848@lmi.net>
Message-ID: <959601BC-301D-11D7-956F-0030658EA95E@panix.com>

MPI *is* cross-platform, as far as I know.  There's a free version of 
MPI 1.2 (MPICH) which runs on many Unices, Mac OS X and Windows NT, 
2000, and XP.  MPI-2 is only available in commercial implementations, 
as far as I know, though MPICH is planned to support it.

I have real doubts about the performance of SMB (on which Samba is 
based) and, if Microsoft modifies the underlying protocols, it may no 
longer be widely available--it isn't readily available on most unix 
systems, though there are implementations that will run on most of them.

I think this may be an area that best performance and ease of use will 
be achieved either by supporting  multiple standards or, alternatively, 
by doing some protocol design.  For what Radiance does with its ambient 
data, MPI is may be overkill.  Or maybe not; I'm not a parallel systems 
expert.

Randolph

MPI links:
   MPICH		http://www-unix.mcs.anl.gov/mpi/mpich/
   MPICH for XP http://www.lfbs.rwth-aachen.de/mp-mpich/
   MPI forum	http://www.mpi-forum.org/
			Standards documents annoying distributed in PostScript.
   There are various commercial implementations as well.


From radiance-dev@radiance-online.org  Sat Jan 25 04:29:25 2003
From: radiance-dev@radiance-online.org (Randolph Fritz)
Date: Fri, 24 Jan 2003 20:29:25 -0800
Subject: [Radiance-dev] Re: multiprocessor systems, Radiance, and you
In-Reply-To: <9565D0A4-2FE6-11D7-B7EA-00306540F848@lmi.net>
Message-ID: <959601BC-301D-11D7-956F-0030658EA95E@panix.com>

MPI *is* cross-platform, as far as I know.  There's a free version of 
MPI 1.2 (MPICH) which runs on many Unices, Mac OS X and Windows NT, 
2000, and XP.  MPI-2 is only available in commercial implementations, 
as far as I know, though MPICH is planned to support it.

I have real doubts about the performance of SMB (on which Samba is 
based) and, if Microsoft modifies the underlying protocols, it may no 
longer be widely available--it isn't readily available on most unix 
systems, though there are implementations that will run on most of them.

I think this may be an area that best performance and ease of use will 
be achieved either by supporting  multiple standards or, alternatively, 
by doing some protocol design.  For what Radiance does with its ambient 
data, MPI is may be overkill.  Or maybe not; I'm not a parallel systems 
expert.

Randolph

MPI links:
   MPICH		http://www-unix.mcs.anl.gov/mpi/mpich/
   MPICH for XP http://www.lfbs.rwth-aachen.de/mp-mpich/
   MPI forum	http://www.mpi-forum.org/
			Standards documents annoying distributed in PostScript.
   There are various commercial implementations as well.


From radiance-dev@radiance-online.org  Mon Jan 27 06:42:39 2003
From: radiance-dev@radiance-online.org (Charles Ehrlich)
Date: Sun, 26 Jan 2003 22:42:39 -0800 (PST)
Subject: [Radiance-dev] Re: multiprocessor systems, Radiance, and you
In-Reply-To: <959601BC-301D-11D7-956F-0030658EA95E@panix.com>
Message-ID: <20030127064239.13658.qmail@web80009.mail.yahoo.com>

--0-1216286439-1043649759=:13474
Content-Type: text/plain; charset=us-ascii


Sorry Randolph.  My experience, both direct and indirect, is opposite just about every point you make.  I have no experience with MPICH, but when I oversaw the programming of LBNL's "LDRD" version of Radiance, the programmer had to re-write his code for two different SGI platforms.  So much for portability.  Perhaps this says more about the skill of the programmer (I don't think so), or of the SGI implementation(s) of MPI....?
In the experiments that I ran with the CynWin version of rpiece, SMB/Samba has proven to be very responsive and reliable.  And to address one of Greg's concerns, the Samba extensions for Unix are quite easy to install.  For the Windows version of Radiance, no additional libraries would need to be installed (of course.)
The LDRD version of Radiance required the use of a robust interface such as MPI in order for the code to scale up to hundreds of processors without serious degradation, according to the programmer.  It was running on 250 processors on the Cray T3E with about 80% utilization of the processors.
-Chas
 Randolph Fritz <randolph@panix.com> wrote:MPI *is* cross-platform, as far as I know. There's a free version of 
MPI 1.2 (MPICH) which runs on many Unices, Mac OS X and Windows NT, 
2000, and XP. MPI-2 is only available in commercial implementations, 
as far as I know, though MPICH is planned to support it.

I have real doubts about the performance of SMB (on which Samba is 
based) and, if Microsoft modifies the underlying protocols, it may no 
longer be widely available--it isn't readily available on most unix 
systems, though there are implementations that will run on most of them.

I think this may be an area that best performance and ease of use will 
be achieved either by supporting multiple standards or, alternatively, 
by doing some protocol design. For what Radiance does with its ambient 
data, MPI is may be overkill. Or maybe not; I'm not a parallel systems 
expert.

Randolph

MPI links:
MPICH http://www-unix.mcs.anl.gov/mpi/mpich/
MPICH for XP http://www.lfbs.rwth-aachen.de/mp-mpich/
MPI forum http://www.mpi-forum.org/
Standards documents annoying distributed in PostScript.
There are various commercial implementations as well.

_______________________________________________
Radiance-dev mailing list
Radiance-dev@radiance-online.org
http://www.radiance-online.org/mailman/listinfo/radiance-dev
--0-1216286439-1043649759=:13474
Content-Type: text/html; charset=us-ascii

<P>Sorry Randolph.&nbsp; My experience, both direct and indirect, is opposite just about every point you make.&nbsp; I have no experience with MPICH, but when I oversaw the programming of LBNL's "LDRD" version of Radiance, the programmer had to re-write his code for two different SGI platforms.&nbsp; So much for portability.&nbsp; Perhaps this says more about the skill of the programmer (I don't think so), or of the SGI implementation(s) of MPI....?
<P>In the experiments that I ran with the CynWin version of rpiece, SMB/Samba has proven to be very responsive and reliable.&nbsp; And to address one of Greg's concerns, the Samba extensions for Unix are quite easy to install.&nbsp; For the Windows version of Radiance, no additional libraries would need to be installed (of course.)
<P>The LDRD version of Radiance required the use of a robust interface such as MPI in order for the code to scale up to hundreds of processors without serious degradation, according to the programmer.&nbsp; It was running on 250 processors on the Cray T3E with about 80% utilization of the processors.
<P>-Chas
<P>&nbsp;<B><I>Randolph Fritz &lt;randolph@panix.com&gt;</I></B> wrote:
<BLOCKQUOTE style="PADDING-LEFT: 5px; MARGIN-LEFT: 5px; BORDER-LEFT: #1010ff 2px solid">MPI *is* cross-platform, as far as I know. There's a free version of <BR>MPI 1.2 (MPICH) which runs on many Unices, Mac OS X and Windows NT, <BR>2000, and XP. MPI-2 is only available in commercial implementations, <BR>as far as I know, though MPICH is planned to support it.<BR><BR>I have real doubts about the performance of SMB (on which Samba is <BR>based) and, if Microsoft modifies the underlying protocols, it may no <BR>longer be widely available--it isn't readily available on most unix <BR>systems, though there are implementations that will run on most of them.<BR><BR>I think this may be an area that best performance and ease of use will <BR>be achieved either by supporting multiple standards or, alternatively, <BR>by doing some protocol design. For what Radiance does with its ambient <BR>data, MPI is may be overkill. Or maybe not; I'm not a parallel systems <BR>expert.<BR><BR>Randolph<BR><BR>MPI links:<BR>MPICH http://www-unix.mcs.anl.gov/mpi/mpich/<BR>MPICH for XP http://www.lfbs.rwth-aachen.de/mp-mpich/<BR>MPI forum http://www.mpi-forum.org/<BR>Standards documents annoying distributed in PostScript.<BR>There are various commercial implementations as well.<BR><BR>_______________________________________________<BR>Radiance-dev mailing list<BR>Radiance-dev@radiance-online.org<BR>http://www.radiance-online.org/mailman/listinfo/radiance-dev</BLOCKQUOTE>
--0-1216286439-1043649759=:13474--

From radiance-dev@radiance-online.org  Mon Jan 27 16:29:40 2003
From: radiance-dev@radiance-online.org (Georg Mischler)
Date: Mon, 27 Jan 2003 11:29:40 -0500 (EST)
Subject: [Radiance-dev] Re: multiprocessor systems, Radiance, and you
In-Reply-To: <3E303FA4.6010800@visarc.com>
Message-ID: <Pine.BSF.4.44.0301271123420.714-100000@emancholl.pair.com>

Looks like Greg was busy already with the ansification...
To make activities like this easier in the future, are there any
plans to make the sources available per CVS somewhere? I'm sure
that Sourceforge would be very happy to host it. Or are we still
waiting for the announced group of "advisors" to be selected?

Speaking of CVS, I remember Greg mentioning difficulties to
convert the old Radiance SCCS archives something more useful.
This might help:
  http://mail.gnu.org/archive/html/info-cvs/2002-03/msg00613.html
  http://www.gigascale.org/softdevel/faq/17.html


Jack de Valpine wrote:
>  Based on my understanding of the topic, it seems that
> there are several approaches that have been put on the table:

Nice and complete list, thanks!


> * file based locking:
>   * NFS - as currently implemented and with all the NFS related
>     issues
>   * Samba - I recall that Georg had mentioned this as a possibly
>     more reliable mechanism

The "Samba" keyword seemed to involve two seperate suggestions:

      * Transplant some custom locking code used in earlier samba
        versions into Radiance. Actually, this is just a specific
        example of a custom/homegrown solution.

      * Use the standard locking mechanisms on Windows, and have
        a Samba server translate that to unix (NFS-)locks where
        necessary. While this would eliminate the unix/Windows
        compatibility question, it doesn't solve the problems we
        still have between different unixes.
        I was in favour of this solution at one time, but only
        later realized that NFS locking is still not reliable on
        all platforms today.


>   * Custom - homegrown solution for locking files

I know that the mailman developers are using something like this,
which actually helps in running this mailing list here. If you
want a good scare, check out all the problems they ran into:
  http://www.google.com/search?q=+site:mail.python.org+mailman+locking


> * client/server - presumably a socket based client server mechanism
>   but not relying on pvm/mpi

This is by far my preferred solution, despite Greg apparently
being afraid of sockets... ;)  Client/server solutions over
sockets are one of the most universally supported concepts
nowadays, even if some vendors try to hide this fact behind
proprietary terminology.

It also looks like Carsten already has this implemented, although
his description so far hasn't made it completely clear whether
that depends on PVM or not. He wanted to be around again this
week to explain it better. A self contained version is obviously
preferrable, and I believe that it can be done with reasonable
effort.


> * pvm/mpi:

I think that we should treat multi-CPU parallelization and
ambient data sharing as two entirely seperate issues, as the
latter will have to work transparently across all versions and
platforms.


> * What are the implementation issues relating to doing a
>   client/server model vs. something like pvm/mpi, how much of the
>   guts of radiance need to be worked on for either option, what is
>   most robust, extensible and os dependant/independant

As far as I understand, there's a function that stores ambient
values into the file, and another one that retreives them again.
And that's already all of it that involves the "guts" of radiance.

Selecting a file based implementation for standalone operation,
or a networked one otherwise can be done at process startup, and
will be completely transparent to the actual simulation code.

I don't know whether it would be a good or bad idea to keep the
NFS lock based sharing mechanism in place for those people who
want to trust their lock manager. It's certainly not a technical
problem to do so. Maybe we can postpone this decision until we
actually have a working alternative.


-schorsch

-- 
Georg Mischler  --  simulations developer  --  schorsch at schorsch com
+schorsch.com+  --  lighting design tools  --  http://www.schorsch.com/


From radiance-dev@radiance-online.org  Mon Jan 27 17:35:52 2003
From: radiance-dev@radiance-online.org (Peter Apian-Bennewitz)
Date: Mon, 27 Jan 2003 18:35:52 +0100
Subject: [Radiance-dev] Re: multiprocessor systems, Radiance, and you
References: <Pine.BSF.4.44.0301271123420.714-100000@emancholl.pair.com>
Message-ID: <3E356DF8.F11E6FCC@pab-opto.de>

--------------785DAA4DB47CA83848A4EC7F
Content-Type: text/plain; charset=iso-8859-1
Content-Transfer-Encoding: base64

Hi,

> Looks like Greg was busy already with the ansification...
> To make activities like this easier in the future, are there any
> plans to make the sources available per CVS somewhere?

Yeap. CVS is coming on radiance-online.org .

> > * client/server - presumably a socket based client server mechanism
> >   but not relying on pvm/mpi
>
> This is by far my preferred solution, despite Greg apparently
> being afraid of sockets... ;)  Client/server solutions over
> sockets are one of the most universally supported concepts
> nowadays, even if some vendors try to hide this fact behind
> proprietary terminology.

I fully agree with my experience of writing a FhG-ISE-grown job
distribution system on HPUX/Linux/SunOS/IRIX, which uses plain socket UDP
and TCP connections. Probably even Microsoft offers a working socket
implementation.

BTW:  radiance-online.org  got a hardware RAID (Adaptec 2400a)  just
before christmas. It's now running on redundant IDE disks, optionally up
to 4x160GB RAID-5.

-Peter


--
 pab-opto, Freiburg, Germany, www.pab-opto.de



--------------785DAA4DB47CA83848A4EC7F
Content-Type: text/html; charset=us-ascii
Content-Transfer-Encoding: 7bit

<!doctype html public "-//w3c//dtd html 4.0 transitional//en">
<html>
Hi,
<blockquote TYPE=CITE>Looks like Greg was busy already with the ansification...
<br>To make activities like this easier in the future, are there any
<br>plans to make the sources available per CVS somewhere?</blockquote>
Yeap. CVS is coming on radiance-online.org .
<blockquote TYPE=CITE>> * client/server - presumably a socket based client
server mechanism
<br>>&nbsp;&nbsp; but not relying on pvm/mpi
<p>This is by far my preferred solution, despite Greg apparently
<br>being afraid of sockets... ;)&nbsp; Client/server solutions over
<br>sockets are one of the most universally supported concepts
<br>nowadays, even if some vendors try to hide this fact behind
<br>proprietary terminology.</blockquote>
I fully agree with my experience of writing a FhG-ISE-grown job distribution
system on HPUX/Linux/SunOS/IRIX, which uses plain socket UDP and TCP connections.
Probably even Microsoft offers a working socket implementation.
<p>BTW:&nbsp; radiance-online.org&nbsp; got a hardware RAID (Adaptec 2400a)&nbsp;
just before christmas. It's now running on redundant IDE&nbsp;disks, optionally
up to 4x160GB RAID-5.
<p>-Peter
<br>&nbsp;
<pre>--&nbsp;
&nbsp;pab-opto, Freiburg, Germany, www.pab-opto.de</pre>
&nbsp;</html>

--------------785DAA4DB47CA83848A4EC7F--


From radiance-dev@radiance-online.org  Mon Jan 27 20:51:18 2003
From: radiance-dev@radiance-online.org (Georg Mischler)
Date: Mon, 27 Jan 2003 15:51:18 -0500 (EST)
Subject: [Radiance-dev] Re: multiprocessor systems, Radiance, and you
In-Reply-To: <3E356DF8.F11E6FCC@pab-opto.de>
Message-ID: <Pine.BSF.4.44.0301271546330.714-100000@emancholl.pair.com>

Peter Apian-Bennewitz wrote:

> Yeap. CVS is coming on radiance-online.org.

Not sure why you'd want to replicate all the work that the
folks at sourceforge already offer for free (including a
multiplatform compile farm), but I'm not going to talk you
out of it... ;)


-schorsch

-- 
Georg Mischler  --  simulations developer  --  schorsch at schorsch com
+schorsch.com+  --  lighting design tools  --  http://www.schorsch.com/


From radiance-dev@radiance-online.org  Mon Jan 27 22:14:54 2003
From: radiance-dev@radiance-online.org (Peter Apian-Bennewitz)
Date: Mon, 27 Jan 2003 23:14:54 +0100
Subject: [Radiance-dev] Re: multiprocessor systems, Radiance, and you
References: <Pine.BSF.4.44.0301271546330.714-100000@emancholl.pair.com>
Message-ID: <3E35AF5E.5EF07597@pab-opto.de>

Georg Mischler wrote:
> 
> Peter Apian-Bennewitz wrote:
> 
> > Yeap. CVS is coming on radiance-online.org.
> 
> Not sure why you'd want to replicate all the work that the
> folks at sourceforge already offer for free (including a
> multiplatform compile farm), but I'm not going to talk you
> out of it... ;)

There won't be any ads and email addresses / profiles are not sold to
"non-affiliated third parties". Sourceforge wouldn't be the first "free"
service sliding senselessly ugly over time.

Maybe it's time for a little background info to all: Radiance-online.org
is a machine donated by me and located at "Fraunhofer Institute for
solar Energysystems" (http://www.ise.fraunhofer.de). Since both me and
they are engaged in Radiance, there's a solid interest in keeping the
thing running and extending it.
Furthermore, setting up a mirrored system between this site and LBNL's
radsite server would provide redundant access, although that is not
sorted out yet.

Technically I don't see a compile farm as big advantage: Who's going to
check the binaries (e.g. an ximage AIX version) in a productive
environment ? Checking for compile errors and include files is step 1,
as I'm sure you experienced too.
IMHO, porting to a new platform is most easily and effectively done by
someone with access to and experience of that platform. And if a larger
company is just dying to get a binary for a certain architecture that
none of us has access to, they very likely donate hardware to Greg.

If anyone "hears voices" urging him to participate in
radiance-online.org, e.g. by contributing examples, demo or organizing
features, he/she is warmly welcomed.

cheers
Peter

-- 
 pab-opto, Freiburg, Germany, www.pab-opto.de

From radiance-dev@radiance-online.org  Tue Jan 28 21:44:58 2003
From: radiance-dev@radiance-online.org (Carsten Bauer)
Date: Tue, 28 Jan 2003 22:44:58 +0100
Subject: [Radiance-dev] Re: multiprocessor systems, Radiance, and you
References: <Pine.BSF.4.44.0301271123420.714-100000@emancholl.pair.com>
Message-ID: <3E36F9DA.FEFEAC26@t-online.de>

Hi, Schorsch and others

> It also looks like Carsten already has this implemented, although
> his description so far hasn't made it completely clear whether
> that depends on PVM or not. He wanted to be around again this
> week to explain it better. A self contained version is obviously
> preferrable, and I believe that it can be done with reasonable
> effort.

sorry, I thought everything was clear already. Of course my stuff
depends completely on PVM. Unfortunately, right now I cannot spend much
time on Radinace-realted issues, due to various reasons, so I better not
engage too much in this discussion.

I don't understand the whole business anyway. As already mentioned,
complex renderings of big pictures needing the power of several machines
are no everyday task, so this shouldn't determine the requirements for a
basic version. Moreover, using a complete PP Library just for sharing
ambient values my indeed be judged as overkill, and as the 'gurus' (like
Rob uses to say) already have other things to offer, e.g. Sockets or
Samba, why not try this out.
 
Additionally, for a moment I was fond of combining Windows and Linux and
everything else, but I've made up my mind on this, who wants to
implement all the upcoming changes of every OS again and again and
again? From Windows 2000 to Windows X to Windows Me to Windows You to
Windows YouNoWho etc, etc. And furthermore, who is paying for that?

So I remembered Gregs words, posted several months ago - cit:
>Ewww.  Can't we just say that if you want to do parallel rendering, you 
>need to install Unix?

-Carsten

From radiance-dev@radiance-online.org  Thu Jan 30 18:56:34 2003
From: radiance-dev@radiance-online.org (Georg Mischler)
Date: Thu, 30 Jan 2003 13:56:34 -0500 (EST)
Subject: [Radiance-dev] Re: multiprocessor systems, Radiance, and you
In-Reply-To: <3E36F9DA.FEFEAC26@t-online.de>
Message-ID: <Pine.BSF.4.44.0301301343071.10440-100000@emancholl.pair.com>

Carsten Bauer wrote:

> Hi, Schorsch and others
>
> > It also looks like Carsten already has this implemented, although
> > his description so far hasn't made it completely clear whether
> > that depends on PVM or not. He wanted to be around again this
> > week to explain it better. A self contained version is obviously
> > preferrable, and I believe that it can be done with reasonable
> > effort.
>
> sorry, I thought everything was clear already. Of course my stuff
> depends completely on PVM.

I was uncertain whether that also included the client/server
communication, thanks for clarifying.  Is you code available
anywhere? Even if we're going to try to avoid PVM, your approach
of integration might still be interesting to look at for
inspiration.


I'm splicing the following in here, so that the topic remains in
one thread:

Greg wrote:

> On another note, I have been following with interest the discussion on
> parallel rendering solutions and alternatives to a working NFS lock
> manager.  I haven't responded because I haven't had anything
> intelligent to add...  It's sounding like the consensus is headed the
> direction of a socket-based client/server solution.  A dreadful pain to
> implement from all I've seen, but perhaps it's best in the long run.

I had a look at the ambient code from 3.4. The current file
access mechanics seem to be organized simple enough, so that a
switch to networked access will only require to replace/modify
three functions (and their children, of course). Making lookamb
network-aware would add another two. I'll have a closer look as
soon as the ANSIfied code is available per CVS. You can expect a
few questions after that to verify that I'm understanding
everything correctly.

On the client side, the networking code will be very simple:
- A new option  -an host[,port[,timeout]]
- Establish a socket connection on startup.
- Write new ambient values to that socket.
- Update the local ambient data from the socket.
This is almost identical to the current file based code, minus
locking (which is done by the server). We'll have to see if it is
worth the effort to "bundle" network transfers (only sync after a
certain number of new values have been created), which would
involve some more overhead.

On the server side, things may get a bit more involved. Since we
need to make sure that all accesses are sequential, asynchronous
operation through select() looks like the obvious choice.
Note that the server doesn't necessarily have to write the data
to a file, unless the user expects to stop and restart it later.
If it does use a file, then the existing code for that purpose
can be used with only minimal changes if any. NFS lock based
shared access on this file will *still* be possible, on those
platforms where that works.

I'm thinking of implementing the server in Python at first. This
will make it easy to experiment with different strategies wrt.
connection pool management, communication protocol, data caching,
and maybe even file locking mechanisms. It will also benefit from
the experience I have collected by writing the remote simulation
server that is included with Rayfront. Once we know what works
best, it will be possible to either declare the Python version
production ready, or to rewrite it in C. The latter is unlikely
to make it any more efficient, but may be desirable to reduce the
third party tool dependency.


-schorsch

-- 
Georg Mischler  --  simulations developer  --  schorsch at schorsch com
+schorsch.com+  --  lighting design tools  --  http://www.schorsch.com/


From radiance-dev@radiance-online.org  Thu Jan 30 20:07:19 2003
From: radiance-dev@radiance-online.org (Randolph Fritz)
Date: Thu, 30 Jan 2003 12:07:19 -0800
Subject: [Radiance-dev] Re: multiprocessor systems, Radiance, and you
In-Reply-To: <Pine.BSF.4.44.0301301343071.10440-100000@emancholl.pair.com>
References: <3E36F9DA.FEFEAC26@t-online.de> <Pine.BSF.4.44.0301301343071.10440-100000@emancholl.pair.com>
Message-ID: <20030130200718.GA27252@panix.com>

Would a broadcast solution be better, perhaps?  Some small server that
just repeatedly sends out the ambient file?  Or something a bit
fancier that doesn't involve TCP connections?

Randolph

From radiance-dev@radiance-online.org  Thu Jan 30 20:34:04 2003
From: radiance-dev@radiance-online.org (Georg Mischler)
Date: Thu, 30 Jan 2003 15:34:04 -0500 (EST)
Subject: [Radiance-dev] Re: multiprocessor systems, Radiance, and you
In-Reply-To: <20030130200718.GA27252@panix.com>
Message-ID: <Pine.BSF.4.44.0301301509510.10440-100000@emancholl.pair.com>

Randolph Fritz wrote:

> Would a broadcast solution be better, perhaps?  Some small server that
> just repeatedly sends out the ambient file?  Or something a bit
> fancier that doesn't involve TCP connections?


In theory, that sounds like a nice idea, but would require the
clients to accept data asynchronously (eg. while they're busy
with other calculations).  I'd prefer to keep the tricky parts
concentrated on the server side, so that the clients are only
confronted with new data when they explicitly ask for it.

The other thing is that broadcasts are only possible with UDP,
which doesn't garantee that the data is actually received by
anyone. If we want to make sure that all processes really have
the full set at any time, then there's no way around TCP.


-schorsch

-- 
Georg Mischler  --  simulations developer  --  schorsch at schorsch com
+schorsch.com+  --  lighting design tools  --  http://www.schorsch.com/


From radiance-dev@radiance-online.org  Thu Jan 30 21:34:15 2003
From: radiance-dev@radiance-online.org (Randolph Fritz)
Date: Thu, 30 Jan 2003 13:34:15 -0800
Subject: [Radiance-dev] Re: multiprocessor systems, Radiance, and you
In-Reply-To: <Pine.BSF.4.44.0301301509510.10440-100000@emancholl.pair.com>
Message-ID: <94D8CD34-349A-11D7-91FD-0030658EA95E@panix.com>

On Thursday, January 30, 2003, at 12:34  PM, Georg Mischler wrote:

> Randolph Fritz wrote:
>
>> Would a broadcast solution be better, perhaps?  Some small server that
>> just repeatedly sends out the ambient file?  Or something a bit
>> fancier that doesn't involve TCP connections?
>
>
> In theory, that sounds like a nice idea, but would require the
> clients to accept data asynchronously (eg. while they're busy
> with other calculations).  I'd prefer to keep the tricky parts
> concentrated on the server side, so that the clients are only
> confronted with new data when they explicitly ask for it.

Have a server app which makes broadcasts on a regular schedule--every 
100 ms or so and a very small client-side app which receives and stores 
the broadcasts.

> The other thing is that broadcasts are only possible with UDP,
> which doesn't garantee that the data is actually received by
> anyone. If we want to make sure that all processes really have
> the full set at any time, then there's no way around TCP.

You're just not sufficiently devious...when a client broadcasts a new 
value it marks it "new."  It waits to hear the value back from the 
watching server.  If it doesn't hear it in, say, 500 ms, it sends it 
again.

I'd like to avoid TCP; it is a very heavy protocol, and its use will 
set a limit on the number of clients--that's why NFS is not primarily 
TCP-based.

How many clients are we talking about, and how much data?

Randolph, knew that networking background had to be good for something


From radiance-dev@radiance-online.org  Thu Jan 30 22:42:02 2003
From: radiance-dev@radiance-online.org (Georg Mischler)
Date: Thu, 30 Jan 2003 17:42:02 -0500 (EST)
Subject: [Radiance-dev] Re: multiprocessor systems, Radiance, and you
In-Reply-To: <94D8CD34-349A-11D7-91FD-0030658EA95E@panix.com>
Message-ID: <Pine.BSF.4.44.0301301700330.10440-100000@emancholl.pair.com>

Randolph Fritz wrote:

> I'd like to avoid TCP; it is a very heavy protocol, and its use will
> set a limit on the number of clients-

Are you thinking about the limited number of file descriptors
that a process may have open on some systems? On my box, this is
currently at 1024, and I think it could be reconfigured if
necessary.


> How many clients are we talking about, and how much data?

There's no theoretical limit on the number of clients, even if we
may rarely see more than a few dozen (eg. for rendering a walk
through animation). Typical numbers will be 2 to 5. A full set of
ambient data for one simulation can exceed 100 MB, more common
sizes are in the range between 5-30 MB. Not really something you
want to broadcast repeatedly when there are cheaper alternatives.
You'd also unnecessarily flood all the channels of your switch
for hours at a time.

With the TCP approach, the full data will be transferred to each
client exactly once, and all the clients will send the full set
to the server once collectively. This is the same amount of
network traffic that is generated now, when you have the ambient
file sitting on a NFS mounted volume.


-schorsch

-- 
Georg Mischler  --  simulations developer  --  schorsch at schorsch com
+schorsch.com+  --  lighting design tools  --  http://www.schorsch.com/


From radiance-dev@radiance-online.org  Thu Jan 30 22:57:55 2003
From: radiance-dev@radiance-online.org (Randolph Fritz)
Date: Thu, 30 Jan 2003 14:57:55 -0800
Subject: [Radiance-dev] Re: multiprocessor systems, Radiance, and you
In-Reply-To: <94D8CD34-349A-11D7-91FD-0030658EA95E@panix.com>
References: <Pine.BSF.4.44.0301301509510.10440-100000@emancholl.pair.com> <94D8CD34-349A-11D7-91FD-0030658EA95E@panix.com>
Message-ID: <20030130225755.GA2037@panix.com>

On Thu, Jan 30, 2003 at 01:34:15PM -0800, Randolph Fritz wrote:
> On Thursday, January 30, 2003, at 12:34  PM, Georg Mischler wrote:
> >
> >In theory, that sounds like a nice idea, but would require the
> >clients to accept data asynchronously (eg. while they're busy
> >with other calculations).  I'd prefer to keep the tricky parts
> >concentrated on the server side, so that the clients are only
> >confronted with new data when they explicitly ask for it.
> 

[...first-cut complicated solution clipped...]

If we can assume a shared file system, there's a simpler way.

Have one ambient server app that writes the shared file.  The server
receives data via UDP from the various renderers, and adds it to the
file.  (Is conflicting data an issue?  How best for the server to
resolve it?)  Every time the renderers read the file they check to
make sure the items they sent are in it; if they're not, they resend
them.

Error handling & network management:

  - I recommend that renderers keep a timer, and if the server does
    not see ambient file updates in some operator-determined period of
    time, raise an alarm.  (The operator-determined time because it
    depends on network and filesystem latency.)

  - I believe the ambient updater itself could be best organized as a
    monitor and an updater process; if the updater fails, the monitor
    can restart it and if several attempts at restarting fail quickly,
    the monitor can raise an alarm.  In a large MP environment it
    might be best to have the monitor and updater on separate systems.
    (The monitor process might also start and stop renderers.)

  - The updater can publish its UDP port and a 64-bit random magic
    number via a file, which is protected (or not) via the file
    permissions system.  The updater only accepts ambient value
    packets which have a valid magic number.  This provides a measure
    of security.  It would perhaps be best for the random magic number
    to be updated every few minutes.

I like this proposal, but I am not a Radiance expert.  What do you-all
think?

Randolph


From radiance-dev@radiance-online.org  Thu Jan 30 23:08:16 2003
From: radiance-dev@radiance-online.org (Randolph Fritz)
Date: Thu, 30 Jan 2003 15:08:16 -0800
Subject: [Radiance-dev] Re: multiprocessor systems, Radiance, and you
In-Reply-To: <Pine.BSF.4.44.0301301700330.10440-100000@emancholl.pair.com>
References: <94D8CD34-349A-11D7-91FD-0030658EA95E@panix.com> <Pine.BSF.4.44.0301301700330.10440-100000@emancholl.pair.com>
Message-ID: <20030130230816.GA7157@panix.com>

On Thu, Jan 30, 2003 at 05:42:02PM -0500, Georg Mischler wrote:
> Randolph Fritz wrote:
> 
> > I'd like to avoid TCP; it is a very heavy protocol, and its use will
> > set a limit on the number of clients-
> 
> Are you thinking about the limited number of file descriptors
> that a process may have open on some systems? On my box, this is
> currently at 1024, and I think it could be reconfigured if
> necessary.
> 

It's more the network and processor overhead of TCP, though the
limited number of file descriptors was once a problem.  I don't think
a single app could ever really manage 1024 simultaneous TCP
connections on most systems, except for the big IBM servers.

> 
> There's no theoretical limit on the number of clients, even if we
> may rarely see more than a few dozen (eg. for rendering a walk
> through animation). Typical numbers will be 2 to 5. A full set of
> ambient data for one simulation can exceed 100 MB, more common
> sizes are in the range between 5-30 MB. Not really something you
> want to broadcast repeatedly when there are cheaper alternatives.
> You'd also unnecessarily flood all the channels of your switch
> for hours at a time.
> 

No, broadcasting the whole thing would definitely not be the way to go.

> With the TCP approach, the full data will be transferred to each
> client exactly once, and all the clients will send the full set
> to the server once collectively. This is the same amount of
> network traffic that is generated now, when you have the ambient
> file sitting on a NFS mounted volume.

I think you may be underestimating the problem of recovery from
dropped connections, downed processors, and so on.

Randolph

From radiance-dev@radiance-online.org  Fri Jan 31 13:03:22 2003
From: radiance-dev@radiance-online.org (Georg Mischler)
Date: Fri, 31 Jan 2003 08:03:22 -0500 (EST)
Subject: [Radiance-dev] Re: multiprocessor systems, Radiance, and you
In-Reply-To: <20030130225755.GA2037@panix.com>
Message-ID: <Pine.BSF.4.44.0301310752540.25524-100000@emancholl.pair.com>

Randolph Fritz wrote:

> It's more the network and processor overhead of TCP, though the
> limited number of file descriptors was once a problem.

I understand that TCP has a much higher overhead than UDP. But is
this really significant compared to the processing that we
already do with Radiance? Five times very little may still not
be much, after all...


> I don't think
> a single app could ever really manage 1024 simultaneous TCP
> connections on most systems, except for the big IBM servers.

The sockets as such are not a problem, but the polling (even when
done by the OS through select()) will become a bit less efficient
eventually. This article talks about an example implemented in
Python on PC hardware:
  http://www.nightmare.com/medusa/async_tweaks.html


> I think you may be underestimating the problem of recovery from
> dropped connections, downed processors, and so on.

We're not handling life support systems here, are we? ;)

The server doesn't really care about individual client
connections. Even if the server dies and restarts, it would be
possible for the clients to try to reconnect a few times within
reasonable intervals.


> If we can assume a shared file system, there's a simpler way.
>
> Have one ambient server app that writes the shared file.  The server
> receives data via UDP from the various renderers, and adds it to the
> file.  (Is conflicting data an issue?  How best for the server to
> resolve it?)  Every time the renderers read the file they check to
> make sure the items they sent are in it; if they're not, they resend
> them.

Interesting idea. Now you see why I want to implement the server
in Python at first, so we can play with various concepts and see
which behaves best under load on all platforms.

Conflicting data are not a problem, at least not one that is
specific to this setup. Those are also written to the same file
by the traditional sharing method.

My initial reflex was to use the same (TCP) channel for both
directions, but you're right that this isn't really necessary.
The simulation jobs need file system access to lots of common
data anyway, so there's no reason why the ambient server should
be excluded from that. That way, the reading channel is secured
against packet loss by NFS.

This leaves us with the choice of UDP or TCP for collecting the
data. The final solution will have to balance the overhead of TCP
against the inherent unreliability of UDP.

If an UDP packet with ambient data for storage is dropped, the
consequence is simply that those spefic values will be missing in
the file. Another process that later checks for them will not find
anything, and therefore has to do the same calculation again, or
at least a very similar one. This means that any dropped packets
will cause the overall computation time to go up, whether they
are caused by network congestion or by the server temporarily
going offline. We'll have to test what happens when increasing
numbers of packets get dropped (1%, 5%, etc.), but I don't expect
any problems besides the wasted time (Greg?).

If we use TCP, then we know that no packets are lost, or rather
we'll know when it happens. The clients will first block if the
server doesn't answer, and after a while the connection may be
declared dead. This would give us some primitive built-in
monitoring right at the place where this information is needed,
without introducing yet another process.

I don't want to make any predictions at the moment about which
method will me more efficient in practise. It won't take much to
implement both of them, and then we'll have to ask people to run
lots of tests under heavy load.


>   - I recommend that renderers keep a timer, and if the server does
>     not see ambient file updates in some operator-determined period of
>     time, raise an alarm.  (The operator-determined time because it
>     depends on network and filesystem latency.)

I'm not sure what problem you're trying to solve here. Ambient
data updates can get rather sparse towards the end of a
simulation anyway, so that their frequency isn't really a good
indicator of anything.


>   - I believe the ambient updater itself could be best organized as a
>     monitor and an updater process;

I don't think that job management concepts are within the
functional scope of core Radiance. Stuff like that can be easily
added from other sources.


>   - The updater can publish its UDP port and a 64-bit random magic

Let's worry about security once the functionality as such works.
It will be trivial to have the server only accept packets from
the local IP range, and you should have a firewall in front of
your network in any case.


-schorsch

-- 
Georg Mischler  --  simulations developer  --  schorsch at schorsch com
+schorsch.com+  --  lighting design tools  --  http://www.schorsch.com/


From radiance-dev@radiance-online.org  Fri Jan 31 17:10:18 2003
From: radiance-dev@radiance-online.org (Greg Ward)
Date: Fri, 31 Jan 2003 09:10:18 -0800
Subject: [Radiance-dev] Re: multiprocessor systems, Radiance, and you
In-Reply-To: <20030131110002.22226.88618.Mailman@darkside-animation.com>
Message-ID: <DFBC1032-353E-11D7-91A0-00306540F848@lmi.net>

Hi Guys,

This whole conversation is getting way too complicated for my tastes.  
Can't we find a simpler solution?  The whole client/server model sounds 
really nasty -- who starts the server?  What happens if the server dies 
or gets overwhelmed?  How portable will it be between architectures?  
All these things make me nervous.

What if we try to stay closer to the current model, just modifying it 
so it doesn't depend on an NFS lock manager.  Here's what I suggest:

1) Instead of calling fcntl with F_SETLKW, each ambient process 
periodically checks for the existence of a lock file on the NFS 
filesystem (named after the ambient file perhaps with an added suffix 
".lok").

2a) If the lock file exists, we continue rendering until a later 
checkpoint.

2b) If the lock file doesn't exist, we create it with open(...O_EXCL).  
We then have full control over the ambient file to read in the new 
values from other processes and write our values to it.  Afterwards, we 
remove the lock file.

The only difference between this and what's currently in ambient.c is 
that we use the lock file with open() and unlink() to control access, 
and buffer as many values as necessary until the lock is available.  
(Right now, the process will block after a certain accumulation and not 
unblock until it obtains the lock.)

-Greg

P.S.  I took some flack for my apparent lack of knowledge regarding C 
pointer arithmetic after the last post.  So I screwed up!  At least I 
eventually figured out that I screwed up -- don't I get some credit for 
that?  I didn't think the error was so obvious, myself.

P.P.S.
>> char    **avp1, **avp2;
>
> I hope you're using pointers to void in the ANSI version... ;)
>
> -schorsch

You may be disappointed when you first see the new ANSI version.  My 
goal was to get the libraries to a state where other people could call 
them with the benefits of function prototypes.  I didn't go into all 
the various modules and programs and make sure that the local functions 
all had prototypes as well.  Only the code in the src/common and src/rt 
directories got treated -- I pretty well left the rest alone, except to 
make sure it was happy with the new library prototypes, and didn't go 
declaring standard library functions, itself.  Internal static 
functions pretty much never got prototyped, as gcc (and other C 
compilers) don't pick on you if you use the old K&R style of function 
definitions:

type call(a1, a1) type a1, a2; {...}

Thus, the comparison function passed to qsort doesn't get its 
parameters examined.  If someone wants to go in and add all the correct 
parameter lists and casts everywhere, they're welcomed to do so once we 
get CVS up and running.  Frankly, I think it's a waste of time that 
could be better spent, and it only increases the chances of errors.  I 
found exactly 0 bugs in Radiance by adding the prototypes I added, and 
caused two or three in the process, which took me a while to ferret 
out....


From radiance-dev@radiance-online.org  Fri Jan 31 17:16:39 2003
From: radiance-dev@radiance-online.org (Greg Ward)
Date: Fri, 31 Jan 2003 09:16:39 -0800
Subject: [Radiance-dev] P.S. to my last P.S.
In-Reply-To: <20030131110002.22226.88618.Mailman@darkside-animation.com>
Message-ID: <C2E87024-353F-11D7-91A0-00306540F848@lmi.net>

I remember now, I did find one bug during ANSI-fication -- a call to my 
own error() function, which was missing the first parameter.  Since it 
never got called in any of my runs, the bug never manifested.  
Prototypes can be useful -- I won't argue that!


From radiance-dev@radiance-online.org  Fri Jan 31 20:22:27 2003
From: radiance-dev@radiance-online.org (Georg Mischler)
Date: Fri, 31 Jan 2003 15:22:27 -0500 (EST)
Subject: [Radiance-dev] Re: multiprocessor systems, Radiance, and you
In-Reply-To: <DFBC1032-353E-11D7-91A0-00306540F848@lmi.net>
Message-ID: <Pine.BSF.4.44.0301311514470.25524-100000@emancholl.pair.com>

Greg Ward wrote:

> This whole conversation is getting way too complicated for my tastes.
> Can't we find a simpler solution?  The whole client/server model sounds
> really nasty --

At this time I'm still convinced that it's the most reliable and
portable way to solve the problem at hand.


> who starts the server?

Who starts simulations on remote systems as it is now?
As long as your processes all run on the same machine, no ambient
server is necessary, and eg. rpiece will continue to work just
fine. After all, we're not going to take the current file sharing
functionality away. We'll just experiment with additional options
that are less vulnerable to OS bugs and other platform issues.

Once you run jobs on more than one machine, you need to start
them manually (or through scripts/other tools) anyway, even if
you use rpiece. So on that front, nothing will really change.

Thinking of it, the server might also be useful to coordinate
the rpiece processes, removing yet another NFS lock dependency.


> What happens if the server dies or gets overwhelmed?

Probably the same that happens now when the NFS server reboots
or the network clogs. The individual simulation processes will
stall, until the server is available again.


> How portable will it be between architectures?
> All these things make me nervous.

Sockets are fully portable across all platforms that Radiance
currently supports, and then some.


> What if we try to stay closer to the current model, just modifying it
> so it doesn't depend on an NFS lock manager.  Here's what I suggest:
>
> 1) Instead of calling fcntl with F_SETLKW, each ambient process
> periodically checks for the existence of a lock file on the NFS
> filesystem (named after the ambient file perhaps with an added suffix
> ".lok").

And you think sockets are nasty?

One of the few things that I know about lockfiles is that they're
not exactly simple to get right.

- What happens if the lockfile owner gets killed?
  Will the others be able to figure out that the lock file is
  stale and override it? Or will that require human intervention?
  I think that NFS locks get purged when the owner dies, so we
  might lose quite some convenience here.

- What happens process b checks for the file after process a
  does, but before process a actually creates the new file?

There's no way to make checking and creating an atomic operation,
so that this situation must be handled explicitly and gracefully.
In a big simulation, it may well be that a dozen processes are
competing for the lock file several times a second for hours or
even days. Race conditions *will* happen.

I'm not saying that it can't be done. But in the best case, I'd
expect a foolprof solution to be similarly involved and complex,
but less portable as using a server process.

Since I'm familiar with client/server concepts, I'm willing to
implement one. If anyone volunteers to design a reliable file
based solution, I'm certainly not objecting to having that
available as an alternative option. In fact, I'd be happy to see
as many synchronization methods as possible implemented, so we
can test them all. And after we know what works, we can leave the
best two or three in the core distribution, for the user to
select the one that is most appropriate in their environment.


> P.S.  I took some flack for my apparent lack of knowledge regarding C
> pointer arithmetic after the last post.  So I screwed up!  At least I
> eventually figured out that I screwed up -- don't I get some credit for
> that?  I didn't think the error was so obvious, myself.

It was certainly one of a rare breed. Not many people dare to
juggle with pointers as you do... ;)


>   I didn't go into all
> the various modules and programs and make sure that the local functions
> all had prototypes as well.

That's probably the way I would have started as well. I didn't
really expect you to declare victory so soon. Good to know that
you're not superhuman either... ;)


>  If someone wants to go in and add all the correct
> parameter lists and casts everywhere, they're welcomed to do so once we
> get CVS up and running.

Compiling on Windows (at least with VC) is a pain without
prototypes, as the real errors get drowned in all the warnings.
So I may end up converting them along the way when trying to
establish cross-platform compatibility.


> I remember now, I did find one bug during ANSI-fication

One down, n to go... ;)
If I understand you correctly, then you only converted a few
percent of the code, so that finding more than one or two would
have been quite a surprise.


-schorsch

-- 
Georg Mischler  --  simulations developer  --  schorsch at schorsch com
+schorsch.com+  --  lighting design tools  --  http://www.schorsch.com/


From radiance-dev@radiance-online.org  Fri Jan 31 23:36:38 2003
From: radiance-dev@radiance-online.org (Randolph Fritz)
Date: Fri, 31 Jan 2003 15:36:38 -0800
Subject: [Radiance-dev] Re: multiprocessor systems, Radiance, and you
In-Reply-To: <Pine.BSF.4.44.0301310752540.25524-100000@emancholl.pair.com>
References: <20030130225755.GA2037@panix.com> <Pine.BSF.4.44.0301310752540.25524-100000@emancholl.pair.com>
Message-ID: <20030131233638.GA26441@panix.com>

On Fri, Jan 31, 2003 at 08:03:22AM -0500, Georg Mischler wrote:
> 
> If an UDP packet with ambient data for storage is dropped, the
> consequence is simply that those spefic values will be missing in
> the file.  Another process that later checks for them will not find
> anything, and therefore has to do the same calculation again, or at
> least a very similar one.
>

Why not have any process that sends an ambient value check for its
presence the next time it reads the ambient file and resend it if it's
not there?  If, due to network latency, the value is sent twice, the
server can simply ignore it, without any harm done.

> 
> >   - I recommend that renderers keep a timer, and if the server does
> >     not see ambient file updates in some operator-determined period of
> >     time, raise an alarm.  (The operator-determined time because it
> >     depends on network and filesystem latency.)
> 
> I'm not sure what problem you're trying to solve here. 
> 

Duh.  Meant "renderer," not server.  A check to make sure the
renderer's ambient values are actually getting into the shared ambient
file.  If this isn't happenning, operator attention is needed.

> 
> >   - I believe the ambient updater itself could be best organized as a
> >     monitor and an updater process;
> 
> I don't think that job management concepts are within the
> functional scope of core Radiance.
>

I suppose.  But that would be my preferred solution in a Unix
environment; the ambient value update server has to be incredibly
reliable, or we'll be hearing complaints about it forever.  It may not
be life-critical, but it sure can be career-critical!

> 
> >   - The updater can publish its UDP port and a 64-bit random magic
> 
> Let's worry about security once the functionality as such works.

Publishing the port solves the problem of communicating the IP address
and port number of the ambient file update server to the clients
without assigning an arbitrary port number, which is not reliable,
since only services listed in RFC whatever are assured of getting
their assigned ports.  One gets the slightly greater security of the
magic number for very little extra effort.

You're just not devious enough.

> It will be trivial to have the server only accept packets from
> the local IP range, and you should have a firewall in front of
> your network in any case.

Within a large network, one is likely to have at security problems
from inside the firewall; it's best to address them early on.

Randolph

From radiance-dev@radiance-online.org  Fri Jan 31 23:44:47 2003
From: radiance-dev@radiance-online.org (Randolph Fritz)
Date: Fri, 31 Jan 2003 15:44:47 -0800
Subject: [Radiance-dev] Re: multiprocessor systems, Radiance, and you
In-Reply-To: <DFBC1032-353E-11D7-91A0-00306540F848@lmi.net>
References: <20030131110002.22226.88618.Mailman@darkside-animation.com> <DFBC1032-353E-11D7-91A0-00306540F848@lmi.net>
Message-ID: <20030131234447.GB26441@panix.com>

On Fri, Jan 31, 2003 at 09:10:18AM -0800, Greg Ward wrote:
> 
> This whole conversation is getting way too complicated for my tastes.  
> Can't we find a simpler solution?  The whole client/server model sounds 
> really nasty -- who starts the server?  What happens if the server dies 
> or gets overwhelmed?  How portable will it be between architectures?  
> All these things make me nervous.
> 

1. The operator does have to start the server.

2. The proposed servers are very very simple, and leverage existing
   technology.  TCP and UDP are well-defined, and so are sockets.
   There's some file sharing technology on every server.

   In my proposal, I specified a watchdog process for the server
   process; with fork()/exec() that's simple on any Unix-derived
   system--I believe it will also work under Cygwin.  For MS-Windows
   an alternate solution would have to be developed, but since the
   proposed servers are very simple--they just replace the current
   locking mechanism with a single writer process--I think most of the
   code can be common.

3. All the protcols we're discussing are very very very standard and
   portable.

> 1) Instead of calling fcntl with F_SETLKW, each ambient process 
> periodically checks for the existence of a lock file on the NFS 
> filesystem (named after the ambient file perhaps with an added suffix 
> ".lok").

I'm not sure that mechanism can be made atomic over NFS--need to
check.  Bet it isn't on MS-Windows at all.  :-(


