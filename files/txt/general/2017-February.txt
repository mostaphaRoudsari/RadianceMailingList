From m.borsa at elioth.fr  Wed Feb  1 06:03:59 2017
From: m.borsa at elioth.fr (BORSA Micol)
Date: Wed, 1 Feb 2017 14:03:59 +0000
Subject: [Radiance-general] genBSDF
Message-ID: <7FDADFC6AA972943ABBBBC12624203FA99BAE9@SQYXCHW2K14.egis.racine.local>

Hello,
I?m new to Radiance and I?m trying to use genBSDF in order to obtain the optical properties of a complex solar screen.
The problem is that when I try to launch the program from the command prompt this message appears:

?rfluxmtx is not recognized as internal command or external, an executable program or a command file. Failure running rfluxmtx at script/genBSDF.pl line 416?

I really don?t know what to do and I hope someone can advise me.
I?m working on Windows 7 and with genBSDF.exe.

Thanks a lot

Micol


________________________________
Ce message et ses pi?ces jointes peuvent contenir des informations confidentielles ou privil?gi?es et ne doivent donc pas ?tre diffus?s, exploit?s ou copi?s sans autorisation. Si vous avez re?u ce message par erreur, merci de le signaler ? l'exp?diteur et le d?truire ainsi que les pi?ces jointes. Les messages ?lectroniques ?tant susceptibles d'alt?ration, Egis d?cline toute responsabilit? si ce message a ?t? alt?r?, d?form? ou falsifi?. Merci.

This message and its attachments may contain confidential or privileged information that may be protected by law; they should not be distributed, used or copied without authorisation. If you have received this email in error, please notify the sender and delete this message and its attachments. As emails may be altered, Egis is not liable for messages that have been modified, changed or falsified. Thank you.
________________________________
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://www.radiance-online.org/pipermail/radiance-general/attachments/20170201/26d9220e/attachment.html>

From germolinal at gmail.com  Thu Feb  2 08:38:57 2017
From: germolinal at gmail.com (=?UTF-8?Q?Germ=C3=A1n_Molina_Larrain?=)
Date: Thu, 2 Feb 2017 13:38:57 -0300
Subject: [Radiance-general] genBSDF
In-Reply-To: <7FDADFC6AA972943ABBBBC12624203FA99BAE9@SQYXCHW2K14.egis.racine.local>
References: <7FDADFC6AA972943ABBBBC12624203FA99BAE9@SQYXCHW2K14.egis.racine.local>
Message-ID: <CAF-iH4LG4ZzO41_qC=oHY0AtF6A8yKNGujb86x+YJB_Mg9nyzw@mail.gmail.com>

Hello Micol,

What happens when you try to run RFLUXMTX outside genBSDF? Do you get the
same message? If that is so, you probably need to reset your PATH variable,
to include the directory where Radiance programs are installed.

Let me know if it works!

2017-02-01 11:03 GMT-03:00 BORSA Micol <m.borsa at elioth.fr>:

> Hello,
>
> I?m new to Radiance and I?m trying to use genBSDF in order to obtain the
> optical properties of a complex solar screen.
>
> The problem is that when I try to launch the program from the command
> prompt this message appears:
>
>
>
> ?rfluxmtx is not recognized as internal command or external, an executable
> program or a command file. Failure running rfluxmtx at script/genBSDF.pl
> line 416?
>
>
>
> I really don?t know what to do and I hope someone can advise me.
>
> I?m working on Windows 7 and with genBSDF.exe.
>
>
>
> Thanks a lot
>
>
>
> Micol
>
>
>
>
> ------------------------------
> Ce message et ses pi?ces jointes peuvent contenir des informations
> confidentielles ou privil?gi?es et ne doivent donc pas ?tre diffus?s,
> exploit?s ou copi?s sans autorisation. Si vous avez re?u ce message par
> erreur, merci de le signaler ? l'exp?diteur et le d?truire ainsi que les
> pi?ces jointes. Les messages ?lectroniques ?tant susceptibles d'alt?ration,
> Egis d?cline toute responsabilit? si ce message a ?t? alt?r?, d?form? ou
> falsifi?. Merci.
>
> This message and its attachments may contain confidential or privileged
> information that may be protected by law; they should not be distributed,
> used or copied without authorisation. If you have received this email in
> error, please notify the sender and delete this message and its
> attachments. As emails may be altered, Egis is not liable for messages that
> have been modified, changed or falsified. Thank you.
> ------------------------------
>
> _______________________________________________
> Radiance-general mailing list
> Radiance-general at radiance-online.org
> http://www.radiance-online.org/mailman/listinfo/radiance-general
>
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://www.radiance-online.org/pipermail/radiance-general/attachments/20170202/a62c6ba4/attachment-0001.html>

From geotrupes at me.com  Thu Feb  2 09:19:53 2017
From: geotrupes at me.com (Giulio Antonutto)
Date: Thu, 02 Feb 2017 17:19:53 +0000
Subject: [Radiance-general] DEM to .rad pipeline
In-Reply-To: <CAFPP+oKiS=Yzw6s-paROSRaf+B=_67yD1PP9sLXOXsJ149i_Ng@mail.gmail.com>
References: <CAFPP+oKiS=Yzw6s-paROSRaf+B=_67yD1PP9sLXOXsJ149i_Ng@mail.gmail.com>
Message-ID: <19926BC6-6F91-4C9B-ABA9-A27566533ED3@me.com>

Best is save to an obj file and then import as mesh with obj2mesh
G.

> On 31 Jan 2017, at 22:36, Ian Seiferling <ianseifs at gmail.com> wrote:
> 
> I am very new to radiance and thus this may come across as a novice or naive question. I hope to use radiance to model daylight on exterior surfaces. The geometry I work with are DEMs typically coming in raster (geotiff) format. 
> 

-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://www.radiance-online.org/pipermail/radiance-general/attachments/20170202/0d584959/attachment.html>

From giuseppe.peronato at epfl.ch  Thu Feb  2 12:36:04 2017
From: giuseppe.peronato at epfl.ch (Giuseppe Peronato)
Date: Thu, 2 Feb 2017 20:36:04 +0000
Subject: [Radiance-general] Radiance-general Digest, Vol 156, Issue 2
In-Reply-To: <mailman.1.1486065600.50352.radiance-general@radiance-online.org>
References: <mailman.1.1486065600.50352.radiance-general@radiance-online.org>
Message-ID: <514E22C3-65AD-4DD2-9065-FF577C494421@epfl.ch>

Hi Giulio,

You probably want to create a mesh out of the raster model and then save it to obj as suggested by Greg.
You can use Rhino3D for that. Rhino can import xyz files (you can use the GDAL library for converting the tiff to xyz) and create a mesh from 3D points using the command meshpatch.
Hope this helps.

Giuseppe

> Message: 1
> Date: Thu, 02 Feb 2017 17:19:53 +0000
> From: Giulio Antonutto <geotrupes at me.com>
> To: Radiance general discussion <radiance-general at radiance-online.org>
> Subject: Re: [Radiance-general] DEM to .rad pipeline
> Message-ID: <19926BC6-6F91-4C9B-ABA9-A27566533ED3 at me.com>
> Content-Type: text/plain; charset="us-ascii"
> 
> Best is save to an obj file and then import as mesh with obj2mesh
> G.
> 
>> On 31 Jan 2017, at 22:36, Ian Seiferling <ianseifs at gmail.com> wrote:
>> 
>> I am very new to radiance and thus this may come across as a novice or naive question. I hope to use radiance to model daylight on exterior surfaces. The geometry I work with are DEMs typically coming in raster (geotiff) format. 
>> 
> 
> -------------- next part --------------
> An HTML attachment was scrubbed...
> URL: <http://www.radiance-online.org/pipermail/radiance-general/attachments/20170202/0d584959/attachment-0001.html>
> 
> ------------------------------
> 



From gward at lmi.net  Thu Feb  2 13:15:32 2017
From: gward at lmi.net (Greg Ward)
Date: Thu, 2 Feb 2017 13:15:32 -0800
Subject: [Radiance-general] Radiance-general Digest, Vol 156, Issue 2
In-Reply-To: <514E22C3-65AD-4DD2-9065-FF577C494421@epfl.ch>
References: <mailman.1.1486065600.50352.radiance-general@radiance-online.org>
 <514E22C3-65AD-4DD2-9065-FF577C494421@epfl.ch>
Message-ID: <7A0EAB92-4D05-4FAA-A839-9DBB535BE50C@lmi.net>

You can also use gensurf to load height data and convert it to .OBJ format using the -o option.  From there, obj2mesh creates a Radiance triangle mesh as Giulio suggested. 

Cheers,
-Greg

> On Feb 2, 2017, at 12:36 PM, Giuseppe Peronato <giuseppe.peronato at epfl.ch> wrote:
> 
> Hi Giulio,
> 
> You probably want to create a mesh out of the raster model and then save it to obj as suggested by Greg.
> You can use Rhino3D for that. Rhino can import xyz files (you can use the GDAL library for converting the tiff to xyz) and create a mesh from 3D points using the command meshpatch.
> Hope this helps.
> 
> Giuseppe
> 
>> Message: 1
>> Date: Thu, 02 Feb 2017 17:19:53 +0000
>> From: Giulio Antonutto <geotrupes at me.com>
>> To: Radiance general discussion <radiance-general at radiance-online.org>
>> Subject: Re: [Radiance-general] DEM to .rad pipeline
>> Message-ID: <19926BC6-6F91-4C9B-ABA9-A27566533ED3 at me.com>
>> Content-Type: text/plain; charset="us-ascii"
>> 
>> Best is save to an obj file and then import as mesh with obj2mesh
>> G.
>> 
>>> On 31 Jan 2017, at 22:36, Ian Seiferling <ianseifs at gmail.com> wrote:
>>> 
>>> I am very new to radiance and thus this may come across as a novice or naive question. I hope to use radiance to model daylight on exterior surfaces. The geometry I work with are DEMs typically coming in raster (geotiff) format.



From stephanie at dosu-arch.com  Mon Feb  6 18:03:19 2017
From: stephanie at dosu-arch.com (Stephanie Truong)
Date: Mon, 06 Feb 2017 18:03:19 -0800
Subject: [Radiance-general] Formatting Geometry in Rhino to use genBSDF
Message-ID: <09a68e2348de431aa7dbcfb2ed6df2ba@dosu-arch.com>

Hi, 

I am attempting to run genBSDF, and was wondering if there is a workflow
that allows the use of Rhino/NURBs geometry to convert into MGF format?
Ultimately, I am trying to create a BSDF.xml file of a complex shading
system. The system is made up of small units which are doubly curved,
gradated (depending on orientation to the sun), and symmetrical on one
axis. I am unsure if the MGF format is able to model that type of
geometry, so it would be helpful to understand how to model geometry to
input into the genBSDF command. Let me know if I need to clarify or
provide more information. I'm relatively new at this, and any help would
be appreciated!  

Thank you in advance,

Stephanie Truong
DOSU | studio architecture
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://www.radiance-online.org/pipermail/radiance-general/attachments/20170206/7773c204/attachment.html>

From germolinal at gmail.com  Mon Feb  6 19:21:20 2017
From: germolinal at gmail.com (=?UTF-8?Q?Germ=C3=A1n_Molina_Larrain?=)
Date: Tue, 7 Feb 2017 00:21:20 -0300
Subject: [Radiance-general] Formatting Geometry in Rhino to use genBSDF
In-Reply-To: <09a68e2348de431aa7dbcfb2ed6df2ba@dosu-arch.com>
References: <09a68e2348de431aa7dbcfb2ed6df2ba@dosu-arch.com>
Message-ID: <CAF-iH4LfLp89TH+Zc_C6TjisG4q28HGZ1xDPuYhdV=tExwFoyw@mail.gmail.com>

Hello Stephanie,

First, I want to clarify that genBSDF uses Radiance format as input, which
is not the same as MGF. Actually, MGF is a format with some really cool
features, but rarely used (unfortunately?).

Anyways... Any tool that exports Radiance or MGF formated geometry (which
is also readable by Radiance) is useful for generating input for genBSDF.
That said, I do not use Rhino, but probably DIVA and Honey Bee or Ladybug
can help you on that. Otherwise, there are some SketchUp plugins for
exporting Radiance geometry,  which is a tool that allows importing several
3D formats. Finally, I have read several times about Radiance using .OBJ
through obj2rad program. I understand that this format is also common, but
not suited to model physically realistic materials.

So... I think you have several choices. I am pretty sure all these formats
are able to model any required geometry, and that the choice you make will
be a matter of how easy is to "draw" it.

Regarding how to input this geometry into genBSDF, you have to place the
width of your "window" along the X axis, Height along the Y axis and inside
is towards Z axis (i.e. Up). Any geometry over the Z axis is inside the
space and will emit a warning. Read the tutorials for more information on
this!

I hope it helps

best,

Germ?n

El 6 feb. 2017 23:07, "Stephanie Truong" <stephanie at dosu-arch.com> escribi?:

Hi,

I am attempting to run genBSDF, and was wondering if there is a workflow
that allows the use of Rhino/NURBs geometry to convert into MGF format?
Ultimately, I am trying to create a BSDF.xml file of a complex shading
system. The system is made up of small units which are doubly curved,
gradated (depending on orientation to the sun), and symmetrical on one
axis. I am unsure if the MGF format is able to model that type of geometry,
so it would be helpful to understand how to model geometry to input into
the genBSDF command. Let me know if I need to clarify or provide more
information. I'm relatively new at this, and any help would be appreciated!


Thank you in advance,
Stephanie Truong
DOSU | studio architecture


_______________________________________________
Radiance-general mailing list
Radiance-general at radiance-online.org
http://www.radiance-online.org/mailman/listinfo/radiance-general
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://www.radiance-online.org/pipermail/radiance-general/attachments/20170207/b34b41e8/attachment.html>

From gregoryjward at gmail.com  Mon Feb  6 21:20:56 2017
From: gregoryjward at gmail.com (Greg Ward)
Date: Mon, 6 Feb 2017 21:20:56 -0800
Subject: [Radiance-general] Formatting Geometry in Rhino to use genBSDF
In-Reply-To: <CAF-iH4LfLp89TH+Zc_C6TjisG4q28HGZ1xDPuYhdV=tExwFoyw@mail.gmail.com>
References: <09a68e2348de431aa7dbcfb2ed6df2ba@dosu-arch.com>
 <CAF-iH4LfLp89TH+Zc_C6TjisG4q28HGZ1xDPuYhdV=tExwFoyw@mail.gmail.com>
Message-ID: <2742040A-D2AC-4FA2-9C09-F10D188A53FA@lmi.net>

Actually, Stephanie is correct -- genBSDF is one of the few Radiance programs that takes MGF input directly.  I supported this feature because the XML format can incorporate the MGF description as a supplement to the computed BSDF.  However, the MGF is also converted to Radiance before computing the actual BSDF, so ultimately, that is the description that matters.

In this case, both MGF and Radiance are equally capable of representing your geometry, which is to say, neither one can do it exactly right.  The NURBs must first be converted to polygons before it can be used, since Radiance does not have a NURBs primitive.  For this operation, you should probably prefer to export in .OBJ format and obj2rad, which will preserve the vertex normals.  Use a fine enough subdivision size that the individual polygons don't undermine your geometric accuracy.  Think in terms of equalling manufacturing tolerances.  You will want to re-describe your materials in native Radiance, however.

I hope this helps.
-Greg

> From: Germ?n Molina Larrain <germolinal at gmail.com>
> Date: February 6, 2017 7:21:20 PM PST
> 
> Hello Stephanie,
> 
> First, I want to clarify that genBSDF uses Radiance format as input, which is not the same as MGF. Actually, MGF is a format with some really cool features, but rarely used (unfortunately?).
> 
> Anyways... Any tool that exports Radiance or MGF formated geometry (which is also readable by Radiance) is useful for generating input for genBSDF. That said, I do not use Rhino, but probably DIVA and Honey Bee or Ladybug can help you on that. Otherwise, there are some SketchUp plugins for exporting Radiance geometry,  which is a tool that allows importing several 3D formats. Finally, I have read several times about Radiance using .OBJ through obj2rad program. I understand that this format is also common, but not suited to model physically realistic materials. 
> 
> So... I think you have several choices. I am pretty sure all these formats are able to model any required geometry, and that the choice you make will be a matter of how easy is to "draw" it.
> 
> Regarding how to input this geometry into genBSDF, you have to place the width of your "window" along the X axis, Height along the Y axis and inside is towards Z axis (i.e. Up). Any geometry over the Z axis is inside the space and will emit a warning. Read the tutorials for more information on this!
> 
> I hope it helps
> 
> best,
> 
> Germ?n
> 
> El 6 feb. 2017 23:07, "Stephanie Truong" <stephanie at dosu-arch.com> escribi?:
> Hi,
> 
> I am attempting to run genBSDF, and was wondering if there is a workflow that allows the use of Rhino/NURBs geometry to convert into MGF format? Ultimately, I am trying to create a BSDF.xml file of a complex shading system. The system is made up of small units which are doubly curved, gradated (depending on orientation to the sun), and symmetrical on one axis. I am unsure if the MGF format is able to model that type of geometry, so it would be helpful to understand how to model geometry to input into the genBSDF command. Let me know if I need to clarify or provide more information. I'm relatively new at this, and any help would be appreciated! 
> 
> 
> 
> Thank you in advance,
> 
> Stephanie Truong
> DOSU | studio architecture
> 
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://www.radiance-online.org/pipermail/radiance-general/attachments/20170206/e97fb38f/attachment.html>

From stephanie at dosu-arch.com  Wed Feb  8 12:34:24 2017
From: stephanie at dosu-arch.com (Stephanie Truong)
Date: Wed, 08 Feb 2017 12:34:24 -0800
Subject: [Radiance-general] Formatting Geometry in Rhino to use genBSDF
In-Reply-To: <2742040A-D2AC-4FA2-9C09-F10D188A53FA@lmi.net>
References: <09a68e2348de431aa7dbcfb2ed6df2ba@dosu-arch.com>
 <CAF-iH4LfLp89TH+Zc_C6TjisG4q28HGZ1xDPuYhdV=tExwFoyw@mail.gmail.com>
 <2742040A-D2AC-4FA2-9C09-F10D188A53FA@lmi.net>
Message-ID: <fe61ad00bfc7fcce1e16afcd76fb08c1@dosu-arch.com>

Thank you so much, this was great help. 

Best,

Stephanie Truong
DOSU | studio architecture
408.387.9112 

On 2017-02-06 21:20, Greg Ward wrote:

> Actually, Stephanie is correct -- genBSDF is one of the few Radiance programs that takes MGF input directly.  I supported this feature because the XML format can incorporate the MGF description as a supplement to the computed BSDF.  However, the MGF is also converted to Radiance before computing the actual BSDF, so ultimately, that is the description that matters. 
> 
> In this case, both MGF and Radiance are equally capable of representing your geometry, which is to say, neither one can do it exactly right.  The NURBs must first be converted to polygons before it can be used, since Radiance does not have a NURBs primitive.  For this operation, you should probably prefer to export in .OBJ format and obj2rad, which will preserve the vertex normals.  Use a fine enough subdivision size that the individual polygons don't undermine your geometric accuracy.  Think in terms of equalling manufacturing tolerances.  You will want to re-describe your materials in native Radiance, however. 
> 
> I hope this helps. 
> -Greg 
> 
>> FROM: Germ?n Molina Larrain <germolinal at gmail.com> 
>> 
>> DATE: February 6, 2017 7:21:20 PM PST
> 
> Hello Stephanie, 
> 
> First, I want to clarify that genBSDF uses Radiance format as input, which is not the same as MGF. Actually, MGF is a format with some really cool features, but rarely used (unfortunately?). 
> 
> Anyways... Any tool that exports Radiance or MGF formated geometry (which is also readable by Radiance) is useful for generating input for genBSDF. That said, I do not use Rhino, but probably DIVA and Honey Bee or Ladybug can help you on that. Otherwise, there are some SketchUp plugins for exporting Radiance geometry,  which is a tool that allows importing several 3D formats. Finally, I have read several times about Radiance using .OBJ through obj2rad program. I understand that this format is also common, but not suited to model physically realistic materials.  
> 
> So... I think you have several choices. I am pretty sure all these formats are able to model any required geometry, and that the choice you make will be a matter of how easy is to "draw" it. 
> 
> Regarding how to input this geometry into genBSDF, you have to place the width of your "window" along the X axis, Height along the Y axis and inside is towards Z axis (i.e. Up). Any geometry over the Z axis is inside the space and will emit a warning. Read the tutorials for more information on this! 
> 
> I hope it helps 
> 
> best, 
> 
> Germ?n 
> 
> El 6 feb. 2017 23:07, "Stephanie Truong" <stephanie at dosu-arch.com> escribi?:
> 
> Hi, 
> 
> I am attempting to run genBSDF, and was wondering if there is a workflow that allows the use of Rhino/NURBs geometry to convert into MGF format? Ultimately, I am trying to create a BSDF.xml file of a complex shading system. The system is made up of small units which are doubly curved, gradated (depending on orientation to the sun), and symmetrical on one axis. I am unsure if the MGF format is able to model that type of geometry, so it would be helpful to understand how to model geometry to input into the genBSDF command. Let me know if I need to clarify or provide more information. I'm relatively new at this, and any help would be appreciated!  
> 
> Thank you in advance,
> 
> Stephanie Truong
> DOSU | studio architecture

_______________________________________________
Radiance-general mailing list
Radiance-general at radiance-online.org
http://www.radiance-online.org/mailman/listinfo/radiance-general
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://www.radiance-online.org/pipermail/radiance-general/attachments/20170208/b0fd6665/attachment.html>

From jacobs.axel at gmail.com  Mon Feb 20 04:01:33 2017
From: jacobs.axel at gmail.com (Axel Jacobs)
Date: Mon, 20 Feb 2017 12:01:33 +0000
Subject: [Radiance-general] Slow spawning of rtrace -n,
 mkillum -n with many light sources
Message-ID: <CA+dqh62ruHFs37K+4EwB=BtcKSSpfrkL9HgtB6J-EC5HRQOX6A@mail.gmail.com>

Dear list,

I'm running some rtrace -n xx calculations, and noticed that there is
only one thread for 30 to 45 minutes, before the -n xx kicks in.  My
scene contains some 6,000 artificial light sources.

The question I have is this:  Is there something within rtrace/mkillum
that is not multi-threaded that is run before the actual ray tracing
part starts (which does honour the -n option)?  I could think of some
light source visibility or intensity test that need to be done before
the actual ray tracing.

Many thanks for your thoughts

Best regards

Axel


From gregoryjward at gmail.com  Mon Feb 20 09:18:55 2017
From: gregoryjward at gmail.com (Greg Ward)
Date: Mon, 20 Feb 2017 09:18:55 -0800
Subject: [Radiance-general] Slow spawning of rtrace -n,
 mkillum -n with many light sources
In-Reply-To: <CA+dqh62ruHFs37K+4EwB=BtcKSSpfrkL9HgtB6J-EC5HRQOX6A@mail.gmail.com>
References: <CA+dqh62ruHFs37K+4EwB=BtcKSSpfrkL9HgtB6J-EC5HRQOX6A@mail.gmail.com>
Message-ID: <D857C449-3BF7-4EFB-99A6-43C0A5BA0AF6@lmi.net>

Hi Axel,

There is quite a bit of initialization code, the goal of which is to get as much common data into shared memory as possible before calling fork().  This reduces the memory footprint of your processes, as well as avoiding redundant work that wouldn't make it go faster, anyway.

Included in this preamble are initializing the photon maps (if any), loading the octree, marking light sources (including virtual sources), and preloading the ambient cache (if one).  It also preloads all object data, including instanced octrees, meshes, pictures used in patterns, and so on.

Even with 6,000 light soruce, marking light sources shouldn't take all that long, *unless* you have "mirror" or "prism" surfaces in your scene.  These will create virtual light sources, multiplying the number of sources potentially by many times.  (Mirror surfaces that face each other are the worst case.)  The virtual light source preamble can take quite some time in such cases, as it tries to eliminate virtual source paths that would never pass light due to obstructions, etc.

If you don't have any mirror or prism surfaces, then I'm not sure why it would be taking so long.

Cheers,
-Greg

> From: Axel Jacobs <jacobs.axel at gmail.com>
> Date: February 20, 2017 4:01:33 AM PST
> 
> Dear list,
> 
> I'm running some rtrace -n xx calculations, and noticed that there is
> only one thread for 30 to 45 minutes, before the -n xx kicks in.  My
> scene contains some 6,000 artificial light sources.
> 
> The question I have is this:  Is there something within rtrace/mkillum
> that is not multi-threaded that is run before the actual ray tracing
> part starts (which does honour the -n option)?  I could think of some
> light source visibility or intensity test that need to be done before
> the actual ray tracing.
> 
> Many thanks for your thoughts
> 
> Best regards
> 
> Axel
> 


From jacobs.axel at gmail.com  Mon Feb 20 09:28:36 2017
From: jacobs.axel at gmail.com (Axel Jacobs)
Date: Mon, 20 Feb 2017 17:28:36 +0000
Subject: [Radiance-general] Slow spawning of rtrace -n,
 mkillum -n with many light sources
In-Reply-To: <D857C449-3BF7-4EFB-99A6-43C0A5BA0AF6@lmi.net>
References: <CA+dqh62ruHFs37K+4EwB=BtcKSSpfrkL9HgtB6J-EC5HRQOX6A@mail.gmail.com>
 <D857C449-3BF7-4EFB-99A6-43C0A5BA0AF6@lmi.net>
Message-ID: <CA+dqh63nwY9YGHuneEiuCakn1Kju2XCPirbwZiMqyLxsSN799g@mail.gmail.com>

Thanks for your answer, Greg.

There are no mirror or prism surfaces in this scene.  Just glass and
plastic.  So this is weird, then.

I did notice this behaviour on previous projects where we had
thousands of light sources, but didn't look into it back then.

Cheers

Axel


On 20 February 2017 at 17:18, Greg Ward <gregoryjward at gmail.com> wrote:
> Hi Axel,
>
> There is quite a bit of initialization code, the goal of which is to get as much common data into shared memory as possible before calling fork().  This reduces the memory footprint of your processes, as well as avoiding redundant work that wouldn't make it go faster, anyway.
>
> Included in this preamble are initializing the photon maps (if any), loading the octree, marking light sources (including virtual sources), and preloading the ambient cache (if one).  It also preloads all object data, including instanced octrees, meshes, pictures used in patterns, and so on.
>
> Even with 6,000 light soruce, marking light sources shouldn't take all that long, *unless* you have "mirror" or "prism" surfaces in your scene.  These will create virtual light sources, multiplying the number of sources potentially by many times.  (Mirror surfaces that face each other are the worst case.)  The virtual light source preamble can take quite some time in such cases, as it tries to eliminate virtual source paths that would never pass light due to obstructions, etc.
>
> If you don't have any mirror or prism surfaces, then I'm not sure why it would be taking so long.
>
> Cheers,
> -Greg
>
>> From: Axel Jacobs <jacobs.axel at gmail.com>
>> Date: February 20, 2017 4:01:33 AM PST
>>
>> Dear list,
>>
>> I'm running some rtrace -n xx calculations, and noticed that there is
>> only one thread for 30 to 45 minutes, before the -n xx kicks in.  My
>> scene contains some 6,000 artificial light sources.
>>
>> The question I have is this:  Is there something within rtrace/mkillum
>> that is not multi-threaded that is run before the actual ray tracing
>> part starts (which does honour the -n option)?  I could think of some
>> light source visibility or intensity test that need to be done before
>> the actual ray tracing.
>>
>> Many thanks for your thoughts
>>
>> Best regards
>>
>> Axel
>>
>
> _______________________________________________
> Radiance-general mailing list
> Radiance-general at radiance-online.org
> http://www.radiance-online.org/mailman/listinfo/radiance-general


From gregoryjward at gmail.com  Mon Feb 20 10:00:14 2017
From: gregoryjward at gmail.com (Greg Ward)
Date: Mon, 20 Feb 2017 10:00:14 -0800
Subject: [Radiance-general] Slow spawning of rtrace -n,
 mkillum -n with many light sources
In-Reply-To: <CA+dqh63nwY9YGHuneEiuCakn1Kju2XCPirbwZiMqyLxsSN799g@mail.gmail.com>
References: <CA+dqh62ruHFs37K+4EwB=BtcKSSpfrkL9HgtB6J-EC5HRQOX6A@mail.gmail.com>
 <D857C449-3BF7-4EFB-99A6-43C0A5BA0AF6@lmi.net>
 <CA+dqh63nwY9YGHuneEiuCakn1Kju2XCPirbwZiMqyLxsSN799g@mail.gmail.com>
Message-ID: <CACBDBD9-BFF8-4E4F-9898-2C2FA4BD711B@lmi.net>

Oh, I just remembered -- there's also the shadow cache, which gets initialized in marksources() as well.  This also ends up tracing some number of rays, about 400 per source, to look for near-source obstructions before the main calculation begins.  So, that could be part of your slow-down.  I guess 6,000 light sources would be about 2.5 million rays to trace, though I have trouble seeing how that would take 45 minutes even on one process.  It should only take a couple of minutes on a modern processor with enough memory to hold the scene.

You could try recompiling with -DSHADCACHE=0, but I don't think you would want to, as the shadow cache is the thing that really saves you with so many light sources.  I'd only do it to determine if that's what slows down the start-up.  (Although it would be an interesting test of the shadow cache under extreme conditions.)

I don't know how to sample running processes on your system, but it would be interesting to find out where rtrace is spending all its time during start-up....

Cheers,
-Greg

P.S.  More info on shadow cache in 2004 workshop program:	http://www.radiance-online.org/community/workshops/2004-fribourg/Ward_talk.pdf

> From: Axel Jacobs <jacobs.axel at gmail.com>
> Date: February 20, 2017 9:28:36 AM PST
> 
> Thanks for your answer, Greg.
> 
> There are no mirror or prism surfaces in this scene.  Just glass and
> plastic.  So this is weird, then.
> 
> I did notice this behaviour on previous projects where we had
> thousands of light sources, but didn't look into it back then.
> 
> Cheers
> 
> Axel
> 
> 
> On 20 February 2017 at 17:18, Greg Ward <gregoryjward at gmail.com> wrote:
>> Hi Axel,
>> 
>> There is quite a bit of initialization code, the goal of which is to get as much common data into shared memory as possible before calling fork().  This reduces the memory footprint of your processes, as well as avoiding redundant work that wouldn't make it go faster, anyway.
>> 
>> Included in this preamble are initializing the photon maps (if any), loading the octree, marking light sources (including virtual sources), and preloading the ambient cache (if one).  It also preloads all object data, including instanced octrees, meshes, pictures used in patterns, and so on.
>> 
>> Even with 6,000 light soruce, marking light sources shouldn't take all that long, *unless* you have "mirror" or "prism" surfaces in your scene.  These will create virtual light sources, multiplying the number of sources potentially by many times.  (Mirror surfaces that face each other are the worst case.)  The virtual light source preamble can take quite some time in such cases, as it tries to eliminate virtual source paths that would never pass light due to obstructions, etc.
>> 
>> If you don't have any mirror or prism surfaces, then I'm not sure why it would be taking so long.
>> 
>> Cheers,
>> -Greg
>> 
>>> From: Axel Jacobs <jacobs.axel at gmail.com>
>>> Date: February 20, 2017 4:01:33 AM PST
>>> 
>>> Dear list,
>>> 
>>> I'm running some rtrace -n xx calculations, and noticed that there is
>>> only one thread for 30 to 45 minutes, before the -n xx kicks in.  My
>>> scene contains some 6,000 artificial light sources.
>>> 
>>> The question I have is this:  Is there something within rtrace/mkillum
>>> that is not multi-threaded that is run before the actual ray tracing
>>> part starts (which does honour the -n option)?  I could think of some
>>> light source visibility or intensity test that need to be done before
>>> the actual ray tracing.
>>> 
>>> Many thanks for your thoughts
>>> 
>>> Best regards
>>> 
>>> Axel


From geotrupes at me.com  Mon Feb 20 11:49:45 2017
From: geotrupes at me.com (Giulio Antonutto)
Date: Mon, 20 Feb 2017 19:49:45 +0000
Subject: [Radiance-general] Slow spawning of rtrace -n,
 mkillum -n with many light sources
In-Reply-To: <CACBDBD9-BFF8-4E4F-9898-2C2FA4BD711B@lmi.net>
References: <CA+dqh62ruHFs37K+4EwB=BtcKSSpfrkL9HgtB6J-EC5HRQOX6A@mail.gmail.com>
 <D857C449-3BF7-4EFB-99A6-43C0A5BA0AF6@lmi.net>
 <CA+dqh63nwY9YGHuneEiuCakn1Kju2XCPirbwZiMqyLxsSN799g@mail.gmail.com>
 <CACBDBD9-BFF8-4E4F-9898-2C2FA4BD711B@lmi.net>
Message-ID: <757FC4FD-C1B5-44CA-9E9F-63CDBFF091E2@me.com>

a good trick from fellow friend colleague Francesco Anselmo is to use glow with a specific distance so only light close enough get cached? use with caution as it is a simplified calculation, but faster.
G.

> On 20 Feb 2017, at 18:00, Greg Ward <gregoryjward at gmail.com> wrote:
> 
> Oh, I just remembered -- there's also the shadow cache, which gets initialized in marksources() as well.  This also ends up tracing some number of rays, about 400 per source, to look for near-source obstructions before the main calculation begins.  So, that could be part of your slow-down.  I guess 6,000 light sources would be about 2.5 million rays to trace, though I have trouble seeing how that would take 45 minutes even on one process.  It should only take a couple of minutes on a modern processor with enough memory to hold the scene.
> 
> You could try recompiling with -DSHADCACHE=0, but I don't think you would want to, as the shadow cache is the thing that really saves you with so many light sources.  I'd only do it to determine if that's what slows down the start-up.  (Although it would be an interesting test of the shadow cache under extreme conditions.)
> 
> I don't know how to sample running processes on your system, but it would be interesting to find out where rtrace is spending all its time during start-up....
> 
> Cheers,
> -Greg
> 
> P.S.  More info on shadow cache in 2004 workshop program:	http://www.radiance-online.org/community/workshops/2004-fribourg/Ward_talk.pdf
> 
>> From: Axel Jacobs <jacobs.axel at gmail.com>
>> Date: February 20, 2017 9:28:36 AM PST
>> 
>> Thanks for your answer, Greg.
>> 
>> There are no mirror or prism surfaces in this scene.  Just glass and
>> plastic.  So this is weird, then.
>> 
>> I did notice this behaviour on previous projects where we had
>> thousands of light sources, but didn't look into it back then.
>> 
>> Cheers
>> 
>> Axel
>> 
>> 
>> On 20 February 2017 at 17:18, Greg Ward <gregoryjward at gmail.com> wrote:
>>> Hi Axel,
>>> 
>>> There is quite a bit of initialization code, the goal of which is to get as much common data into shared memory as possible before calling fork().  This reduces the memory footprint of your processes, as well as avoiding redundant work that wouldn't make it go faster, anyway.
>>> 
>>> Included in this preamble are initializing the photon maps (if any), loading the octree, marking light sources (including virtual sources), and preloading the ambient cache (if one).  It also preloads all object data, including instanced octrees, meshes, pictures used in patterns, and so on.
>>> 
>>> Even with 6,000 light soruce, marking light sources shouldn't take all that long, *unless* you have "mirror" or "prism" surfaces in your scene.  These will create virtual light sources, multiplying the number of sources potentially by many times.  (Mirror surfaces that face each other are the worst case.)  The virtual light source preamble can take quite some time in such cases, as it tries to eliminate virtual source paths that would never pass light due to obstructions, etc.
>>> 
>>> If you don't have any mirror or prism surfaces, then I'm not sure why it would be taking so long.
>>> 
>>> Cheers,
>>> -Greg
>>> 
>>>> From: Axel Jacobs <jacobs.axel at gmail.com>
>>>> Date: February 20, 2017 4:01:33 AM PST
>>>> 
>>>> Dear list,
>>>> 
>>>> I'm running some rtrace -n xx calculations, and noticed that there is
>>>> only one thread for 30 to 45 minutes, before the -n xx kicks in.  My
>>>> scene contains some 6,000 artificial light sources.
>>>> 
>>>> The question I have is this:  Is there something within rtrace/mkillum
>>>> that is not multi-threaded that is run before the actual ray tracing
>>>> part starts (which does honour the -n option)?  I could think of some
>>>> light source visibility or intensity test that need to be done before
>>>> the actual ray tracing.
>>>> 
>>>> Many thanks for your thoughts
>>>> 
>>>> Best regards
>>>> 
>>>> Axel
> 
> _______________________________________________
> Radiance-general mailing list
> Radiance-general at radiance-online.org
> http://www.radiance-online.org/mailman/listinfo/radiance-general



From gregoryjward at gmail.com  Tue Feb 21 13:33:18 2017
From: gregoryjward at gmail.com (Greg Ward)
Date: Tue, 21 Feb 2017 13:33:18 -0800
Subject: [Radiance-general] Slow spawning of rtrace -n,
 mkillum -n with many light sources
In-Reply-To: <757FC4FD-C1B5-44CA-9E9F-63CDBFF091E2@me.com>
References: <CA+dqh62ruHFs37K+4EwB=BtcKSSpfrkL9HgtB6J-EC5HRQOX6A@mail.gmail.com>
 <D857C449-3BF7-4EFB-99A6-43C0A5BA0AF6@lmi.net>
 <CA+dqh63nwY9YGHuneEiuCakn1Kju2XCPirbwZiMqyLxsSN799g@mail.gmail.com>
 <CACBDBD9-BFF8-4E4F-9898-2C2FA4BD711B@lmi.net>
 <757FC4FD-C1B5-44CA-9E9F-63CDBFF091E2@me.com>
Message-ID: <7857009E-D853-407D-AA9E-24FAFCDB6519@lmi.net>

Hi Axel,

Thanks for sending me your model off-list.  Indeed, it is the source obstructor cache initialization that is taking up most of the start-up time.  It's tracing about 8.5 million rays, which would normally be done in about 10 minutes, but seems to be taking longer due to the preponderance of triangle mesh geometry in your model.

The Radiance triangle mesh (.rtm) format was designed to handle complex geometry in the smallest possible memory footprint.  To achieve this, I had to compromise a little on execution time.  In addition to the ray vector transformations that are also required by the "instance" primitive, tracing rays into a triangle mesh is maybe twice as expensive as rendering straight geometry.  If simple geometry is stored in a mesh, then you are paying this price unnecessarily.

To reduce start-up time, I would recommend putting the geometry into octree instances rather than triangle meshes if it's not too complicated, or just use xform if you aren't making multiple copies of the geometry throughout your model.  Having a single instance is wasteful of resources and costs overhead during rendering.

Another thing that will speed up the initialization is to use a frozen octree.  Your 7000 light sources mean 7000 calls to the shell to run xform, and there's no reason to do that except the first time, during octree creation.

Cheers,
-Greg

P.S.  More information on mesh primitive from 2003 workshop:  http://www.radiance-online.org/community/workshops/2003-berkeley/presentations/Ward/Tutorial1.html
Download the PowerPoint tutorial and skip to Section II around slide 42.

> From: Giulio Antonutto <geotrupes at me.com>
> Date: February 20, 2017 11:49:45 AM PST
> 
> a good trick from fellow friend colleague Francesco Anselmo is to use glow with a specific distance so only light close enough get cached? use with caution as it is a simplified calculation, but faster.
> G.
> 
>> On 20 Feb 2017, at 18:00, Greg Ward <gregoryjward at gmail.com> wrote:
>> 
>> Oh, I just remembered -- there's also the shadow cache, which gets initialized in marksources() as well.  This also ends up tracing some number of rays, about 400 per source, to look for near-source obstructions before the main calculation begins.  So, that could be part of your slow-down.  I guess 6,000 light sources would be about 2.5 million rays to trace, though I have trouble seeing how that would take 45 minutes even on one process.  It should only take a couple of minutes on a modern processor with enough memory to hold the scene.
>> 
>> You could try recompiling with -DSHADCACHE=0, but I don't think you would want to, as the shadow cache is the thing that really saves you with so many light sources.  I'd only do it to determine if that's what slows down the start-up.  (Although it would be an interesting test of the shadow cache under extreme conditions.)
>> 
>> I don't know how to sample running processes on your system, but it would be interesting to find out where rtrace is spending all its time during start-up....
>> 
>> Cheers,
>> -Greg
>> 
>> P.S.  More info on shadow cache in 2004 workshop program:	http://www.radiance-online.org/community/workshops/2004-fribourg/Ward_talk.pdf
>> 
>>> From: Axel Jacobs <jacobs.axel at gmail.com>
>>> Date: February 20, 2017 9:28:36 AM PST
>>> 
>>> Thanks for your answer, Greg.
>>> 
>>> There are no mirror or prism surfaces in this scene.  Just glass and
>>> plastic.  So this is weird, then.
>>> 
>>> I did notice this behaviour on previous projects where we had
>>> thousands of light sources, but didn't look into it back then.
>>> 
>>> Cheers
>>> 
>>> Axel
>>> 
>>> 
>>> On 20 February 2017 at 17:18, Greg Ward <gregoryjward at gmail.com> wrote:
>>>> Hi Axel,
>>>> 
>>>> There is quite a bit of initialization code, the goal of which is to get as much common data into shared memory as possible before calling fork().  This reduces the memory footprint of your processes, as well as avoiding redundant work that wouldn't make it go faster, anyway.
>>>> 
>>>> Included in this preamble are initializing the photon maps (if any), loading the octree, marking light sources (including virtual sources), and preloading the ambient cache (if one).  It also preloads all object data, including instanced octrees, meshes, pictures used in patterns, and so on.
>>>> 
>>>> Even with 6,000 light soruce, marking light sources shouldn't take all that long, *unless* you have "mirror" or "prism" surfaces in your scene.  These will create virtual light sources, multiplying the number of sources potentially by many times.  (Mirror surfaces that face each other are the worst case.)  The virtual light source preamble can take quite some time in such cases, as it tries to eliminate virtual source paths that would never pass light due to obstructions, etc.
>>>> 
>>>> If you don't have any mirror or prism surfaces, then I'm not sure why it would be taking so long.
>>>> 
>>>> Cheers,
>>>> -Greg
>>>> 
>>>>> From: Axel Jacobs <jacobs.axel at gmail.com>
>>>>> Date: February 20, 2017 4:01:33 AM PST
>>>>> 
>>>>> Dear list,
>>>>> 
>>>>> I'm running some rtrace -n xx calculations, and noticed that there is
>>>>> only one thread for 30 to 45 minutes, before the -n xx kicks in.  My
>>>>> scene contains some 6,000 artificial light sources.
>>>>> 
>>>>> The question I have is this:  Is there something within rtrace/mkillum
>>>>> that is not multi-threaded that is run before the actual ray tracing
>>>>> part starts (which does honour the -n option)?  I could think of some
>>>>> light source visibility or intensity test that need to be done before
>>>>> the actual ray tracing.
>>>>> 
>>>>> Many thanks for your thoughts
>>>>> 
>>>>> Best regards
>>>>> 
>>>>> Axel


From gregoryjward at gmail.com  Tue Feb 21 19:18:01 2017
From: gregoryjward at gmail.com (Gregory J. Ward)
Date: Tue, 21 Feb 2017 19:18:01 -0800
Subject: [Radiance-general] Slow spawning of rtrace -n,
 mkillum -n with many light sources
In-Reply-To: <7857009E-D853-407D-AA9E-24FAFCDB6519@lmi.net>
References: <CA+dqh62ruHFs37K+4EwB=BtcKSSpfrkL9HgtB6J-EC5HRQOX6A@mail.gmail.com>
 <D857C449-3BF7-4EFB-99A6-43C0A5BA0AF6@lmi.net>
 <CA+dqh63nwY9YGHuneEiuCakn1Kju2XCPirbwZiMqyLxsSN799g@mail.gmail.com>
 <CACBDBD9-BFF8-4E4F-9898-2C2FA4BD711B@lmi.net>
 <757FC4FD-C1B5-44CA-9E9F-63CDBFF091E2@me.com>
 <7857009E-D853-407D-AA9E-24FAFCDB6519@lmi.net>
Message-ID: <6FFD1EAE-619E-42B0-9C93-E6DC472A32B2@gmail.com>

I went ahead and added a limit on the source obstruction code, so it won't precheck more than 200 light sources.  This is an optional optimization, anyway, so I figure it's better not to have this strange problem of taking forever to start up when you have a lot of sources.

Cheers,
-Greg

> From: Greg Ward <gward at lmi.net>
> Date: February 21, 2017 1:33:18 PM PST
> 
> Hi Axel,
> 
> Thanks for sending me your model off-list.  Indeed, it is the source obstructor cache initialization that is taking up most of the start-up time.  It's tracing about 8.5 million rays, which would normally be done in about 10 minutes, but seems to be taking longer due to the preponderance of triangle mesh geometry in your model.
> 
> The Radiance triangle mesh (.rtm) format was designed to handle complex geometry in the smallest possible memory footprint.  To achieve this, I had to compromise a little on execution time.  In addition to the ray vector transformations that are also required by the "instance" primitive, tracing rays into a triangle mesh is maybe twice as expensive as rendering straight geometry.  If simple geometry is stored in a mesh, then you are paying this price unnecessarily.
> 
> To reduce start-up time, I would recommend putting the geometry into octree instances rather than triangle meshes if it's not too complicated, or just use xform if you aren't making multiple copies of the geometry throughout your model.  Having a single instance is wasteful of resources and costs overhead during rendering.
> 
> Another thing that will speed up the initialization is to use a frozen octree.  Your 7000 light sources mean 7000 calls to the shell to run xform, and there's no reason to do that except the first time, during octree creation.
> 
> Cheers,
> -Greg
> 
> P.S.  More information on mesh primitive from 2003 workshop:  http://www.radiance-online.org/community/workshops/2003-berkeley/presentations/Ward/Tutorial1.html
> Download the PowerPoint tutorial and skip to Section II around slide 42.
> 
>> From: Giulio Antonutto <geotrupes at me.com>
>> Date: February 20, 2017 11:49:45 AM PST
>> 
>> a good trick from fellow friend colleague Francesco Anselmo is to use glow with a specific distance so only light close enough get cached? use with caution as it is a simplified calculation, but faster.
>> G.
>> 
>>> On 20 Feb 2017, at 18:00, Greg Ward <gregoryjward at gmail.com> wrote:
>>> 
>>> Oh, I just remembered -- there's also the shadow cache, which gets initialized in marksources() as well.  This also ends up tracing some number of rays, about 400 per source, to look for near-source obstructions before the main calculation begins.  So, that could be part of your slow-down.  I guess 6,000 light sources would be about 2.5 million rays to trace, though I have trouble seeing how that would take 45 minutes even on one process.  It should only take a couple of minutes on a modern processor with enough memory to hold the scene.
>>> 
>>> You could try recompiling with -DSHADCACHE=0, but I don't think you would want to, as the shadow cache is the thing that really saves you with so many light sources.  I'd only do it to determine if that's what slows down the start-up.  (Although it would be an interesting test of the shadow cache under extreme conditions.)
>>> 
>>> I don't know how to sample running processes on your system, but it would be interesting to find out where rtrace is spending all its time during start-up....
>>> 
>>> Cheers,
>>> -Greg
>>> 
>>> P.S.  More info on shadow cache in 2004 workshop program:	http://www.radiance-online.org/community/workshops/2004-fribourg/Ward_talk.pdf
>>> 
>>>> From: Axel Jacobs <jacobs.axel at gmail.com>
>>>> Date: February 20, 2017 9:28:36 AM PST
>>>> 
>>>> Thanks for your answer, Greg.
>>>> 
>>>> There are no mirror or prism surfaces in this scene.  Just glass and
>>>> plastic.  So this is weird, then.
>>>> 
>>>> I did notice this behaviour on previous projects where we had
>>>> thousands of light sources, but didn't look into it back then.
>>>> 
>>>> Cheers
>>>> 
>>>> Axel
>>>> 
>>>> 
>>>> On 20 February 2017 at 17:18, Greg Ward <gregoryjward at gmail.com> wrote:
>>>>> Hi Axel,
>>>>> 
>>>>> There is quite a bit of initialization code, the goal of which is to get as much common data into shared memory as possible before calling fork().  This reduces the memory footprint of your processes, as well as avoiding redundant work that wouldn't make it go faster, anyway.
>>>>> 
>>>>> Included in this preamble are initializing the photon maps (if any), loading the octree, marking light sources (including virtual sources), and preloading the ambient cache (if one).  It also preloads all object data, including instanced octrees, meshes, pictures used in patterns, and so on.
>>>>> 
>>>>> Even with 6,000 light soruce, marking light sources shouldn't take all that long, *unless* you have "mirror" or "prism" surfaces in your scene.  These will create virtual light sources, multiplying the number of sources potentially by many times.  (Mirror surfaces that face each other are the worst case.)  The virtual light source preamble can take quite some time in such cases, as it tries to eliminate virtual source paths that would never pass light due to obstructions, etc.
>>>>> 
>>>>> If you don't have any mirror or prism surfaces, then I'm not sure why it would be taking so long.
>>>>> 
>>>>> Cheers,
>>>>> -Greg
>>>>> 
>>>>>> From: Axel Jacobs <jacobs.axel at gmail.com>
>>>>>> Date: February 20, 2017 4:01:33 AM PST
>>>>>> 
>>>>>> Dear list,
>>>>>> 
>>>>>> I'm running some rtrace -n xx calculations, and noticed that there is
>>>>>> only one thread for 30 to 45 minutes, before the -n xx kicks in.  My
>>>>>> scene contains some 6,000 artificial light sources.
>>>>>> 
>>>>>> The question I have is this:  Is there something within rtrace/mkillum
>>>>>> that is not multi-threaded that is run before the actual ray tracing
>>>>>> part starts (which does honour the -n option)?  I could think of some
>>>>>> light source visibility or intensity test that need to be done before
>>>>>> the actual ray tracing.
>>>>>> 
>>>>>> Many thanks for your thoughts
>>>>>> 
>>>>>> Best regards
>>>>>> 
>>>>>> Axel


From jacobs.axel at gmail.com  Wed Feb 22 01:55:48 2017
From: jacobs.axel at gmail.com (Axel Jacobs)
Date: Wed, 22 Feb 2017 09:55:48 +0000
Subject: [Radiance-general] Slow spawning of rtrace -n,
 mkillum -n with many light sources
In-Reply-To: <CACBDBD9-BFF8-4E4F-9898-2C2FA4BD711B@lmi.net>
References: <CA+dqh62ruHFs37K+4EwB=BtcKSSpfrkL9HgtB6J-EC5HRQOX6A@mail.gmail.com>
 <D857C449-3BF7-4EFB-99A6-43C0A5BA0AF6@lmi.net>
 <CA+dqh63nwY9YGHuneEiuCakn1Kju2XCPirbwZiMqyLxsSN799g@mail.gmail.com>
 <CACBDBD9-BFF8-4E4F-9898-2C2FA4BD711B@lmi.net>
Message-ID: <CA+dqh62ZvfbHVKCKW+Mxz4SsX+FQtgLZgS+Y2CfbdGYNX2Wx3w@mail.gmail.com>

Hi Greg,

thank you so much for solving this riddle.  I have to admit I have
been blissfully unaware of the drawbacks of using RTMs. We use them as
much as possible now, since I have come to appreciate the fast compile
times and small octree sizes this can give us.  However, there have
been quite a few projects where RTMs would take hours to compile,
generating octrees many GB in size.  In such instances, we convert the
OBJs into polygon, but without the normals.  Occasionally, we also
need to go via obj2rad, simply because obj2mesh fails to generate the
RTMs.

Looks as if we need to take a fresh look at our workflow.

Thank you for adding the limit on the source obstruction code.  I'll
try this out in the next few days, and re-run the project

Thanks again

Axel


On 20 February 2017 at 18:00, Greg Ward <gregoryjward at gmail.com> wrote:
> Oh, I just remembered -- there's also the shadow cache, which gets initialized in marksources() as well.  This also ends up tracing some number of rays, about 400 per source, to look for near-source obstructions before the main calculation begins.  So, that could be part of your slow-down.  I guess 6,000 light sources would be about 2.5 million rays to trace, though I have trouble seeing how that would take 45 minutes even on one process.  It should only take a couple of minutes on a modern processor with enough memory to hold the scene.
>
> You could try recompiling with -DSHADCACHE=0, but I don't think you would want to, as the shadow cache is the thing that really saves you with so many light sources.  I'd only do it to determine if that's what slows down the start-up.  (Although it would be an interesting test of the shadow cache under extreme conditions.)
>
> I don't know how to sample running processes on your system, but it would be interesting to find out where rtrace is spending all its time during start-up....
>
> Cheers,
> -Greg
>
> P.S.  More info on shadow cache in 2004 workshop program:       http://www.radiance-online.org/community/workshops/2004-fribourg/Ward_talk.pdf
>
>> From: Axel Jacobs <jacobs.axel at gmail.com>
>> Date: February 20, 2017 9:28:36 AM PST
>>
>> Thanks for your answer, Greg.
>>
>> There are no mirror or prism surfaces in this scene.  Just glass and
>> plastic.  So this is weird, then.
>>
>> I did notice this behaviour on previous projects where we had
>> thousands of light sources, but didn't look into it back then.
>>
>> Cheers
>>
>> Axel
>>
>>
>> On 20 February 2017 at 17:18, Greg Ward <gregoryjward at gmail.com> wrote:
>>> Hi Axel,
>>>
>>> There is quite a bit of initialization code, the goal of which is to get as much common data into shared memory as possible before calling fork().  This reduces the memory footprint of your processes, as well as avoiding redundant work that wouldn't make it go faster, anyway.
>>>
>>> Included in this preamble are initializing the photon maps (if any), loading the octree, marking light sources (including virtual sources), and preloading the ambient cache (if one).  It also preloads all object data, including instanced octrees, meshes, pictures used in patterns, and so on.
>>>
>>> Even with 6,000 light soruce, marking light sources shouldn't take all that long, *unless* you have "mirror" or "prism" surfaces in your scene.  These will create virtual light sources, multiplying the number of sources potentially by many times.  (Mirror surfaces that face each other are the worst case.)  The virtual light source preamble can take quite some time in such cases, as it tries to eliminate virtual source paths that would never pass light due to obstructions, etc.
>>>
>>> If you don't have any mirror or prism surfaces, then I'm not sure why it would be taking so long.
>>>
>>> Cheers,
>>> -Greg
>>>
>>>> From: Axel Jacobs <jacobs.axel at gmail.com>
>>>> Date: February 20, 2017 4:01:33 AM PST
>>>>
>>>> Dear list,
>>>>
>>>> I'm running some rtrace -n xx calculations, and noticed that there is
>>>> only one thread for 30 to 45 minutes, before the -n xx kicks in.  My
>>>> scene contains some 6,000 artificial light sources.
>>>>
>>>> The question I have is this:  Is there something within rtrace/mkillum
>>>> that is not multi-threaded that is run before the actual ray tracing
>>>> part starts (which does honour the -n option)?  I could think of some
>>>> light source visibility or intensity test that need to be done before
>>>> the actual ray tracing.
>>>>
>>>> Many thanks for your thoughts
>>>>
>>>> Best regards
>>>>
>>>> Axel
>
> _______________________________________________
> Radiance-general mailing list
> Radiance-general at radiance-online.org
> http://www.radiance-online.org/mailman/listinfo/radiance-general


From gregoryjward at gmail.com  Wed Feb 22 08:41:49 2017
From: gregoryjward at gmail.com (Greg Ward)
Date: Wed, 22 Feb 2017 08:41:49 -0800
Subject: [Radiance-general] Slow spawning of rtrace -n,
 mkillum -n with many light sources
In-Reply-To: <CA+dqh62ZvfbHVKCKW+Mxz4SsX+FQtgLZgS+Y2CfbdGYNX2Wx3w@mail.gmail.com>
References: <CA+dqh62ruHFs37K+4EwB=BtcKSSpfrkL9HgtB6J-EC5HRQOX6A@mail.gmail.com>
 <D857C449-3BF7-4EFB-99A6-43C0A5BA0AF6@lmi.net>
 <CA+dqh63nwY9YGHuneEiuCakn1Kju2XCPirbwZiMqyLxsSN799g@mail.gmail.com>
 <CACBDBD9-BFF8-4E4F-9898-2C2FA4BD711B@lmi.net>
 <CA+dqh62ZvfbHVKCKW+Mxz4SsX+FQtgLZgS+Y2CfbdGYNX2Wx3w@mail.gmail.com>
Message-ID: <DF4995EC-D4C0-41B6-BD58-FD00D15F1B49@lmi.net>

Hi Axel,

I'd be interested in looking at OBJ files where obj2mesh fails.

Cheers,
-Greg

> From: Axel Jacobs <jacobs.axel at gmail.com>
> Date: February 22, 2017 1:55:48 AM PST
> 
> Hi Greg,
> 
> thank you so much for solving this riddle.  I have to admit I have
> been blissfully unaware of the drawbacks of using RTMs. We use them as
> much as possible now, since I have come to appreciate the fast compile
> times and small octree sizes this can give us.  However, there have
> been quite a few projects where RTMs would take hours to compile,
> generating octrees many GB in size.  In such instances, we convert the
> OBJs into polygon, but without the normals.  Occasionally, we also
> need to go via obj2rad, simply because obj2mesh fails to generate the
> RTMs.
> 
> Looks as if we need to take a fresh look at our workflow.
> 
> Thank you for adding the limit on the source obstruction code.  I'll
> try this out in the next few days, and re-run the project
> 
> Thanks again
> 
> Axel
> 
> 
> On 20 February 2017 at 18:00, Greg Ward <gregoryjward at gmail.com> wrote:
>> Oh, I just remembered -- there's also the shadow cache, which gets initialized in marksources() as well.  This also ends up tracing some number of rays, about 400 per source, to look for near-source obstructions before the main calculation begins.  So, that could be part of your slow-down.  I guess 6,000 light sources would be about 2.5 million rays to trace, though I have trouble seeing how that would take 45 minutes even on one process.  It should only take a couple of minutes on a modern processor with enough memory to hold the scene.
>> 
>> You could try recompiling with -DSHADCACHE=0, but I don't think you would want to, as the shadow cache is the thing that really saves you with so many light sources.  I'd only do it to determine if that's what slows down the start-up.  (Although it would be an interesting test of the shadow cache under extreme conditions.)
>> 
>> I don't know how to sample running processes on your system, but it would be interesting to find out where rtrace is spending all its time during start-up....
>> 
>> Cheers,
>> -Greg
>> 
>> P.S.  More info on shadow cache in 2004 workshop program:       http://www.radiance-online.org/community/workshops/2004-fribourg/Ward_talk.pdf
>> 
>>> From: Axel Jacobs <jacobs.axel at gmail.com>
>>> Date: February 20, 2017 9:28:36 AM PST
>>> 
>>> Thanks for your answer, Greg.
>>> 
>>> There are no mirror or prism surfaces in this scene.  Just glass and
>>> plastic.  So this is weird, then.
>>> 
>>> I did notice this behaviour on previous projects where we had
>>> thousands of light sources, but didn't look into it back then.
>>> 
>>> Cheers
>>> 
>>> Axel
>>> 
>>> 
>>> On 20 February 2017 at 17:18, Greg Ward <gregoryjward at gmail.com> wrote:
>>>> Hi Axel,
>>>> 
>>>> There is quite a bit of initialization code, the goal of which is to get as much common data into shared memory as possible before calling fork().  This reduces the memory footprint of your processes, as well as avoiding redundant work that wouldn't make it go faster, anyway.
>>>> 
>>>> Included in this preamble are initializing the photon maps (if any), loading the octree, marking light sources (including virtual sources), and preloading the ambient cache (if one).  It also preloads all object data, including instanced octrees, meshes, pictures used in patterns, and so on.
>>>> 
>>>> Even with 6,000 light soruce, marking light sources shouldn't take all that long, *unless* you have "mirror" or "prism" surfaces in your scene.  These will create virtual light sources, multiplying the number of sources potentially by many times.  (Mirror surfaces that face each other are the worst case.)  The virtual light source preamble can take quite some time in such cases, as it tries to eliminate virtual source paths that would never pass light due to obstructions, etc.
>>>> 
>>>> If you don't have any mirror or prism surfaces, then I'm not sure why it would be taking so long.
>>>> 
>>>> Cheers,
>>>> -Greg
>>>> 
>>>>> From: Axel Jacobs <jacobs.axel at gmail.com>
>>>>> Date: February 20, 2017 4:01:33 AM PST
>>>>> 
>>>>> Dear list,
>>>>> 
>>>>> I'm running some rtrace -n xx calculations, and noticed that there is
>>>>> only one thread for 30 to 45 minutes, before the -n xx kicks in.  My
>>>>> scene contains some 6,000 artificial light sources.
>>>>> 
>>>>> The question I have is this:  Is there something within rtrace/mkillum
>>>>> that is not multi-threaded that is run before the actual ray tracing
>>>>> part starts (which does honour the -n option)?  I could think of some
>>>>> light source visibility or intensity test that need to be done before
>>>>> the actual ray tracing.
>>>>> 
>>>>> Many thanks for your thoughts
>>>>> 
>>>>> Best regards
>>>>> 
>>>>> Axel
>> 
>> _______________________________________________
>> Radiance-general mailing list
>> Radiance-general at radiance-online.org
>> http://www.radiance-online.org/mailman/listinfo/radiance-general
> 
> _______________________________________________
> Radiance-general mailing list
> Radiance-general at radiance-online.org
> http://www.radiance-online.org/mailman/listinfo/radiance-general


From jacobs.axel at gmail.com  Wed Feb 22 09:11:15 2017
From: jacobs.axel at gmail.com (Axel Jacobs)
Date: Wed, 22 Feb 2017 17:11:15 +0000
Subject: [Radiance-general] Slow spawning of rtrace -n,
 mkillum -n with many light sources
In-Reply-To: <DF4995EC-D4C0-41B6-BD58-FD00D15F1B49@lmi.net>
References: <CA+dqh62ruHFs37K+4EwB=BtcKSSpfrkL9HgtB6J-EC5HRQOX6A@mail.gmail.com>
 <D857C449-3BF7-4EFB-99A6-43C0A5BA0AF6@lmi.net>
 <CA+dqh63nwY9YGHuneEiuCakn1Kju2XCPirbwZiMqyLxsSN799g@mail.gmail.com>
 <CACBDBD9-BFF8-4E4F-9898-2C2FA4BD711B@lmi.net>
 <CA+dqh62ZvfbHVKCKW+Mxz4SsX+FQtgLZgS+Y2CfbdGYNX2Wx3w@mail.gmail.com>
 <DF4995EC-D4C0-41B6-BD58-FD00D15F1B49@lmi.net>
Message-ID: <CA+dqh63EGaxcZ60Q-tB+1+11oqeLQHRL5dwtjYsdB=zazuFxsg@mail.gmail.com>

Hi Greg,

I'll ask around and find you some projects.  Give me a few days, and
I'll get back to you.

Cheers

Axel


On 22 February 2017 at 16:41, Greg Ward <gregoryjward at gmail.com> wrote:
> Hi Axel,
>
> I'd be interested in looking at OBJ files where obj2mesh fails.
>
> Cheers,
> -Greg
>
>> From: Axel Jacobs <jacobs.axel at gmail.com>
>> Date: February 22, 2017 1:55:48 AM PST
>>
>> Hi Greg,
>>
>> thank you so much for solving this riddle.  I have to admit I have
>> been blissfully unaware of the drawbacks of using RTMs. We use them as
>> much as possible now, since I have come to appreciate the fast compile
>> times and small octree sizes this can give us.  However, there have
>> been quite a few projects where RTMs would take hours to compile,
>> generating octrees many GB in size.  In such instances, we convert the
>> OBJs into polygon, but without the normals.  Occasionally, we also
>> need to go via obj2rad, simply because obj2mesh fails to generate the
>> RTMs.
>>
>> Looks as if we need to take a fresh look at our workflow.
>>
>> Thank you for adding the limit on the source obstruction code.  I'll
>> try this out in the next few days, and re-run the project
>>
>> Thanks again
>>
>> Axel
>>
>>
>> On 20 February 2017 at 18:00, Greg Ward <gregoryjward at gmail.com> wrote:
>>> Oh, I just remembered -- there's also the shadow cache, which gets initialized in marksources() as well.  This also ends up tracing some number of rays, about 400 per source, to look for near-source obstructions before the main calculation begins.  So, that could be part of your slow-down.  I guess 6,000 light sources would be about 2.5 million rays to trace, though I have trouble seeing how that would take 45 minutes even on one process.  It should only take a couple of minutes on a modern processor with enough memory to hold the scene.
>>>
>>> You could try recompiling with -DSHADCACHE=0, but I don't think you would want to, as the shadow cache is the thing that really saves you with so many light sources.  I'd only do it to determine if that's what slows down the start-up.  (Although it would be an interesting test of the shadow cache under extreme conditions.)
>>>
>>> I don't know how to sample running processes on your system, but it would be interesting to find out where rtrace is spending all its time during start-up....
>>>
>>> Cheers,
>>> -Greg
>>>
>>> P.S.  More info on shadow cache in 2004 workshop program:       http://www.radiance-online.org/community/workshops/2004-fribourg/Ward_talk.pdf
>>>
>>>> From: Axel Jacobs <jacobs.axel at gmail.com>
>>>> Date: February 20, 2017 9:28:36 AM PST
>>>>
>>>> Thanks for your answer, Greg.
>>>>
>>>> There are no mirror or prism surfaces in this scene.  Just glass and
>>>> plastic.  So this is weird, then.
>>>>
>>>> I did notice this behaviour on previous projects where we had
>>>> thousands of light sources, but didn't look into it back then.
>>>>
>>>> Cheers
>>>>
>>>> Axel
>>>>
>>>>
>>>> On 20 February 2017 at 17:18, Greg Ward <gregoryjward at gmail.com> wrote:
>>>>> Hi Axel,
>>>>>
>>>>> There is quite a bit of initialization code, the goal of which is to get as much common data into shared memory as possible before calling fork().  This reduces the memory footprint of your processes, as well as avoiding redundant work that wouldn't make it go faster, anyway.
>>>>>
>>>>> Included in this preamble are initializing the photon maps (if any), loading the octree, marking light sources (including virtual sources), and preloading the ambient cache (if one).  It also preloads all object data, including instanced octrees, meshes, pictures used in patterns, and so on.
>>>>>
>>>>> Even with 6,000 light soruce, marking light sources shouldn't take all that long, *unless* you have "mirror" or "prism" surfaces in your scene.  These will create virtual light sources, multiplying the number of sources potentially by many times.  (Mirror surfaces that face each other are the worst case.)  The virtual light source preamble can take quite some time in such cases, as it tries to eliminate virtual source paths that would never pass light due to obstructions, etc.
>>>>>
>>>>> If you don't have any mirror or prism surfaces, then I'm not sure why it would be taking so long.
>>>>>
>>>>> Cheers,
>>>>> -Greg
>>>>>
>>>>>> From: Axel Jacobs <jacobs.axel at gmail.com>
>>>>>> Date: February 20, 2017 4:01:33 AM PST
>>>>>>
>>>>>> Dear list,
>>>>>>
>>>>>> I'm running some rtrace -n xx calculations, and noticed that there is
>>>>>> only one thread for 30 to 45 minutes, before the -n xx kicks in.  My
>>>>>> scene contains some 6,000 artificial light sources.
>>>>>>
>>>>>> The question I have is this:  Is there something within rtrace/mkillum
>>>>>> that is not multi-threaded that is run before the actual ray tracing
>>>>>> part starts (which does honour the -n option)?  I could think of some
>>>>>> light source visibility or intensity test that need to be done before
>>>>>> the actual ray tracing.
>>>>>>
>>>>>> Many thanks for your thoughts
>>>>>>
>>>>>> Best regards
>>>>>>
>>>>>> Axel
>>>
>>> _______________________________________________
>>> Radiance-general mailing list
>>> Radiance-general at radiance-online.org
>>> http://www.radiance-online.org/mailman/listinfo/radiance-general
>>
>> _______________________________________________
>> Radiance-general mailing list
>> Radiance-general at radiance-online.org
>> http://www.radiance-online.org/mailman/listinfo/radiance-general
>
> _______________________________________________
> Radiance-general mailing list
> Radiance-general at radiance-online.org
> http://www.radiance-online.org/mailman/listinfo/radiance-general


